<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>C++ - The Guides</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="../../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        
        <!-- MathJax -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="intro.html"><strong>1.</strong> Introduction</a></li><li><a href="chapters/linux/intro.html"><strong>2.</strong> Linux Command Line</a></li><li><ul class="section"><li><a href="chapters/linux/vim.html"><strong>2.1.</strong> vim</a></li><li><a href="chapters/linux/bash.html"><strong>2.2.</strong> scripting</a></li><li><a href="chapters/linux/utils.html"><strong>2.3.</strong> utilities</a></li></ul></li><li><a href="chapters/ccpp/intro.html"><strong>3.</strong> C/C++ Notes</a></li><li><ul class="section"><li><a href="chapters/ccpp/gcc.html"><strong>3.1.</strong> gcc</a></li><li><a href="chapters/ccpp/c.html"><strong>3.2.</strong> C</a></li><li><a href="chapters/ccpp/cpp.html" class="active"><strong>3.3.</strong> C++</a></li></ul></li><li><a href="chapters/algs/intro.html"><strong>4.</strong> Algorithms &amp; Data Structures</a></li><li><ul class="section"><li><a href="chapters/algs/lds.html"><strong>4.1.</strong> Linear Data Structures</a></li><li><a href="chapters/algs/sorting.html"><strong>4.2.</strong> Sorting</a></li><li><a href="chapters/algs/searching.html"><strong>4.3.</strong> Searching</a></li><li><a href="chapters/algs/trees.html"><strong>4.4.</strong> Trees</a></li><li><a href="chapters/algs/graphs.html"><strong>4.5.</strong> Graphs</a></li><li><a href="chapters/algs/dnc.html"><strong>4.6.</strong> Divide &amp; Conquer</a></li><li><a href="chapters/algs/greedy.html"><strong>4.7.</strong> Greedy Algorithms</a></li><li><a href="chapters/algs/dynprog.html"><strong>4.8.</strong> Dynamic Programming</a></li><li><a href="chapters/algs/algs_graphs.html"><strong>4.9.</strong> Graph Algorithms</a></li><li><a href="chapters/algs/linprog.html"><strong>4.10.</strong> Linear Programming</a></li><li><a href="chapters/algs/algs_string.html"><strong>4.11.</strong> String Algorithms</a></li></ul></li><li><a href="chapters/leetcode/main.html"><strong>5.</strong> LeetCode Catalog</a></li><li><a href="chapters/theorynpcomp/intro.html"><strong>6.</strong> Theory of NP-Completeness</a></li><li><ul class="section"><li><a href="chapters/theorynpcomp/theorynpcomp.html"><strong>6.1.</strong> The Theory of NP-Completeness</a></li><li><a href="chapters/theorynpcomp/proofnpcomp.html"><strong>6.2.</strong> Proving NP-Complete Results</a></li></ul></li><li><a href="chapters/ocaml/intro.html"><strong>7.</strong> OCaml Functional Programming</a></li><li><ul class="section"><li><a href="chapters/ocaml/n99exercises.html"><strong>7.1.</strong> 99 Excercises in OCaml</a></li><li><a href="chapters/ocaml/lambdacalc.html"><strong>7.2.</strong> Lambda Calcul</a></li></ul></li><li><a href="chapters/umath/intro.html"><strong>8.</strong> Maths de 1er cycle</a></li><li><ul class="section"><li><a href="chapters/umath/reduction.html"><strong>8.1.</strong> Reduction des Endomorphismes</a></li></ul></li><li><a href="chapters/about/whoami.html"><strong>9.</strong> About</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">The Guides</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="chapters/ccpp/cpp.html#c" id="c"><h1>C++</h1></a>
<p>In C++, a true <code>bool</code> type is available with only <code>true</code> and <code>false</code> values.</p>
<p>In C, <code>'x'</code> and <code>'\n'</code> are of type <code>int</code>. In C++, they are of type <code>char</code>.</p>
<p>Can decorate <code>1000000</code> as <code>1'000'000</code>.</p>
<table><thead><tr><th> C header file </th><th> C++ header file </th></tr></thead><tbody>
<tr><td> <code>assert.h</code> </td><td> <code>cassert</code> </td></tr>
<tr><td> <code>ctype.h</code> </td><td> <code>cctype</code> </td></tr>
<tr><td> <code>errno.h</code> </td><td> <code>cerrno</code> </td></tr>
<tr><td> <code>float.h</code> </td><td> <code>cfloat</code> </td></tr>
<tr><td> <code>limits.h</code> </td><td> <code>climits</code> </td></tr>
<tr><td> <code>math.h</code> </td><td> <code>cmath</code> </td></tr>
<tr><td> <code>stdarg.h</code> </td><td> <code>cstdarg</code> </td></tr>
<tr><td> <code>stddef.h</code> </td><td> <code>cstddef</code> </td></tr>
<tr><td> <code>stdint.h</code> </td><td> <code>cstdint</code> </td></tr>
<tr><td> <code>stdio.h</code> </td><td> <code>cstdio</code> </td></tr>
<tr><td> <code>stdlib.h</code> </td><td> <code>cstdlib</code> </td></tr>
<tr><td> <code>string.h</code> </td><td> <code>cstring</code> </td></tr>
<tr><td> <code>time.h</code> </td><td> <code>ctime</code> </td></tr>
</tbody></table>
<p>Use C function in C++, if function is a common library function or was compiled
by a c compiler.</p>
<pre><code class="language-c">// in.c
#include &lt;stdio.h&gt;

void my_printer(char *s){
  printf(&quot;%s\n&quot;, s);
}
</code></pre>
<p>compile with</p>
<pre><code class="language-bash">gcc -c in.c
</code></pre>
<pre><code class="language-cpp">// extern.cpp
#include &lt;iostream&gt;

extern &quot;C&quot; double sin(double);

extern &quot;C&quot;
{
  double cos(double);
  double tan(double);
  void my_printer(char*);
}

int main(){
  std::cout &lt;&lt; sin(1.0) &lt;&lt; std::endl;
  std::cout &lt;&lt; cos(1.0) &lt;&lt; std::endl;
  std::cout &lt;&lt; tan(1.0) &lt;&lt; std::endl;
  char a[] = {'c', ' ', 'c', 'o', 'd', 'e'};
  my_printer(a);
  return 0;
}
</code></pre>
<p>compile with</p>
<pre><code class="language-bash">g++ -o extern extern.cpp in.o
</code></pre>
<p>In C++ a function can be oveloaded: same name, different signatures
and definitions.</p>
<p>If an overloaded function can handle <code>int</code> and <code>double</code> arguments, a compiler
error occurs if it is invoked on a <code>long</code> value \(\rightarrow\) the compiler
can't know to which type it should cast the <code>long</code>. Do an explicit cast.</p>
<p>Formal paramaters having default values should only be present in the function
declaration. They should not be followed by formal parameters having no default
values.</p>
<p>A namespace declaration can only contain declarations and no definitions, use
extern for namespace variable to avoid defining it and breaking the One
Definition Rule.</p>
<p>Extracting namespace component for use inside of a single compilation unit.</p>
<pre><code class="language-cpp">// ...
y = Math::power(x, 3)*Math::pi;
</code></pre>
<p>becomes</p>
<pre><code class="language-cpp">using Math::power;
using Math::pi;
// ...
y = power(x, 3)*pi;
</code></pre>
<p>Extracting all namespace components, USE ONLY IF A FEW NAMESPACES ARE USED.</p>
<pre><code class="language-cpp">using namespace Math;
</code></pre>
<p>Explicitly use a function in the globale namespace (<em>ie: not declared in any
namespace</em>)</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;

int main(){
    ::printf(&quot;bruh\n&quot;);
    return 0;
}
</code></pre>
<p>Anonymous Namespaces can only contain definitions (any declarations cannot
be accessed bruh). These definitions can only be used in the current compilation
unit.</p>
<pre><code class="language-cpp">namespace {
    int f(n) {return n*n;}
}
</code></pre>
<p>has the same effect as</p>
<pre><code class="language-cpp">static int f(n) {return n*n;}
</code></pre>
<p>all references must be initialized</p>
<pre><code class="language-cpp">double x, y;
double &amp;r = x; // r is a reference to the variable x
r = y; // the variable x now contains the value of the variable y
</code></pre>
<p>Never return a reference to a local variable or to a parameter not
passed by reference (<em>ie passed by value</em>).</p>
<pre><code class="language-cpp">// OK
double&amp; maximum(double&amp; a, double&amp; b){
    return (a&gt;=b)?a:b;
}
// STOOPID
double&amp; maximum(double a, double b){
    return (a&gt;=b)?a:b;
}
</code></pre>
<p>A lot to unpack, but the common idiom is to declare a function receiving const
references and returning a const reference, and an overloaded version which
receives non const references and returns a non const reference.</p>
<pre><code class="language-cpp">double&amp; maxi(double&amp; a, double&amp; b){
    return (a&gt;b) ? a : b;
}
const double&amp; maxi(const double&amp; a, const double&amp; b){
    return (a&gt;b) ? a : b;
}
</code></pre>
<p>a reference must always be initialized or declared extern (<em>initialized in an
other compilation unit</em>).</p>
<pre><code class="language-cpp">double&amp; r1; // NOOOOO
extern double&amp; r2; // OK, make sure it's defined elsewhere
</code></pre>
<p>&quot;References behave like constant pointers who are automatically dereferenced&quot;</p>
<pre><code class="language-cpp">auto i = ... ; // let the compiler deduce the appropriate type
decltype(expr) j = ... ; // declare the variable j as having the same type as expr
</code></pre>
<p>use <code>using</code> instead of <code>typedef</code> in C++</p>
<pre><code class="language-cpp">using txtptr = const char * (*) (double);
using y = x; // y is the new (hopefully more intuitive) name for the type x
</code></pre>
<p>Use <code>nullptr</code> (of type <code>nullptr_t</code>) instead of <code>0</code> or <code>NULL</code>.</p>
<p>Favor the four kinds of modern C++ casts to standard C casts.</p>
<pre><code class="language-cpp">static_cast&lt;new_type&gt;(expr); // use for numeric types
const_cast&lt;new_type&gt;(expr); // get something non constant or non volatile
reinterpret_cast&lt;new_type&gt;(expr); // use for pointer cast, often nonsensical
dynamic_cast&lt;new_type&gt;(expr); // stoopid oop nonsense
</code></pre>
<p>A function whose result is declared to be constexr can be evaluated at compile
time if its arguments are const, constexpr or litterals.</p>
<p><img src="media/constexpr_func.png" alt="" /></p>
<p><code>consteval</code> - specifies that a function is an immediate function, that is,
every call to the function must produce a compile-time constant.</p>
<p><img src="media/consteval.png" alt="" /></p>
<p>Conditionally compile with <code>if constexpr(expr)</code> where <code>expr</code> is an expression
known at compile time.</p>
<pre><code class="language-cpp">static_assert(expr, &quot;message&quot;); // expr must be evaluated at compile time
</code></pre>
<pre><code class="language-cpp">double a[30];
for(double x : a)
    x = 0; // STOOPID, x is a copy of an element of a
for(double&amp; x : a)
    x = 0; // OK, will modify, since x references an element of a
// if large elements, and no modification needed, favor a constant reference
for(const double&amp; x : a) // or const auto&amp;
    std::cout &lt;&lt; x;
</code></pre>
<pre><code class="language-cpp">double *p;
p = new double; // uninitialized
double *x = new double(5); // initialized to value 5
double *y = new double{6}; // initialized to value 6
double *z = new double(); // initialized to 0

double *p = new double[n]; // pointer to first element of
                           // array dynamically allocated
double *p = new double[3]{1.0, 3.0, 3.0}; // initialized version
delete p; // ok
double *q = reinterpret_cast&lt;double*&gt;(malloc(sizeof(int)));
delete q; // NOOOOO, STOOPID
</code></pre>
<p>Anything declared with <code>new[]</code> must be deleted with <code>delete[]</code>.
U.B. .
If a type <code>T</code> aliases an array type, any allocated <code>new T</code> must be unallocated
with <code>delete[]</code></p>
<pre><code class="language-cpp">class TClass {
    private:
    // ... //
    protected:
    // ... //
    public:
    // ... //
}
// if absent, private
// can repeat sections
</code></pre>
<p>In C, <code>struct X</code> declares a type <code>struct X</code>, in C++ it declares a type <code>X</code>
(similar to <code>class X</code>).</p>
<p>Always place class declaration in <code>.h</code> header file with the same name as the
class, place the implementation in a <code>.cpp</code> file with the same filename.</p>
<p><code>this</code> is a constant pointer to the object, it is automatically added to member
methods by compilers.</p>
<p>For a setter, returning <code>*this</code> allows method chaining.</p>
<pre><code class="language-cpp">class T{
  public:
    RT method(params) const; // this method won't modify the object 
};
</code></pre>
<p>If a method does not modify its calling object, declare it <code>const</code>.</p>
<p>A <code>const</code> method cannot call a non <code>const</code> method. It can however call a <code>static</code>
method.</p>
<p>Functions who are friends of a class can access all fields and methods of this
class.</p>
<p>Inline functions must be declared and defined (below) in header files.
The compiler needs the definition.</p>
<p>A method defined in the class declaration is implicitly inline.</p>
<p>Inline functions can't be recursive.</p>
<p>The default constructor is invoked automatically if an object is not initialized.</p>
<p>If fields are initialized (using constants), the default constructor and all
other constructors will not have to initialize the fields. (... helpfull)</p>
<p>If a constructor with parameters exists, the compiler won't provide the default
parameterless constructor. To specifically request it, use:</p>
<pre><code class="language-cpp">class S{
    public:
      S() = default; // request the default parameterless constructor
};
</code></pre>
<pre><code class="language-cpp">class X{
    public:
      X(const X&amp; x); // cloning constructor
};
</code></pre>
<pre><code class="language-cpp">X x;
X y(x); // same as
X y = x; // this
X y{x}; // same as
</code></pre>
<p>Always provide a cloning constructor for classes that have dynamically allocated
fields (pointers, new nonsense ... etc). A cloner for class <code>T</code> has <code>T(const T&amp;)</code>
for a signature.</p>
<pre><code class="language-cpp">class Z{
  // assumed to have a parameterless AND a cloning constructor
  // assumed to be assignable: Z z1, z2; ...; z1 = z2;
};
class X{
  private:
    int k_;
    Z z_;
    X(int k, const Z&amp; z); // constructor
};

// NO, STOOPID
X::X(int k, const Z&amp; z){
  k_ = k;
  z_ = z; // here z_ is initialized first with the parameterless constructor
  // it is then reaffected using the cloning constructor
}

// CHAD
X::X(int k, const Z&amp; z):k_(k), z_(z){ // call the cloning constructor first
}
</code></pre>
<pre><code class="language-cpp">class C{
    public:
      ~C(); // Destructor
};
</code></pre>
<p>the <code>delete</code> operator calls the destructor before freeing the memory dynamically
allocated with <code>new</code>.</p>
<blockquote>
<p>The expression <code>const_cast&lt;T&gt;(v)</code> can be used to change the <code>const</code> or <code>volatile</code>
qualifiers of pointers or references. (Among new-style casts, only <code>const_cast&lt;&gt;</code>
can remove const qualifiers.) <code>T</code> must be a pointer, reference, or
pointer-to-member type.</p>
</blockquote>
<p>If an object can have multiple equivalent physical representations, consider
using the <code>mutable</code> qualifier on fields that should be modifiable even if the
object is declared <code>const</code>.</p>
<p><code>mutable</code> vs <code>const_cast&lt;...&gt;(this)</code> : EPIC FIGHT</p>
<ul>
<li><code>const_cast</code>: make all fields modifiable, just now</li>
<li><code>mutable</code>: permits modification of the class member declared mutable even if
the containing object is declared const.</li>
</ul>
<p>Operators that cannot be overloaded: <code>::</code>, <code>.*</code>, <code>.</code>, <code>?:</code>, <code>sizeof</code>.</p>
<p><code>=</code>, <code>[]</code>, <code>()</code>, <code>-&gt;</code>: always overload these operators with methods.</p>
<p><code>T&amp; operator=(const T&amp;);</code> is the proper signature for the overloaded assignement
operator.</p>
<p><code>ostream&amp; operator&lt;&lt;(ostream&amp;, const T&amp;)</code> is the (only) proper signature for
the overloaded <code>&lt;&lt;</code> operator.</p>
<p><code>istream&amp; operator&lt;&lt;(ostream&amp;, T&amp;)</code> is the (only) proper signature for
the overloaded <code>&gt;&gt;</code> operator.</p>
<p>Call a method from within these two overloaded operators; this allows for
subclasses to define their own standards for stream operations \(\rightarrow\)
polymorphism.</p>
<p><code>x[j]</code> is equivalent to <code>x.operator[](j)</code></p>
<p><code>explicit</code> specifies that a constructor is explicit, that is, it cannot be
used for implicit conversions and copy-initialization.</p>
<p>To convert an instance of class <code>T</code> into an instance of type <code>X</code>:</p>
<pre><code class="language-cpp">T t;
X x;
x = t; // is equivalent to 
x = t.operator X(); // this
T.operator X() // -&gt; convert the instance of type T into an equivalent instance of type X
</code></pre>
<pre><code class="language-cpp">class A 
{
    public:
       int x;
    protected:
       int y;
    private:
       int z;
};

class B : public A
{
    // x is public
    // y is protected
    // z is not accessible from B
};

class C : protected A
{
    // x is protected
    // y is protected
    // z is not accessible from C
};

class D : private A    // 'private' is default for classes
{
    // x is private
    // y is private
    // z is not accessible from D
};
</code></pre>
<p>Constructors are never inherited.</p>
<p>Always call the parent constructor in the inherited constructor.</p>
<pre><code class="language-cpp">class Y{
  private:
  T1 t1_;
  public:
  Y(T1 t1);
};

Y::Y(T1 t1){
  t1_ = t1;
}

class X : public Y{
  private:
  T2 t2_;
  public: 
    X(T1 t1, T2 t2);
};

X::X(T1 t1, T2 t2) : Y(t1){
  t2_ = t2;
}
</code></pre>
<pre><code class="language-cpp">// multiple inheritance
class Child: public parent1, private parent2 {};
</code></pre>
<p>A pointer (or reference) to class <code>T</code> used to call method <code>m()</code>
uses the definition of <code>m</code> in the class <code>T</code>, even if the pointed instance is of
a subclass of <code>T</code> which overrides <code>m</code>.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class X {
public:
  void do_smthg();
  virtual void do_smthg_else();
};

class Y : public X{
public:
  void do_smthg();
  void do_smthg_else() override;
};

void Y::do_smthg(){
  cout &lt;&lt; &quot;y do\n&quot;;
}

void Y::do_smthg_else(){
  cout &lt;&lt; &quot;y do\n&quot;;
}

void X::do_smthg(){
  cout &lt;&lt; &quot;x do\n&quot;;
}

void X::do_smthg_else(){
  cout &lt;&lt; &quot;x do\n&quot;;
}

int main(){
  X *a[3];
  a[0] = new Y();
  a[0]-&gt;do_smthg(); // x do: static dispatch
  a[0]-&gt;do_smthg_else(); // y do: dynamic dispatch
  return 0;
}
</code></pre>
<p>use <code>virtual</code> on base type, <code>virtual</code> or preferrably <code>override</code> on the child
type.</p>
<p><code>static</code> methods (class methods) and constructors cannot be virtual.</p>
<p>A call to a virtual method in the constructor of a base class uses the definition
of the method in the base class. Avoid calling virtual methods in a constructor.</p>
<p>If polymorphism is used, USE A VIRTUAL DESTRUCTOR. Why ? Because.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="chapters/ccpp/c.html" class="mobile-nav-chapters previous" title="Previous chapter">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="chapters/algs/intro.html" class="mobile-nav-chapters next" title="Next chapter">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="chapters/ccpp/c.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="chapters/algs/intro.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        
        <script type="text/javascript" src="highlightjs-line-numbers.js"></script>
        

    </body>
</html>
