<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>C++ - The Guides</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="../../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        
        <!-- MathJax -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="intro.html"><strong>1.</strong> Introduction</a></li><li><a href="chapters/linux/intro.html"><strong>2.</strong> Linux Command Line</a></li><li><ul class="section"><li><a href="chapters/linux/vim.html"><strong>2.1.</strong> vim &amp; neovim</a></li><li><a href="chapters/linux/bash.html"><strong>2.2.</strong> scripting</a></li><li><a href="chapters/linux/utils.html"><strong>2.3.</strong> utilities</a></li></ul></li><li><a href="chapters/ccpp/intro.html"><strong>3.</strong> C/C++ Notes</a></li><li><ul class="section"><li><a href="chapters/ccpp/gcc.html"><strong>3.1.</strong> gcc</a></li><li><a href="chapters/ccpp/c.html"><strong>3.2.</strong> C</a></li><li><a href="chapters/ccpp/cpp.html" class="active"><strong>3.3.</strong> C++</a></li></ul></li><li><a href="chapters/algs/intro.html"><strong>4.</strong> Algorithms &amp; Data Structures</a></li><li><ul class="section"><li><a href="chapters/algs/lds.html"><strong>4.1.</strong> Linear Data Structures</a></li><li><a href="chapters/algs/sorting.html"><strong>4.2.</strong> Sorting</a></li><li><a href="chapters/algs/searching.html"><strong>4.3.</strong> Searching</a></li><li><a href="chapters/algs/trees.html"><strong>4.4.</strong> Trees</a></li><li><a href="chapters/algs/graphs.html"><strong>4.5.</strong> Graphs</a></li><li><a href="chapters/algs/dnc.html"><strong>4.6.</strong> Divide &amp; Conquer</a></li><li><a href="chapters/algs/greedy.html"><strong>4.7.</strong> Greedy Algorithms</a></li><li><a href="chapters/algs/dynprog.html"><strong>4.8.</strong> Dynamic Programming</a></li><li><a href="chapters/algs/algs_graphs.html"><strong>4.9.</strong> Graph Algorithms</a></li><li><a href="chapters/algs/linprog.html"><strong>4.10.</strong> Linear Programming</a></li><li><a href="chapters/algs/algs_string.html"><strong>4.11.</strong> String Algorithms</a></li></ul></li><li><a href="chapters/leetcode/main.html"><strong>5.</strong> LeetCode Catalog</a></li><li><a href="chapters/theorynpcomp/intro.html"><strong>6.</strong> Theory of NP-Completeness</a></li><li><ul class="section"><li><a href="chapters/theorynpcomp/theorynpcomp.html"><strong>6.1.</strong> The Theory of NP-Completeness</a></li><li><a href="chapters/theorynpcomp/proofnpcomp.html"><strong>6.2.</strong> Proving NP-Complete Results</a></li></ul></li><li><a href="chapters/ocaml/intro.html"><strong>7.</strong> OCaml Functional Programming</a></li><li><ul class="section"><li><a href="chapters/ocaml/n99exercises.html"><strong>7.1.</strong> 99 Excercises in OCaml</a></li><li><a href="chapters/ocaml/lambdacalc.html"><strong>7.2.</strong> Lambda Calcul</a></li></ul></li><li><a href="chapters/umath/intro.html"><strong>8.</strong> Maths de 1er cycle</a></li><li><ul class="section"><li><a href="chapters/umath/reduction.html"><strong>8.1.</strong> Reduction des Endomorphismes</a></li></ul></li><li><a href="chapters/about/whoami.html"><strong>9.</strong> About</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">The Guides</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="chapters/ccpp/cpp.html#c" id="c"><h1>C++</h1></a>
<p>In C++, a true <code>bool</code> type is available with only <code>true</code> and <code>false</code> values.</p>
<p>In C, <code>'x'</code> and <code>'\n'</code> are of type <code>int</code>. In C++, they are of type <code>char</code>.</p>
<p>Can decorate <code>1000000</code> as <code>1'000'000</code>.</p>
<table><thead><tr><th> C header file </th><th> C++ header file </th></tr></thead><tbody>
<tr><td> <code>assert.h</code> </td><td> <code>cassert</code> </td></tr>
<tr><td> <code>ctype.h</code> </td><td> <code>cctype</code> </td></tr>
<tr><td> <code>errno.h</code> </td><td> <code>cerrno</code> </td></tr>
<tr><td> <code>float.h</code> </td><td> <code>cfloat</code> </td></tr>
<tr><td> <code>limits.h</code> </td><td> <code>climits</code> </td></tr>
<tr><td> <code>math.h</code> </td><td> <code>cmath</code> </td></tr>
<tr><td> <code>stdarg.h</code> </td><td> <code>cstdarg</code> </td></tr>
<tr><td> <code>stddef.h</code> </td><td> <code>cstddef</code> </td></tr>
<tr><td> <code>stdint.h</code> </td><td> <code>cstdint</code> </td></tr>
<tr><td> <code>stdio.h</code> </td><td> <code>cstdio</code> </td></tr>
<tr><td> <code>stdlib.h</code> </td><td> <code>cstdlib</code> </td></tr>
<tr><td> <code>string.h</code> </td><td> <code>cstring</code> </td></tr>
<tr><td> <code>time.h</code> </td><td> <code>ctime</code> </td></tr>
</tbody></table>
<p>Use C function in C++, if function is a common library function or was compiled
by a c compiler.</p>
<pre><code class="language-c">// in.c
#include &lt;stdio.h&gt;

void my_printer(char *s){
  printf(&quot;%s\n&quot;, s);
}
</code></pre>
<p>compile with</p>
<pre><code class="language-bash">gcc -c in.c
</code></pre>
<pre><code class="language-cpp">// extern.cpp
#include &lt;iostream&gt;

extern &quot;C&quot; double sin(double);

extern &quot;C&quot;
{
  double cos(double);
  double tan(double);
  void my_printer(char*);
}

int main(){
  std::cout &lt;&lt; sin(1.0) &lt;&lt; std::endl;
  std::cout &lt;&lt; cos(1.0) &lt;&lt; std::endl;
  std::cout &lt;&lt; tan(1.0) &lt;&lt; std::endl;
  char a[] = {'c', ' ', 'c', 'o', 'd', 'e'};
  my_printer(a);
  return 0;
}
</code></pre>
<p>compile with</p>
<pre><code class="language-bash">g++ -o extern extern.cpp in.o
</code></pre>
<p>In C++ a function can be oveloaded: same name, different signatures
and definitions.</p>
<p>If an overloaded function can handle <code>int</code> and <code>double</code> arguments, a compiler
error occurs if it is invoked on a <code>long</code> value \(\rightarrow\) the compiler
can't know to which type it should cast the <code>long</code>. Do an explicit cast.</p>
<p>Formal paramaters having default values should only be present in the function
declaration. They should not be followed by formal parameters having no default
values.</p>
<p>A namespace declaration can only contain declarations and no definitions, use
extern for namespace variable to avoid defining it and breaking the One
Definition Rule.</p>
<p>Extracting namespace component for use inside of a single compilation unit.</p>
<pre><code class="language-cpp">// ...
y = Math::power(x, 3)*Math::pi;
</code></pre>
<p>becomes</p>
<pre><code class="language-cpp">using Math::power;
using Math::pi;
// ...
y = power(x, 3)*pi;
</code></pre>
<p>Extracting all namespace components, USE ONLY IF A FEW NAMESPACES ARE USED.</p>
<pre><code class="language-cpp">using namespace Math;
</code></pre>
<p>Explicitly use a function in the globale namespace (<em>ie: not declared in any
namespace</em>)</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;

int main(){
    ::printf(&quot;bruh\n&quot;);
    return 0;
}
</code></pre>
<p>Anonymous Namespaces can only contain definitions (any declarations cannot
be accessed bruh). These definitions can only be used in the current compilation
unit.</p>
<pre><code class="language-cpp">namespace {
    int f(n) {return n*n;}
}
</code></pre>
<p>has the same effect as</p>
<pre><code class="language-cpp">static int f(n) {return n*n;}
</code></pre>
<p>all references must be initialized</p>
<pre><code class="language-cpp">double x, y;
double &amp;r = x; // r is a reference to the variable x
r = y; // the variable x now contains the value of the variable y
</code></pre>
<p>Never return a reference to a local variable or to a parameter not
passed by reference (<em>ie passed by value</em>).</p>
<pre><code class="language-cpp">// OK
double&amp; maximum(double&amp; a, double&amp; b){
    return (a&gt;=b)?a:b;
}
// STOOPID
double&amp; maximum(double a, double b){
    return (a&gt;=b)?a:b;
}
</code></pre>
<p>A lot to unpack, but the common idiom is to declare a function receiving const
references and returning a const reference, and an overloaded version which
receives non const references and returns a non const reference.</p>
<pre><code class="language-cpp">double&amp; maxi(double&amp; a, double&amp; b){
    return (a&gt;b) ? a : b;
}
const double&amp; maxi(const double&amp; a, const double&amp; b){
    return (a&gt;b) ? a : b;
}
</code></pre>
<p>a reference must always be initialized or declared extern (<em>initialized in an
other compilation unit</em>).</p>
<pre><code class="language-cpp">double&amp; r1; // NOOOOO
extern double&amp; r2; // OK, make sure it's defined elsewhere
</code></pre>
<p>&quot;References behave like constant pointers who are automatically dereferenced&quot;</p>
<pre><code class="language-cpp">auto i = ... ; // let the compiler deduce the appropriate type
decltype(expr) j = ... ; // declare the variable j as having the same type as expr
</code></pre>
<p>use <code>using</code> instead of <code>typedef</code> in C++</p>
<pre><code class="language-cpp">using txtptr = const char * (*) (double);
using y = x; // y is the new (hopefully more intuitive) name for the type x
</code></pre>
<p>Use <code>nullptr</code> (of type <code>nullptr_t</code>) instead of <code>0</code> or <code>NULL</code>.</p>
<p>Favor the four kinds of modern C++ casts to standard C casts.</p>
<pre><code class="language-cpp">static_cast&lt;new_type&gt;(expr); // use for numeric types
const_cast&lt;new_type&gt;(expr); // get something non constant or non volatile
reinterpret_cast&lt;new_type&gt;(expr); // use for pointer cast, often nonsensical
dynamic_cast&lt;new_type&gt;(expr); // stoopid oop nonsense
</code></pre>
<p>A function whose result is declared to be constexr can be evaluated at compile
time if its arguments are const, constexpr or litterals.</p>
<p><img src="media/constexpr_func.png" alt="" /></p>
<p><code>consteval</code> - specifies that a function is an immediate function, that is,
every call to the function must produce a compile-time constant.</p>
<p><img src="media/consteval.png" alt="" /></p>
<p>Conditionally compile with <code>if constexpr(expr)</code> where <code>expr</code> is an expression
known at compile time.</p>
<pre><code class="language-cpp">static_assert(expr, &quot;message&quot;); // expr must be evaluated at compile time
</code></pre>
<pre><code class="language-cpp">double a[30];
for(double x : a)
    x = 0; // STOOPID, x is a copy of an element of a
for(double&amp; x : a)
    x = 0; // OK, will modify, since x references an element of a
// if large elements, and no modification needed, favor a constant reference
for(const double&amp; x : a) // or const auto&amp;
    std::cout &lt;&lt; x;
</code></pre>
<pre><code class="language-cpp">double *p;
p = new double; // uninitialized
double *x = new double(5); // initialized to value 5
double *y = new double{6}; // initialized to value 6
double *z = new double(); // initialized to 0

double *p = new double[n]; // pointer to first element of
                           // array dynamically allocated
double *p = new double[3]{1.0, 3.0, 3.0}; // initialized version
delete p; // ok
double *q = reinterpret_cast&lt;double*&gt;(malloc(sizeof(int)));
delete q; // NOOOOO, STOOPID
</code></pre>
<p>Anything declared with <code>new[]</code> must be deleted with <code>delete[]</code>.
U.B. .
If a type <code>T</code> aliases an array type, any allocated <code>new T</code> must be unallocated
with <code>delete[]</code></p>
<pre><code class="language-cpp">class TClass {
    private:
    // ... //
    protected:
    // ... //
    public:
    // ... //
}
// if absent, private
// can repeat sections
</code></pre>
<p>In C, <code>struct X</code> declares a type <code>struct X</code>, in C++ it declares a type <code>X</code>
(similar to <code>class X</code>).</p>
<p>Always place class declaration in <code>.h</code> header file with the same name as the
class, place the implementation in a <code>.cpp</code> file with the same filename.</p>
<p><code>this</code> is a constant pointer to the object, it is automatically added to member
methods by compilers.</p>
<p>For a setter, returning <code>*this</code> allows method chaining.</p>
<pre><code class="language-cpp">class T{
  public:
    RT method(params) const; // this method won't modify the object 
};
</code></pre>
<p>If a method does not modify its calling object, declare it <code>const</code>.</p>
<p>A <code>const</code> method cannot call a non <code>const</code> method. It can however call a <code>static</code>
method.</p>
<p>Functions who are friends of a class can access all fields and methods of this
class.</p>
<p>Inline functions must be declared and defined (below) in header files.
The compiler needs the definition.</p>
<p>A method defined in the class declaration is implicitly inline.</p>
<p>Inline functions can't be recursive.</p>
<p>The default constructor is invoked automatically if an object is not initialized.</p>
<p>If fields are initialized (using constants), the default constructor and all
other constructors will not have to initialize the fields. (... helpfull)</p>
<p>If a constructor with parameters exists, the compiler won't provide the default
parameterless constructor. To specifically request it, use:</p>
<pre><code class="language-cpp">class S{
    public:
      S() = default; // request the default parameterless constructor
};
</code></pre>
<pre><code class="language-cpp">class X{
    public:
      X(const X&amp; x); // cloning constructor
};
</code></pre>
<pre><code class="language-cpp">X x;
X y(x); // same as
X y = x; // this
X y{x}; // same as
</code></pre>
<p>Always provide a cloning constructor for classes that have dynamically allocated
fields (pointers, new nonsense ... etc). A cloner for class <code>T</code> has <code>T(const T&amp;)</code>
for a signature.</p>
<pre><code class="language-cpp">class Z{
  // assumed to have a parameterless AND a cloning constructor
  // assumed to be assignable: Z z1, z2; ...; z1 = z2;
};
class X{
  private:
    int k_;
    Z z_;
    X(int k, const Z&amp; z); // constructor
};

// NO, STOOPID
X::X(int k, const Z&amp; z){
  k_ = k;
  z_ = z; // here z_ is initialized first with the parameterless constructor
  // it is then reaffected using the cloning constructor
}

// CHAD
X::X(int k, const Z&amp; z):k_(k), z_(z){ // call the cloning constructor first
}
</code></pre>
<pre><code class="language-cpp">class C{
    public:
      ~C(); // Destructor
};
</code></pre>
<p>the <code>delete</code> operator calls the destructor before freeing the memory dynamically
allocated with <code>new</code>.</p>
<blockquote>
<p>The expression <code>const_cast&lt;T&gt;(v)</code> can be used to change the <code>const</code> or <code>volatile</code>
qualifiers of pointers or references. (Among new-style casts, only <code>const_cast&lt;&gt;</code>
can remove const qualifiers.) <code>T</code> must be a pointer, reference, or
pointer-to-member type.</p>
</blockquote>
<p>If an object can have multiple equivalent physical representations, consider
using the <code>mutable</code> qualifier on fields that should be modifiable even if the
object is declared <code>const</code>.</p>
<p><code>mutable</code> vs <code>const_cast&lt;...&gt;(this)</code> : EPIC FIGHT</p>
<ul>
<li><code>const_cast</code>: make all fields modifiable, just now</li>
<li><code>mutable</code>: permits modification of the class member declared mutable even if
the containing object is declared const.</li>
</ul>
<p>Operators that cannot be overloaded: <code>::</code>, <code>.*</code>, <code>.</code>, <code>?:</code>, <code>sizeof</code>.</p>
<p><code>=</code>, <code>[]</code>, <code>()</code>, <code>-&gt;</code>: always overload these operators with methods.</p>
<p><code>T&amp; operator=(const T&amp;);</code> is the proper signature for the overloaded assignement
operator.</p>
<p><code>ostream&amp; operator&lt;&lt;(ostream&amp;, const T&amp;)</code> is the (only) proper signature for
the overloaded <code>&lt;&lt;</code> operator.</p>
<p><code>istream&amp; operator&lt;&lt;(ostream&amp;, T&amp;)</code> is the (only) proper signature for
the overloaded <code>&gt;&gt;</code> operator.</p>
<p>Call a method from within these two overloaded operators; this allows for
subclasses to define their own standards for stream operations \(\rightarrow\)
polymorphism.</p>
<p><code>x[j]</code> is equivalent to <code>x.operator[](j)</code></p>
<p><code>explicit</code> specifies that a constructor is explicit, that is, it cannot be
used for implicit conversions and copy-initialization.</p>
<p>To convert an instance of class <code>T</code> into an instance of type <code>X</code>:</p>
<pre><code class="language-cpp">T t;
X x;
x = t; // is equivalent to 
x = t.operator X(); // this
T.operator X() // -&gt; convert the instance of type T into an equivalent instance of type X
</code></pre>
<pre><code class="language-cpp">class A 
{
    public:
       int x;
    protected:
       int y;
    private:
       int z;
};

class B : public A
{
    // x is public
    // y is protected
    // z is not accessible from B
};

class C : protected A
{
    // x is protected
    // y is protected
    // z is not accessible from C
};

class D : private A    // 'private' is default for classes
{
    // x is private
    // y is private
    // z is not accessible from D
};
</code></pre>
<p>Constructors are never inherited.</p>
<p>Always call the parent constructor in the inherited constructor.</p>
<pre><code class="language-cpp">class Y{
  private:
  T1 t1_;
  public:
  Y(T1 t1);
};

Y::Y(T1 t1){
  t1_ = t1;
}

class X : public Y{
  private:
  T2 t2_;
  public: 
    X(T1 t1, T2 t2);
};

X::X(T1 t1, T2 t2) : Y(t1){
  t2_ = t2;
}
</code></pre>
<pre><code class="language-cpp">// multiple inheritance
class Child: public parent1, private parent2 {};
</code></pre>
<p>A pointer (or reference) to class <code>T</code> used to call method <code>m()</code>
uses the definition of <code>m</code> in the class <code>T</code>, even if the pointed instance is of
a subclass of <code>T</code> which overrides <code>m</code>.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class X {
public:
  void do_smthg();
  virtual void do_smthg_else();
};

class Y : public X{
public:
  void do_smthg();
  void do_smthg_else() override;
};

void Y::do_smthg(){
  cout &lt;&lt; &quot;y do\n&quot;;
}

void Y::do_smthg_else(){
  cout &lt;&lt; &quot;y do\n&quot;;
}

void X::do_smthg(){
  cout &lt;&lt; &quot;x do\n&quot;;
}

void X::do_smthg_else(){
  cout &lt;&lt; &quot;x do\n&quot;;
}

int main(){
  X *a[3];
  a[0] = new Y();
  a[0]-&gt;do_smthg(); // x do: static dispatch
  a[0]-&gt;do_smthg_else(); // y do: dynamic dispatch
  return 0;
}
</code></pre>
<p>use <code>virtual</code> on base type, <code>virtual</code> or preferrably <code>override</code> on the child
type.</p>
<p><code>static</code> methods (class methods) and constructors cannot be virtual.</p>
<p>A call to a virtual method in the constructor of a base class uses the definition
of the method in the base class. Avoid calling virtual methods in a constructor.</p>
<p>If polymorphism is used, USE A VIRTUAL DESTRUCTOR. Why ? Because.</p>
<p>If you have a virtual function that is not abstract, then you must implement it.</p>
<p>To declare a method abstract:</p>
<pre><code class="language-cpp">virtual qualifiers returntype method(params) qualifiers = 0;
// also called pure virtual method
</code></pre>
<p>A class having at least one abstract method is considered abstract,
it can't be instanciated (incomplete class).</p>
<p>An interface is a class that only contains pure virtual methods.</p>
<blockquote>
<p>A destructor can be declared virtual (10.3) or pure virtual (10.4); if any
objects of that class or any derived class are created in the program,
the destructor shall be defined. If a class has a base class with a virtual
destructor, its destructor (whether user- or implicitly-declared) is virtual.</p>
</blockquote>
<p>The destructor of a base class is always called from the destructor of the
derived class, even if it is declared virtual pure. It must always be
implemented.</p>
<p>An abstract subclass of an abstract class can implement part of a virtual pure
method, and still declare it virtual pure; its subclasses can then call its
implementation in their (hopefully) final implementation. Still, DECLARE IT
VIRTUAL PURE.</p>
<p>If a method is supposed to override a virtual method in a base class, use the
<code>override</code> keyword, this way if the method signatures don't match (forgot
<code>const</code> for example), there will be a compile time error.</p>
<p>To overload a method in a base class, reinject it into the scope
<code>using Base::method;</code>.
See unqualified name lookup in
<a href="https://stackoverflow.com/questions/35870081/c-base-class-function-overloading-in-a-subclass">StackOverflow</a>
and <a href="https://en.cppreference.com/w/cpp/language/unqualified_lookup">cppreference</a>.</p>
<p>Templates</p>
<pre><code class="language-cpp">template &lt;int k, typename R, typename T&gt;
T f(R){
  for(int n=0; n&lt;k; k++) 
   // ...
}
</code></pre>
<p>either a type <code>T</code> or <code>int</code> param or <code>bool</code> param. can also be used for a class.</p>
<p>template default values</p>
<pre><code class="language-cpp">template &lt;int d, typename NT&gt; // ok
class X{
  // ...
};
template &lt;int d, typename NT=double&gt; // ok
class X{
  // ...
};
template &lt;int d=3, typename NT=double&gt; // ok
class X{
  // ...
};
X&lt;&gt; ; // ok
X&lt;2&gt; ; // ok
X&lt;2,double&gt; ; // ok
X&lt;,double&gt; ; // no

template &lt;int d=3, typename NT&gt; // NOOOO
class X{
  // ...
};
</code></pre>
<p>Stack allocated objects created within a try bloc before an exception is thrown
are automatically deleted. (NOT tru for dynamically allocated objects with new).</p>
<pre><code class="language-cpp">try{
  int k;
  std::cin &gt;&gt; k;
  if(k&lt;0)
    throw k;
  else if(k==0)
    throw std::exception;
}catch(int i){
  // if exception is of type int, execute this and jump after all catch blocks
}catch(std::exception e){
}
</code></pre>
<p>Standard Exceptions are in the header <code>&lt;stdexcept&gt;</code>,
they all inherit from <code>std::exception</code>.</p>
<p>Favor using exception classes instead of string and numeric constants in catch
block parameters. (create classes that inherit from the std::exception class).</p>
<ul>
<li>An exception forces calling code to recognize an error condition and handle it. Unhandled exceptions stop program execution.</li>
<li>An exception jumps to the point in the call stack that can handle the error. Intermediate functions can let the exception propagate. They don't have to coordinate with other layers.</li>
<li>The exception stack-unwinding mechanism destroys all objects in scope after an exception is thrown, according to well-defined rules.</li>
<li>An exception enables a clean separation between the code that detects the error and the code that handles the error.</li>
</ul>
<pre><code class="language-cpp">try{
  executeProgram();
}catch(...){ // universal exception handler, catch all exceptions, unknown
  prepareProgramStop();
}
</code></pre>
<pre><code class="language-cpp">// some dynamic memory is allocated
// some exception is thrown
catch(...){
// deallocate memory
  throw; // rethrow the exception
}
</code></pre>
<pre><code class="language-cpp">class X{
  public:
  X(const X&amp;) = delete; // don't allow copy constructor
};
</code></pre>
<p>See <a href="https://stackoverflow.com/questions/5513881/meaning-of-delete-after-function-declaration">StackOverflow</a>
for more details on <code>method = delete</code>.</p>
<p>See Resource Acquisition is initialization (RAII) on
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">wikipedia</a>.</p>
<pre><code class="language-cpp">// careful, slicing: will only get base type and message
catch(std::exception e) 
catch(const std::exception e) 
// ok, virtual message, no slicing 
catch(const std::exception&amp; e) // favor using const reference -&gt; no slicing
</code></pre>
<p>The <code>catch</code> exception handlers are examined in order when an exception is
thrown in the <code>try</code> block; as soon as one has a matching parameter type (even
if superclass), its block is executed. The other <code>catch</code> blocks are all skipped
, even when the parameters match. ORDEEEER!</p>
<p>Throwing an exception should never cause a memory leak, use RAII.</p>
<p>IOS INBREEDING</p>
<p><img src="media/family1.png" alt="" />
<img src="media/family2.png" alt="" />
<img src="media/family3.png" alt="" />
<img src="media/family4.png" alt="" />
<img src="media/iostream_fam.png" alt="" /></p>
<p><code>std::cout</code>, <code>std::cerr</code> and <code>std::clog</code> are all instances of <code>std::ostream</code>,
<em>ie:</em> <code>std::basic_ostream&lt;char&gt;</code>.</p>
<p><code>std::cin</code> is an instance of <code>std::istream</code>,
<em>ie:</em> <code>std::basic_istream&lt;char&gt;</code>.</p>
<p>A stream can have four (non exclusive) states: <code>fail</code>, <code>good</code>, <code>bad</code> and <code>eof</code>.</p>
<ul>
<li>fail: error, but no data loss, cant read or write from now on</li>
<li>bad: error, with data loss, cant read or write from now on</li>
<li>eof: end of stream encountered, not an error,
but cant read or write from now on</li>
<li>good: good ... (duh)</li>
</ul>
<p>a stream is automatically cast to a bool using <code>!fail()</code>. It is considered
<code>true</code> if the last IO operation succeded.</p>
<pre><code class="language-cpp">while(std::cin){ // while the last input was successful &lt;==&gt; !(std::cin.fail())
  // continue processing
}
</code></pre>
<p>Force stream state</p>
<pre><code class="language-cpp">std::cin.clear(std::ios_base::failbit);
std::cin.clear(std::ios_base::badbit);
std::cin.clear(std::ios_base::eofbit);
std::cin.clear(); // defaults to std::ios_base::goodbit
</code></pre>
<p>A stream's openmode is of type <code>std::ios_base::openmode</code>. It is a bitmask type
<em>ie:</em> can be combined with <code>|</code>;
ex: <code>(ios_base::in | ios_base::out | ios_base::binary )</code></p>
<p>See <a href="https://en.cppreference.com/w/cpp/io/ios_base/openmode">CppReference</a> for
more information.</p>
<p>Input Stream Methods</p>
<ul>
<li>
<p><code>std::ios_base::app</code> comes from 'append' - all output will be added (appended) to the end of
the file. In other words you cannot write anywhere else in the file but at
the end.</p>
</li>
<li>
<p><code>std::ios_base::ate</code> comes from 'at end' - it sets the stream position at the end of the
file when you open it, but you are free to move it around (seek) and write
wherever it pleases you.</p>
</li>
</ul>
<p>More details on <a href="https://stdcxx.apache.org/doc/stdlibug/30-3.html">openmodes</a>.</p>
<ul>
<li><code>is::get(char &amp;)</code> -&gt; get a char from a stream. returns the stream. Does not ignore
non printable chars.</li>
<li><code>is::unget()</code> -&gt; last char read is put back in the buffer, as if it was never read
also returns the stream.</li>
<li><code>is::putback(char_type)</code> -&gt; char parameter is put in the buffer, also returns
the stream.</li>
<li><code>is::peek()</code> -&gt; returns the next character in the stream, does not read it.</li>
<li><code>getline(input_stream, string_storage, delimiter)</code> -&gt;  reads until delimiter
or EOF and writes into string until length is reached.
see <a href="https://en.cppreference.com/w/cpp/string/basic_string/getline">CppReference</a>.</li>
<li><code>is::read(char* storage, count)</code> -&gt; reads and stores into storage until count
or EOF is reached.
See <a href="https://en.cppreference.com/w/cpp/io/basic_istream/read">CppReference</a>.</li>
<li><code>basic_istream&amp; ignore(std::streamsize count=1, int_type delim=Traits::eof());</code>
bruh look it <a href="https://en.cppreference.com/w/cpp/io/basic_istream/ignore">up</a>.</li>
</ul>
<p>Some input streams (non interactive ones, unline std::cin) support positioning
with the <a href="https://en.cppreference.com/w/cpp/io/basic_istream/tellg">tellg()</a>
<a href="https://en.cppreference.com/w/cpp/io/basic_istream/seekg">seekg(pos | offset, seekdir)</a>
functions.</p>
<p><code>seekdir</code> can be <code>ios_base::beg</code>, <code>ios_base::end</code> or <code>ios_base::cur</code>.</p>
<p>Positioning often requires a stream to be open in <code>std::io_base::binary</code>.</p>
<p><code>std::ifstream</code> follows RAII idiom, its constructor takes a file name as a string
and an optional (default = <code>std::ios_base::in</code>) <code>std::ios_base::openmode</code>;
see more on <a href="https://en.cppreference.com/w/cpp/io/basic_ifstream/basic_ifstream">CppReference</a>.</p>
<p>The <code>rdbuf()</code> method returns a pointer to the stream_buffer associated with the
basic_ios.
<a href="https://en.cppreference.com/w/cpp/io/basic_ios/rdbuf">CppReference</a>.</p>
<pre><code class="language-cpp">#include &lt;fstream&gt;
#include &lt;iostream&gt;
int main(){
  std::ifstream dat(&quot;test.dat&quot;, std::ios_base::in | std::ios_base::binary);
  std::cout &lt;&lt; &quot;ifstream rdbuffer is open? &quot; &lt;&lt; dat.rdbuf()-&gt;is_open() &lt;&lt; std::endl;
  dat.rdbuf()-&gt;close();
  std::cout &lt;&lt; &quot;ifstream rdbuffer is open? &quot; &lt;&lt; dat.rdbuf()-&gt;is_open() &lt;&lt; std::endl;
  return 0;
}
</code></pre>
<p>The <code>void open( const char* filename,std::ios_base::openmode mode=std::ios_base::in)</code>
method opens and associates the file with name <code>filename</code> with the file stream.
See <a href="https://en.cppreference.com/w/cpp/io/basic_ifstream/open">CppReference</a> for more
details.</p>
<p>The <code>void close()</code> method of <code>ifstream</code> closes the associated file.
This function is called by the destructor of basic_fstream when the stream
object goes out of scope and is not usually invoked directly.
<a href="https://en.cppreference.com/w/cpp/io/basic_fstream/close">CppReference</a>.</p>
<p>The method <code>bool is_open()</code> checks if the file stream has an associated file.
<a href="https://en.cppreference.com/w/cpp/io/basic_fstream/is_open">CppReference</a>.
Used to ckeck if a file opened for reading exists.</p>
<p><a href="https://stackoverflow.com/questions/4872361/why-are-there-two-different-getline-functions-if-indeed-there-are">stackoverflow:</a></p>
<blockquote>
<p>The global getline() function works with C++ std::string objects.
The istream::getline() methods work with &quot;classic&quot; C strings (pointers to char).</p>
</blockquote>
<p>Use <a href="https://en.cppreference.com/w/cpp/io/basic_istringstream"><code>istringstream</code></a>
to convert a string into an objet whose class supports the <code>&gt;&gt;</code> operator.</p>
<p><a href="https://en.cppreference.com/w/cpp/io/basic_istringstream/str"><code>istringstream::str()</code></a>
returns a copy of the underlying string.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sstream&gt;
int main(){
  std::string s1 = &quot;1 2&quot;;
  std::istringstream is(s1);

  // obtain string in the input string stream
  std::cout &lt;&lt; is.str() &lt;&lt; std::endl; // prints: 1 2

  // change string in the input string stream
  std::string s2 = &quot;3 4&quot;;
  is.str(s2);

  int a, b;
  is &gt;&gt; a &gt;&gt; b; // read input string stream
  std::cout &lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; &quot; b=&quot; &lt;&lt; b &lt;&lt; std::endl; // prints: a=3 b=4
  return 0;
}
</code></pre>
<p><a href="https://en.cppreference.com/w/cpp/io/basic_istringstream"><code>istringstream</code></a> supports
positioning with <a href="https://en.cppreference.com/w/cpp/io/basic_istream/seekg"><code>seekg(...)</code></a>
and <a href="https://en.cppreference.com/w/cpp/io/basic_istream/tellg"><code>tellg()</code></a>.</p>
<p>Similarly to <code>istream</code>,
<a href="https://en.cppreference.com/w/cpp/io/basic_ofstream"><code>ostream</code></a>
can handle 3 kinds of operations:</p>
<ul>
<li>formatted (output) with <code>&lt;&lt;</code></li>
<li>unformatted (output) with
<a href="https://en.cppreference.com/w/cpp/io/basic_ostream/put"><code>put</code></a> and
<a href="https://en.cppreference.com/w/cpp/io/basic_ostream/write"><code>write(char*, count)</code></a></li>
<li>positioning with
<a href="https://en.cppreference.com/w/cpp/io/basic_ostream/tellp"><code>tellp()</code></a> and
<a href="https://en.cppreference.com/w/cpp/io/basic_ostream/seekp"><code>write(pos | offset, seekdir)</code></a></li>
</ul>
<p><a href="https://en.cppreference.com/w/cpp/io/basic_ofstream"><code>ofstream</code></a>
has a destructor that automagically closes the associated file \(\rightarrow\)
RAII. A useful constructor is
<a href="https://en.cppreference.com/w/cpp/io/basic_ofstream/basic_ofstream"><code>ofstream(filename, openmode)</code></a>.</p>
<p><a href="https://en.cppreference.com/w/cpp/io/basic_ofstream"><code>ofstream</code></a>
also has the usual
<a href="https://en.cppreference.com/w/cpp/io/basic_ofstream/rdbuf"><code>rdbuf</code></a>,
<a href="https://en.cppreference.com/w/cpp/io/basic_ofstream/open"><code>open</code></a>,
<a href="https://en.cppreference.com/w/cpp/io/basic_ofstream/close"><code>close</code></a> and
<a href="https://en.cppreference.com/w/cpp/io/basic_ofstream/is_open"><code>is_open</code></a>
methods.</p>
<p>Use <a href="https://en.cppreference.com/w/cpp/io/basic_ostringstream"><code>ostringstream</code></a>
to convert an objet whose class supports the <code>&lt;&lt;</code> operator into a string.
Its constructor takes a char sequence and an <code>openmode</code>
(default is <code>ios_base::out</code>). Its
<a href="https://en.cppreference.com/w/cpp/io/basic_ostringstream/str"><code>str</code></a> method
manages the contents of the underlying string object, that object can be changed
through it.</p>
<p>The <a href="https://en.cppreference.com/w/cpp/io/basic_ostringstream/str"><code>str</code></a> method
comes is overloaded:</p>
<ul>
<li>one version (&lt;=3) returns a copy of the string associated with the ostringstream.</li>
<li>another version (&gt;=4) can copy a string into the internal
<a href="https://en.cppreference.com/w/cpp/io/basic_stringbuf"><code>stringbuf</code></a>.</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;sstream&gt;
template &lt;typename T&gt;
std::string toString(const T&amp; x){
  std::ostringstream os(std::ios_base::app); // append to file
  std::string buf = &quot;*&quot;; // arbitrary prefix to show the effect of append mode
  os.str(buf);
  os &lt;&lt; x;
  return os.str();
}
int main(){
  std::string pi_str = toString(std::acos(-1.0));
  std::cout &lt;&lt; &quot;PI=&quot; &lt;&lt; pi_str &lt;&lt; std::endl; // PI=*3.14159
  return 0;
}
</code></pre>
<p>Some important io manipulators in <code>&lt;ios&gt;</code></p>
<pre><code class="language-cpp">#include &lt;iomanip&gt;
#include &lt;ios&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;

int main() {
  bool v = true;

  // boolalpha , noboolalpha
  std::cout &lt;&lt; std::boolalpha &lt;&lt; v &lt;&lt; &quot; &quot; &lt;&lt; std::noboolalpha &lt;&lt; v &lt;&lt; std::endl;
  v = false; // print: true 1
  std::cout &lt;&lt; std::boolalpha &lt;&lt; v &lt;&lt; &quot; &quot; &lt;&lt; std::noboolalpha &lt;&lt; v
            &lt;&lt; std::endl; // print: false 0

  // showbase, noshowbase, dec, hex, oct
  std::cout &lt;&lt; std::showbase;
  std::cout &lt;&lt; std::dec &lt;&lt; 15 &lt;&lt; &quot; &quot; &lt;&lt; std::hex &lt;&lt; 15 &lt;&lt; std::oct &lt;&lt; &quot; &quot; &lt;&lt; 15
            &lt;&lt; std::endl; // prints: 15 0xf 017
  std::cout &lt;&lt; std::noshowbase;
  std::cout &lt;&lt; std::dec &lt;&lt; 15 &lt;&lt; &quot; &quot; &lt;&lt; std::hex &lt;&lt; 15 &lt;&lt; std::oct &lt;&lt; &quot; &quot; &lt;&lt; 15
            &lt;&lt; std::endl; // prints: 15 f 17

  // showpoint, noshowpoint
  double d = 33.0, q = 33.1;
  std::cout &lt;&lt; std::showpoint &lt;&lt; d &lt;&lt; &quot; &quot; &lt;&lt; std::noshowpoint &lt;&lt; d &lt;&lt; &quot; &quot; &lt;&lt; q
            &lt;&lt; std::endl; // prints: 33.0000 33 33.1

  // showpos, noshowpos
  double pi = 3.14159;
  std::cout &lt;&lt; std::showpos &lt;&lt; pi &lt;&lt; &quot; &quot; &lt;&lt; 0.0 &lt;&lt; &quot; &quot; &lt;&lt; std::noshowpos &lt;&lt; pi
            &lt;&lt; std::endl; // prints: +3.14159 +0 3.14159

  // skipws, noskipws
  char c1, c2, c3;
  std::cout &lt;&lt; &quot;type&gt;&quot;;
  std::cin &gt;&gt; std::skipws &gt;&gt; c1 &gt;&gt; std::noskipws &gt;&gt; c2 &gt;&gt;
      c3; // type: &lt;space&gt; A &lt;space&gt; B
  std::cout &lt;&lt; std::hex &lt;&lt; std::showbase &lt;&lt; static_cast&lt;int&gt;(c1) &lt;&lt; &quot; &quot;
            &lt;&lt; static_cast&lt;int&gt;(c2) &lt;&lt; &quot; &quot; &lt;&lt; static_cast&lt;int&gt;(c3)
            &lt;&lt; std::endl; // prints: 0x41 0x20 0x42

  // scientific, fixed, defaultfloat, hexfloat
  double x = 0.00002;
  std::cout &lt;&lt; std::fixed &lt;&lt; x &lt;&lt; std::endl;        // prints: 0.000020
  std::cout &lt;&lt; std::scientific &lt;&lt; x &lt;&lt; std::endl;   // prints: 2.000000e-05
  std::cout &lt;&lt; std::defaultfloat &lt;&lt; x &lt;&lt; std::endl; // prints: 2e-05
  std::cout &lt;&lt; std::hexfloat &lt;&lt; x &lt;&lt; std::endl; // prints: 0x1.4f8b588e368f1p-16

  // uppercase, nouppercase
  double y = 300.1234;
  int k = -559038737;
  std::cout &lt;&lt; std::scientific &lt;&lt; std::hex;
  std::cout &lt;&lt; std::uppercase &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; k
            &lt;&lt; std::endl; // prints: 3.001234E+02 0XDEADBEEF
  std::cout &lt;&lt; std::nouppercase &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; k
            &lt;&lt; std::endl; // prints: 3.001234e+02 0xdeadbeef

  // std::setfill, std::left, std::right and std::internal
  std::cout &lt;&lt; std::hex &lt;&lt; std::showbase;
  std::cout &lt;&lt; std::setfill('#') &lt;&lt; std::setw(12);
  std::cout &lt;&lt; std::left &lt;&lt; 24 &lt;&lt; std::endl; // prints: 0x18########
  std::cout &lt;&lt; std::setfill('#') &lt;&lt; std::setw(12);
  std::cout &lt;&lt; std::right &lt;&lt; 24 &lt;&lt; std::endl; // prints: ########0x18
  std::cout &lt;&lt; std::setfill('#') &lt;&lt; std::setw(12);
  std::cout &lt;&lt; std::internal &lt;&lt; 24 &lt;&lt; std::endl; // prints: 0x########18

  // std::ws
  char c4, c5;
  std::cout &lt;&lt; &quot;type&gt;&quot;;
  std::cin &gt;&gt; std::skipws &gt;&gt; c4 &gt;&gt; std::noskipws &gt;&gt; std::ws &gt;&gt;
      c5; // type: &lt;space&gt; A &lt;space&gt; B
  std::cout &lt;&lt; std::hex &lt;&lt; std::showbase &lt;&lt; static_cast&lt;int&gt;(c4) &lt;&lt; &quot; &quot;
            &lt;&lt; static_cast&lt;int&gt;(c5) &lt;&lt; std::endl; // prints: 0x41 0x42

  // std::ends
  std::ostringstream os;
  os &lt;&lt; &quot;AAA&quot; &lt;&lt; std::ends &lt;&lt; &quot;BBB&quot; &lt;&lt; std::ends &lt;&lt; &quot;CCC&quot; &lt;&lt; std::ends
     &lt;&lt; std::flush; // make c style strings
  std::string s = os.str();
  for (auto c : s)
    std::cout &lt;&lt; std::hex &lt;&lt; std::showbase &lt;&lt; static_cast&lt;int&gt;(c) &lt;&lt; &quot; &quot;;
  // prints: 0x41 0x41 0x41 0 0x42 0x42 0x42 0 0x43 0x43 0x43 0
  std::cout &lt;&lt; std::endl;

  return 0;
}
</code></pre>
<p><a href="https://en.cppreference.com/w/cpp/io/manip/unitbuf"><code>unitbuf/nounitbuf</code></a>
enables or disables automatic flushing of the output stream after any
output operation.</p>
<p>The oracle at <a href="https://stackoverflow.com/a/6027938">stackoverflow</a> informs us
that <a href="https://en.cppreference.com/w/cpp/io/cerr"><code>cerr/wcerr</code></a> default to
<code>unitbuf</code>. You do want to see the errors if a crash happens.</p>
<p>What's the difference between <code>ws</code> and <code>skipws</code> ?
<a href="https://stackoverflow.com/a/68341644">[🔮]</a></p>
<ul>
<li>
<p><a href="https://en.cppreference.com/w/cpp/io/manip/skipws"><code>skipws</code></a> enables or
disables skipping of leading whitespace by the formatted input functions.</p>
</li>
<li>
<p><a href="https://en.cppreference.com/w/cpp/io/manip/ws"><code>ws</code></a> discards leading
whitespace from an input stream \(\rightarrow\)
<a href="https://en.cppreference.com/w/cpp/named_req/UnformattedInputFunction"><code>unformatted input function</code></a></p>
</li>
</ul>
<p><code>&lt;ostream&gt;</code> declares 3 manipulators:</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/io/manip/flush"><code>flush</code></a> flushes the
stream <em>ie:</em> writes all unwritten data on the stream buffer to the peripheral
(file, string, whatever else), <code>unitbuf</code> performs a flush after each operation.</li>
<li><a href="https://en.cppreference.com/w/cpp/io/manip/endl"><code>endl</code></a>
inserts a newline character into the output stream and flushes it.</li>
<li><a href="https://en.cppreference.com/w/cpp/io/manip/ends">ends</a>
inserts a null character into the output stream, does not flush.</li>
</ul>
<p><a href="https://en.cppreference.com/w/cpp/io/manip/setw"><code>setw(n)</code></a>
(declared in <code>&lt;iomanip&gt;</code>) specifies that the next operation should use a width <code>n</code>.
If write: shorter than <code>n</code> will be padded with the filler char set by</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/io/manip/setfill"><code>setfill</code></a>, longer won't be
troncated.</li>
<li>If read: shorter than <code>n</code> is read entirely, longer is troncated (unless numeric).</li>
</ul>
<p><a href="https://en.cppreference.com/w/cpp/io/manip/setbase"><code>setbase</code></a>
sets the numeric base of the stream.</p>
<p><a href="https://en.cppreference.com/w/cpp/io/manip/setfill"><code>setfill</code></a> is self
explanatory ... bruh.</p>
<p><a href="https://en.cppreference.com/w/cpp/io/manip/setprecision"><code>setprecision</code></a>
set the precision used to write or read floating point types, see the page
reference examples.</p>
<p>Formatted io for basic types is symmetic: a value written with <code>&lt;&lt;</code> can
be read with <code>&gt;&gt;</code> (without loss of information). The only exception is the string
class: the <code>&lt;&lt;</code> operator writes the whole string, but the <code>&gt;&gt;</code> operator only
reads a word into the string.</p>
<p>The <a href="https://en.cppreference.com/w/cpp/io/manip/quoted"><code>quoted</code></a>
allows insertion and extraction of quoted strings,
such as the ones found in csv, json or xml.</p>
<pre><code class="language-cpp">#include &lt;iomanip&gt;
#include &lt;iostream&gt;

int main(){
  std::string s, q = &quot;c++ is fabulous&quot;;

  std::stringstream flow;
  flow &lt;&lt; q;
  flow &gt;&gt; s;
  std::cout &lt;&lt; s &lt;&lt; std::endl; // prints: c++

  std::stringstream qflow; // implicit &quot;
  qflow &lt;&lt; std::quoted(q);
  qflow &gt;&gt; std::quoted(s);
  std::cout &lt;&lt; s &lt;&lt; std::endl; // prints: c++ is fabulous

  std::stringstream bflow;
  bflow &lt;&lt; std::quoted(q, '|');
  bflow &gt;&gt; std::quoted(s, '|');
  std::cout &lt;&lt; s &lt;&lt; std::endl; // prints: c++ is fabulous

  std::stringstream xflow;
  xflow &lt;&lt; std::quoted(q, '&lt;', '&gt;');
  xflow &gt;&gt; std::quoted(s, '&lt;', '&gt;');
  std::cout &lt;&lt; s &lt;&lt; std::endl; // prints: c++ is fabulous

  return 0;
}
</code></pre>
<p>To create a paramterless output manipulator use the 18-20 overload
of the <a href="https://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt"><code>&lt;&lt;</code></a>
operator of the <code>basic_ostream</code> class.</p>
<pre><code class="language-cpp">// prototype
std::basic_ostream&amp; operator&lt;&lt;(
    std::basic_ostream&lt;CharT, Traits&gt;&amp; (*func)
        (std::basic_ostream&lt;CharT, Traits&gt;&amp;) );
// so if a function manip is declared as
std::ostream&amp; manip(std::ostream&amp;);
// the expression 
flow &lt;&lt; manip; // is equivalent to
manip(flow);
</code></pre>
<p>Example:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;ostream&gt;

template&lt;typename C, typename T&gt;
std::basic_ostream&lt;C,T&gt;&amp; compilation_date(std::basic_ostream&lt;C,T&gt;&amp; os){
  return os &lt;&lt; __DATE__ &lt;&lt; &quot; &quot; &lt;&lt; __TIME__ &lt;&lt; std::flush;
}

int main(){
  std::cout &lt;&lt; &quot;Version : &quot; &lt;&lt; compilation_date;
  std::endl(std::cout); // equivalent to
  std::cout &lt;&lt; std::endl;
  return 0;
}
</code></pre>
<p>Left and right shift nonsense</p>
<pre><code class="language-cpp">std::cout &lt;&lt; (4&lt;&lt;2) &lt;&lt; std::endl; // equivalent to 4 * 2^2
std::cout &lt;&lt; (8&gt;&gt;2) &lt;&lt; std::endl; // equivalent to 8 / 2^2
</code></pre>
<p>Lambda expressions in C++: C++11 onwards</p>
<ul>
<li>the return type is automatically is automagically deduced by the compiler.</li>
</ul>
<pre><code class="language-cpp">auto f = [](const char *s=&quot; default\n&quot;){std::cout &lt;&lt; 42 &lt;&lt; s &lt;&lt; std::endl;};
f(); // prints: 42 default
f(&quot; not default&quot;); // prints: 42 not default
[](int n){std::cout &lt;&lt; n &lt;&lt; std::endl;}(32); // prints: 32
</code></pre>
<p>Use <code>decltype(name)</code> to get the type of a lambda function named <code>name</code> (often
declared auto). Two lambda expressions, even if having the exact same definitions
don't have the same type. In a generic context, we need to name a lambda expression
to use its type as a template parameter.</p>
<p>Starting from C++17, the compiler can infer the template parameters of an instance
from the types of the constructor real parameters. So can do dis:</p>
<pre><code class="language-cpp">auto lam = [](int n){return 2*n};
Feval&lt;int, decltype(lam)&gt; f(2, lam);
Feval f(2, lam); // works and is equivalent to 
Feval f(2, [](int n){return 2*n;}); // dis
</code></pre>
<p>Starting from C++14, lambda parameters can be auto: works as if there was
a generic type for each <code>auto</code> parameter.</p>
<pre><code class="language-cpp">auto maxi = [](auto a, auto b){
  if(a&gt;b) return a; else return b;
};

std::cout &lt;&lt; maxi(1, 3) &lt;&lt; std::endl; // prints: 3
std::cout &lt;&lt; maxi(1, 0) &lt;&lt; std::endl; // prints: 1
std::cout &lt;&lt; maxi('a', 'c') &lt;&lt; std::endl; // prints: c
std::cout &lt;&lt; maxi(1, 3.14) &lt;&lt; std::endl; // does not compile
// maxi would have to return either a or b of type int or double -- incompatible
// &quot; Inconsistent types 'double' and 'int'
</code></pre>
<p>to force a lambda to return a type:</p>
<pre><code class="language-cpp">auto maxi = [](auto a, auto b) -&gt; decltype(a) {
  if(a&gt;b) return a; else return b;
};
std::cout &lt;&lt; maxi(1, 3.14) &lt;&lt; std::endl; // now compiles and prints: 3
</code></pre>
<p>Other example</p>
<pre><code class="language-cpp">auto div3 = [](int n=3) -&gt; bool {
  return n%3==0;
};
std::cout &lt;&lt; div3() &lt;&lt; std::endl; // prints: 1
std::cout &lt;&lt; div3(43) &lt;&lt; std::endl; // prints: 0
</code></pre>
<p>A lambda can access all global and <code>static</code> local variables in the scope in
which it is defined. To capture a (nonstatic!) variable in the local context,
use the <code>[]</code> operator to specify what local entities to capture:</p>
<pre><code class="language-cpp"></code></pre>
<p>413</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="chapters/ccpp/c.html" class="mobile-nav-chapters previous" title="Previous chapter">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="chapters/algs/intro.html" class="mobile-nav-chapters next" title="Next chapter">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="chapters/ccpp/c.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="chapters/algs/intro.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        
        <script type="text/javascript" src="highlightjs-line-numbers.js"></script>
        

    </body>
</html>
