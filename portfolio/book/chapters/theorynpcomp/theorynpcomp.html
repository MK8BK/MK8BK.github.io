<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Theory of NP-Completeness - The Guides</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../../chapters/linux/intro.html"><strong aria-hidden="true">2.</strong> Linux Command Line</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../chapters/linux/vim.html"><strong aria-hidden="true">2.1.</strong> vim & neovim</a></li><li class="chapter-item expanded "><a href="../../chapters/linux/bash.html"><strong aria-hidden="true">2.2.</strong> scripting</a></li><li class="chapter-item expanded "><a href="../../chapters/linux/utils.html"><strong aria-hidden="true">2.3.</strong> utilities</a></li></ol></li><li class="chapter-item expanded "><a href="../../chapters/ccpp/intro.html"><strong aria-hidden="true">3.</strong> C/C++ Notes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../chapters/ccpp/gcc.html"><strong aria-hidden="true">3.1.</strong> Tooling</a></li><li class="chapter-item expanded "><a href="../../chapters/ccpp/c.html"><strong aria-hidden="true">3.2.</strong> C</a></li><li class="chapter-item expanded "><a href="../../chapters/ccpp/cpp.html"><strong aria-hidden="true">3.3.</strong> C++</a></li></ol></li><li class="chapter-item expanded "><a href="../../chapters/algs/intro.html"><strong aria-hidden="true">4.</strong> Algorithms & Data Structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../chapters/algs/lds.html"><strong aria-hidden="true">4.1.</strong> Linear Data Structures</a></li><li class="chapter-item expanded "><a href="../../chapters/algs/sorting.html"><strong aria-hidden="true">4.2.</strong> Sorting</a></li><li class="chapter-item expanded "><a href="../../chapters/algs/searching.html"><strong aria-hidden="true">4.3.</strong> Searching</a></li><li class="chapter-item expanded "><a href="../../chapters/algs/trees.html"><strong aria-hidden="true">4.4.</strong> Trees</a></li><li class="chapter-item expanded "><a href="../../chapters/algs/graphs.html"><strong aria-hidden="true">4.5.</strong> Graphs</a></li><li class="chapter-item expanded "><a href="../../chapters/algs/dnc.html"><strong aria-hidden="true">4.6.</strong> Divide & Conquer</a></li><li class="chapter-item expanded "><a href="../../chapters/algs/greedy.html"><strong aria-hidden="true">4.7.</strong> Greedy Algorithms</a></li><li class="chapter-item expanded "><a href="../../chapters/algs/dynprog.html"><strong aria-hidden="true">4.8.</strong> Dynamic Programming</a></li><li class="chapter-item expanded "><a href="../../chapters/algs/algs_graphs.html"><strong aria-hidden="true">4.9.</strong> Graph Algorithms</a></li><li class="chapter-item expanded "><a href="../../chapters/algs/linprog.html"><strong aria-hidden="true">4.10.</strong> Linear Programming</a></li><li class="chapter-item expanded "><a href="../../chapters/algs/algs_string.html"><strong aria-hidden="true">4.11.</strong> String Algorithms</a></li></ol></li><li class="chapter-item expanded "><a href="../../chapters/leetcode/main.html"><strong aria-hidden="true">5.</strong> LeetCode Catalog</a></li><li class="chapter-item expanded "><a href="../../chapters/theorynpcomp/intro.html"><strong aria-hidden="true">6.</strong> Theory of NP-Completeness</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../chapters/theorynpcomp/theorynpcomp.html" class="active"><strong aria-hidden="true">6.1.</strong> The Theory of NP-Completeness</a></li><li class="chapter-item expanded "><a href="../../chapters/theorynpcomp/proofnpcomp.html"><strong aria-hidden="true">6.2.</strong> Proving NP-Complete Results</a></li></ol></li><li class="chapter-item expanded "><a href="../../chapters/ocaml/intro.html"><strong aria-hidden="true">7.</strong> OCaml Functional Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../chapters/ocaml/n99exercises.html"><strong aria-hidden="true">7.1.</strong> 99 Excercises in OCaml</a></li><li class="chapter-item expanded "><a href="../../chapters/ocaml/lambdacalc.html"><strong aria-hidden="true">7.2.</strong> Lambda Calcul</a></li></ol></li><li class="chapter-item expanded "><a href="../../chapters/umath/intro.html"><strong aria-hidden="true">8.</strong> Maths de 1er cycle</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../chapters/umath/reduction.html"><strong aria-hidden="true">8.1.</strong> Reduction des Endomorphismes</a></li></ol></li><li class="chapter-item expanded "><a href="../../chapters/about/whoami.html"><strong aria-hidden="true">9.</strong> About</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Guides</h1>

                    <div class="right-buttons">

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-theory-of-np-completeness"><a class="header" href="#the-theory-of-np-completeness">The Theory of NP-Completeness</a></h1>
<h2 id="decision-problems-languages-and-encoding-schemes"><a class="header" href="#decision-problems-languages-and-encoding-schemes">Decision Problems, Languages and Encoding Schemes</a></h2>
<p>The theory of \(NP\)-completeness is designed to be applied only to decision
problems.</p>
<p>A Decision problem is a problem with only two possible solutions: "yes" and "no".</p>
<p><strong>Definition</strong>
A decision problem \(\Pi\) consists of a set \(D_\Pi\) of instances and a
subset \(Y_\Pi \subseteq D_\Pi\) of <em>yes</em>-instances.</p>
<p>\(\rightarrow\) a more practical approach is to define a <em>generic instance</em>
using a set of various components (graphs, functions, numbers, sets) and a
<em>yes-no</em> question asked in terms of the generic instance.</p>
<p>An instance belongs to \(D_\Pi\) iff it can be obtained from a generic instance
by substiting particular objects of the specified types for all
the generic components.</p>
<p>An instance belongs to \(Y_\Pi\) iff the answer to the stated question,
when particularized to that instance, is <em>"yes"</em>.</p>
<p><strong>Examples</strong></p>
<ul>
<li>
<p><strong>Subgraph Isomorphism</strong></p>
<p><em>Instance</em>: Two graphs \(G_1=(V_1, E_1)\) and \(G_2=(V_2, E_2)\).</p>
<p><em>Question</em>: Does \(G_1\) contain a subgraph isomorphic to \(G2\), that is,
a subset \(V'\subseteq V_1\) and a subset \(E'\subseteq E_1\) such that
\(|V'|=|V_2|\), \(|E'|=|E_2|\), and there exists a one-to-one function
\(f: V_2 \rightarrow V'\) satisfying \(\{u, v\}\in E_2\) iff
\(\{f(u), f(v)\}\in E'\) ?</p>
</li>
<li>
<p><strong>Traveling Salesman</strong></p>
<p><em>Instance</em>: A finite set \(C=\{c_1, ..., c_m\}\) of "cities", a "distance"
\(d(c_i, c_j)\in\mathbb{Z}^+\) for each pair of cities \(c_i, c_j \in C\)
, and a bound \(B\in\mathbb{Z}^+\).</p>
<p><em>Question</em>: Is there a "tour" of all the cities in \(C\) having total
length no more than \(B\), that is an ordering
\(&lt; c_{\pi(1)}, ..., c_{\pi(m)} &gt;\) of \(C\) such that</p>
<p>\[(\sum_{i=1}^{m-1}{d(c_{\pi(i)}, c_{\pi(i+1)})}) + d(c_{\pi(m)}, c_{\pi(1)}) \leq B ?\]</p>
</li>
</ul>
<p>The traveling salesman problem variant described above is an example of how
a non decision problem can be transformed into a decision problem.</p>
<p><strong>Definition</strong></p>
<p>For any finite set \(\Sigma\) of symbols, we denote by \(\Sigma^* \) the set
of all finite strings of symbols from \(\Sigma\). If \(L\) is a subset
of \(\Sigma^* \), we say that \(L\) is a <strong>language</strong> over the <strong>alphabet</strong>
\(\Sigma\).</p>
<p><strong>Examples</strong></p>
<ul>
<li>If \(\Sigma=\{0, 1\}\) then \(\Sigma^* \) consists of the empty string
"\(\epsilon\)", the strings \(0, 1, 00, 01, 11, 000, 001\) and all other
finite strings of \(1\)'s and \(0\)'s.</li>
<li>\(\{01, 001, 111, 1101010\}\) is a language over \(\{0, 1\}\), as is
the set of all binary representations of integers that are perfect squares,
as is \(\{0, 1\}^* \) itself.</li>
</ul>
<p><strong>Definition</strong></p>
<p>An encoding scheme \(e\) for a problem \(\Pi\) provides a way of describing
each instance of \(\Pi\) by an appropriate string of symbols over some fixed
alphabet \(\Sigma\).</p>
<p><strong>Remark</strong></p>
<p>The problem \(\Pi\) and the encoding sceme \(e\) for \(\Pi\) partition
\(\Sigma^* \) intro three classes of strings:</p>
<ul>
<li>those that are not encodings of instances of \(\Pi\).</li>
<li>those that encode instances of \(\Pi\) for which the answer is "<em>no</em>".</li>
<li>those that encode instances of \(\Pi\) for which the answer is "<em>yes</em>".</li>
</ul>
<p><strong>Definition</strong></p>
<p>Assuming that \(\Sigma\) is the alphabet used by \(e\),
the language associated to the problem \(\Pi\) and the encoding \(e\) is
denoted :
\[
L[\Pi, e] = \{x\in\Sigma^* :  x\
is\ the\ encoding\ under\ e\ of\ an \ instance\ I\in Y_{\Pi}\}.
\]</p>
<p><strong>Lemma</strong>
If a result holds for the language \(L[\Pi, e]\), then it holds for the
problem \(\Pi\) under the encoding scheme \(e\).</p>
<p>Assuming the encodings we employ are "reasonable" most properties are
encoding-independant.</p>
<p>We assume that every decision problem \(\Pi\) has an associated
encoding-independant function \(Length: D_\Pi \rightarrow\mathbb{N}\),
which is "polynomially related" to the input lengths we would we would obtain
from a reasonable encoding scheme.</p>
<p><strong>A Standard Encoding Scheme</strong></p>
<p>The alphabet used is \(\Psi=\{ 0 , 1 , - , [ , ] , ( , ) , , \} \).</p>
<p>We define <strong>structured strings</strong> recursively:</p>
<ol>
<li>An integer \(k\) is represented by a string of \(0\)'s and \(1\)'s
preceded by a minus sign "\(-\)" if \(k\) is negative.</li>
<li>If \(x\) is a structured string representing the integer \(k\), then
\([x]\) is a structured string that can be used as a "name". (for examples:
a vertex in a graph, a set element, a city in the traveling salesman problem).</li>
<li>If \(x_1, \dots, x_m\) are structured strings representing the objects
\(X_1, ..., X_m\), then \((x_1, ..., x_m)\) is a structured string
representing the sequence \(&lt; X_1, ..., X_m &gt;\).</li>
</ol>
<p>We already know how to encode <strong>integers</strong> and <strong>sequences</strong>.</p>
<ul>
<li>A <strong>set</strong> is represented by ordering its elements as a sequence
\(&lt; X_1, ..., X_m &gt;\) and taking the structured string corresponding
to that sequence.</li>
<li>A <strong>graph</strong> with vertex set \(V\) and edge set \(E\) is represented by a
structured string \((x, y)\), where \(x\) is a structured string
representing the set \(V\) and \(y\) is a structured string representing
the \(E\) (the elements of \(E\) being the two-element subsets of \(V\)
that are edges).</li>
<li>A <strong>finite function</strong>  \(f: \{U_1, ..., U_m\}\rightarrow W\) is
represented by a structured string \(((x_1, y_1), ... ,(x_m, y_m))\) where
\(x_i\) is a structured string representing the object \(U_i\)
and \(y_i\) a structured string representing the object \(f(U_i)\in W\)
, \(\forall \ 1\leq i\leq m\).</li>
<li>A <strong>rational number</strong> \(q\) is represented by a structured string
\((x,y)\) where \(x\) is a structured string representing an integer
\(a\), \(y\) is a structured string representing an integer \(b\),
\(a/b=q\), and \(GCD(a, b)=1\).</li>
</ul>
<p>Two structured strings written in the standard encoding schemes can represent
a same object without being strictly the same.</p>
<p>From now on, an encoding scheme is said to be reasonable if it is equivalent
to the standard encoding scheme, in the sense that there exist polynomial time
algorithms for converting an encoding of an instance back and forth between
the two encoding schemes.</p>
<h2 id="deterministic-turing-machines-and-the-class-p"><a class="header" href="#deterministic-turing-machines-and-the-class-p">Deterministic Turing Machines and the Class P</a></h2>
<p><strong>Definition</strong></p>
<p>A <strong>Deterministic One-Tape Turing Machine</strong> (DTM) is a model of computation
which consists of a <em>finite state control</em>, a <em>read-write head</em> and a two-way
infinite <em>tape</em> of squares labeled (\(..., -2, -1, 0, 1, 2, ...\)).</p>
<p><img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/deterministic_turing_machine.jpg" alt="img" /></p>
<p><strong>Definition</strong></p>
<p>A <em>program</em> for a DTM specifies the following information:</p>
<ol>
<li>A finite set \(\Gamma\) of tape symbols, including a subset
\(\Sigma\subset\Gamma\) of <em>input</em> symbols and a distinguished
<em>blank symbol</em> \(b\in\Gamma\backslash\Sigma\);</li>
<li>a finite set \(\mathcal{Q}\) of <em>states</em>, including a distinguished <em>start-state</em>
\(q_0\) and two distinguished <em>halt-states</em> \(q_Y\) and \(q_N\);</li>
<li>a <em>transition function</em>
\(\delta: (\mathcal{Q}\backslash\{q_Y, q_N\})\times\Gamma\rightarrow
\mathcal{Q}\times\Gamma\times\{-1, +1\}\).</li>
</ol>
<p><strong>Operation of a DTM program</strong></p>
<p>The input to the DTM is a string \(x\in\Sigma^*\).</p>
<p>All the tape squares initially contain the blank symbol \(b\).</p>
<p>The string \(x\) is placed in tape squares 1 through \(|x|\).</p>
<p>The program starts its operation in state \(q_0\), with the head scanning tape
square \(1\).</p>
<p>At each step:</p>
<ul>
<li>If the current state \(q\) is either \(q_Y\) or \(q_N\), then the
computation has ended, with the answer being "\(yes\)" if \(q=q_Y\)
or "\(no\)" if \(q=q_N\).</li>
<li>Else we have \(q\in \mathcal{Q}\backslash \{q_Y, q_N\}\) and there is a symbol
\(s\) in the tape square being scanned. The value of the <em>transition
function</em> can be computed:
\(\delta(q, s)=(q', s', \Delta)\). The <em>read write head</em> then replaces
the symbol \(s\) by \(s'\) in the current square, it then moves one square
right if \(\Delta=1\) or one square left if \(\Delta=-1\). The
<em>finite state control</em> updates the state value from \(q\) to \(q'\).</li>
</ul>
<p><strong>Definition</strong></p>
<p>We say that a DTM program \(M\) with input alphabet \(\Sigma\) <em>accepts</em>
\(x\in\Sigma^*\) if and only if \(M\) halts in state \(q_Y\) when applied
to input \(x\).</p>
<p><strong>Definition</strong>
: The language \(L_M\) recognized by the program \(M\) is given by
\(L_M = \{x\in\Sigma^*: M \ accepts\ x\}\).</p>
<p>If \(x\in(\Sigma^*\backslash L_M)\) then either the computation of \(M\) on
\(x\) halts in state \(q_N\) or it does not halt <em>ie: continues forever</em>.</p>
<p><strong>Definition</strong></p>
<p>We say that a DTM program \(M\) <em>solves</em> the decision problem \(\Pi\) under
encoding scheme \(e\) if \(M\) halts for all input strings over its input
alphabet and \(L_M = L[\Pi, e]\).</p>
<p><strong>Example</strong>: Integer Divisibility by four.</p>
<p>Instance: A positive integer \(N\).</p>
<p>Question: Is there a positive integer \(m\) such that \(N=4m\)?</p>
<p>Using the standard encoding scheme, the integer \(N\) is represented by the
string of  \(0\)'s and \(1\)'s that is its binary representation.</p>
<p>\[
\Gamma=\{0, 1, b\}, \Sigma=\{0, 1\} \\
\mathcal{Q}=\{q_0, q_1, q_2, q_3, q_Y, q_N\} \\
\delta(q_0, 0)=(q_0, 0, +1), \
\delta(q_0, 1)=(q_0, 1, +1)\\
\delta(q_0, b)=(q_1, b, -1), \
\delta(q_1, 0)=(q_2, b, -1)\\
\delta(q_1, 1)=(q_3, b, -1), \
\delta(q_1, b)=(q_N, b, -1)\\
\delta(q_2, 0)=(q_Y, b, -1), \
\delta(q_2, 1)=(q_N, b, -1)\\
\delta(q_2, b)=(q_N, b, -1), \
\delta(q_3, 0)=(q_N, b, -1)\\
\delta(q_3, 1)=(q_N, b, -1), \
\delta(q_3, b)=(q_N, b, -1)\\
M=(\Gamma, \mathcal{Q}, \delta).
\]</p>
<p>Here as example of the execution of this program on the string
\(x=10100\).</p>
<p><img src="media/dtmM.png" alt="dtm execution diagram" /></p>
<p>The language \(L_M\) recognized by the program \(M\) is given by
\(L_M = \{x\in\Sigma^*: M\ accepts \ x\}\).</p>
<p>It can be shown that \(L_M\) is exactly the language</p>
<p>\[
\{x\in\{0, 1\}^*: the \ rightmost \ two \ symbols \ of \ x
\ are \ both \ 0 \}.
\]</p>
<p>Since an integer \(N\) is divisible by \(4\) if and only if the last two
digits of its binary representation are \(0\), the DTM program \(M\) solves
the INTEGER DIVISIBILITY BY FOUR problem.</p>
<p><strong>Remark</strong>: A DTM program can compute functions.
Suppose \(M\) is a DTM with input alphabet \(\Sigma\) and tape alphabet
\(\Gamma\) that halts for all input strings from \(\Sigma^*\).
Then \(M\) computes the function \(f_M : \Sigma^* \rightarrow \Gamma^*\)
where for each \(x \in \Sigma^*\), \(f_M(x)\) is defined to be the
contiguous string obtained by running \(M\) on input \(x\) until it
halts; from tape position 1 up to but not including the first blank symbol.</p>
<p>The <strong>time</strong> used in the computation of a DTM program \(M\) on an input \(x\)
is the number of steps occuring in that computation up until the first
halt state is entered.</p>
<p><strong>Definition</strong>
For a DTM program \(M\) that halts on all inputs \(x\in\Sigma^*\), its
<em>time complexity function</em> \(T_M: \mathbb{Z}^+\rightarrow\mathbb{Z}^+\)
is given by:</p>
<p>\[
T_M(n) = max \{m: there \ is \ a \ string \ x\in\Sigma^* of \ length
\\ \
n \ on \ which \ the \ computation \ of \ M \ takes \ time \ m \}
\]</p>
<p><strong>Remark</strong> \(M\) is a <em>polynomial time DTM program</em> if there exists a
polynomial \(p\) such that \(\forall n \in \mathbb{N} : T_M(n)\leq p(n)\).</p>
<p><strong>Definition</strong></p>
<p>\[
P = \{L: there \ exists \ a \ polynomial \ time \ DTM \ program \\
\ M \ for \ which \ L=L_M\}.
\]</p>
<p>We say that a decision problem \(\Pi\) belongs to \(P\) under the encoding scheme \(e\) if \(L[\Pi, e]\in P\), <em>ie</em> there is a polynomial time DTM
program that solves \(\Pi\) under the encoding \(e\).</p>
<p>If a decision problem \(\Pi\in P\) then its complementary problem is
also in \(P\), this is not necessarily the case for a problem in \(NP\).</p>
<h2 id="nondeterminstic-computation-and-the-class-np"><a class="header" href="#nondeterminstic-computation-and-the-class-np">Nondeterminstic Computation and the class NP</a></h2>
<p>The class \(NP\) is intended to isolate the notion of polynomial time
"verifiability", which does not imply polynomial time solvability.</p>
<p>A <strong>nondeterministic algorithm</strong> is composed of two separate stages, the first
being a <em>guessing stage</em> and the second a <em>checking stage</em>.
Given a problem instance \(I\), the first stage <em>guesses</em> a structure \(S\).
\(I\) and \(S\) are then passed as inputs to the checking stage, which
performs deterministic computations to verify if the structure \(S\)
proves that the answer to \(I\) is "yes".</p>
<p>A nondeterministic algorithm <em>solves</em> a decision problem \(\Pi\) iff :</p>
<ol>
<li>If \(I\in Y_{\Pi}\), then there exists some structure \(S\) that, when
guessed for input \(I\), will lead the checking stage to respond "yes" for
\(I\) and \(S\).</li>
<li>If \(I\notin Y_{\Pi}\), then there exists some structure \(S\) that, when
guessed for input \(I\), will lead the checking stage to respond "yes" for
\(I\) and \(S\).</li>
</ol>
<p><strong>Definitions</strong></p>
<p>A <strong>NonDeterministic one-tape Turing Machine</strong> (NDTM)
is a computation model composed of a <em>finite state control</em>, a <em>read-write head</em>
, a two-way infinite <em>tape</em> of squares labeled (\(..., -2, -1, 0, 1, 2, ...\))
and a <em>guessing module</em> having a <em>write-only head</em>.</p>
<p><img src="https://i.stack.imgur.com/lqJWu.png" alt="img" /></p>
<p>An <strong>NDTM program</strong> is specified in exactly the same way as \(DTM\) program.
This includes the tape alphabet \(\Gamma\), input alphabet \(\Sigma\),
blank symbol \(b\), state set \(\mathcal{Q}\), initial state \(q_0\), halt
states \(q_Y\) and \(q_N\) and transition function
\(\delta: (\mathcal{Q} \backslash \{q_Y, q_N\})\times\Gamma
\rightarrow \mathcal{Q}\times\Gamma\times\{-1, +1\}\)</p>
<p>The <strong>computation of an NDTM</strong> on an input string \(x\in\Sigma^*\) differs from
that of a DTM in that it takes place in two distinct stages:</p>
<ul>
<li>the <em>guessing stage</em>:
<ul>
<li>the input string \(x\) is written in tapes \(1\) through \(|x|\).
All other squares contain the blank character.</li>
<li>the read-write head is scanning square \(1\), while the write-only head is
scanning square \(-1\), the finite state control is inactive.</li>
<li>the guessing module then directs the write-only head, one step at a
time, either to write some symbol from \(\Gamma\) in te tape square being
scanned and move one square to the left, or to stop, at which point the
guessing module becomes inactive.</li>
</ul>
</li>
</ul>
<p>The finite state control is then activated in state \(q_0\).</p>
<ul>
<li>the <em>checking stage</em>:
<ul>
<li>the guessing module and its write-only head are no longer involved, having
fulfilled their role by guessing a string on the tape.</li>
<li>the computation proceeds solely under the direction of the NDTM program
according to exactly the same rules as for a DTM.</li>
<li>the guessed string can (and usually will) be examined during this stage.</li>
<li>The computation ceases when and if the finite state control enters one of
the two halting states and is said to be an <em>accepting computation</em> if it
halts in state \(q_Y\). All other computations, halting or not are
classified as <em>non-accepting computations</em>.</li>
</ul>
</li>
</ul>
<p>The choice of whether to remain active, and, if so, which symbol to write, is
made by the guessing module in a totally arbitrary manner. An important
consequence is that the guessing module can write any string from
\(\Gamma^*\) before it halts (if it ever does).</p>
<p><strong>Properties</strong></p>
<p>An NDTM program \(M\) has an infinite number of possible computations for a
given input string \(x\), one for each possible guessed string from
\(\Gamma^*\).</p>
<p>An NDTM program \(M\) accepts \(x\) if at least one of these is an accepting
computation.</p>
<p>The language recongnized by \(M\) is
\[L_M = \{x\in\Sigma^* : M \ accepts \ x\}\]</p>
<p>The <em>time</em> required by an NDTM program \(M\) to accept the string
\(x\in L_M\) is the minimum, over all accepting computations of \(M\) for
\(x\) of the number of steps ocurring in the guessing and checking stages up
until the halt state \(q_Y\) is entered.</p>
<p>The <em>time complexity function</em> \(T_M: \mathbb{Z}^+\rightarrow\mathbb{Z}^+\)
for \(M\) is
\[
T_M(n) = max (\{1\}\cup\{m: \exists x\in\Sigma^* with \ |x|=n \ \
s.t. \ the \ time \ to \ accept \ x \ by \ M \ is \ m
\})
\]</p>
<p>The time complexity function for \(M\) depends only on the number of steps
occurring in <em>accepting computations</em>. By convention, \(T_M(n)\) is \(1\)
for whenever no inputs of length \(n\) are accepted by \(M\).</p>
<p>The NDTM program \(M\) is a <em>polynomial time NDTM program</em> if there exists a
polynomial \(p\) such that \(\forall n\geq 1: \ T_M(n)\leq p(n) \).</p>
<p><strong>Definition</strong>
\[
NP = \{L: there \ is \ a \ polynomial \ time \ NDTM \ program
\ M \ for \ which \ L_M=L\}
\]</p>
<p>A decision problem \(\Pi\) will be said to belong to \(NP\) under encoding
scheme \(e\) if the language \(L[\Pi, e]\in NP\)</p>
<p><strong>Heuristic</strong> We identify \(NP\) with the class of all decision problems
"solvable" by polynomial time nondeterministic algorithms.</p>
<h2 id="the-relationship-between-p-and-np"><a class="header" href="#the-relationship-between-p-and-np">The Relationship between P and NP</a></h2>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../chapters/theorynpcomp/intro.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../chapters/theorynpcomp/proofnpcomp.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../chapters/theorynpcomp/intro.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../chapters/theorynpcomp/proofnpcomp.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../js/highlightjs-line-numbers.js"></script>


    </div>
    </body>
</html>
