<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>The Theory of NP-Completeness - The Guides</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="../../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        
        <!-- MathJax -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="intro.html"><strong>1.</strong> Introduction</a></li><li><a href="chapters/theorynpcomp/intro.html"><strong>2.</strong> Theory of NP-Completeness</a></li><li><ul class="section"><li><a href="chapters/theorynpcomp/theorynpcomp.html" class="active"><strong>2.1.</strong> The Theory of NP-Completeness</a></li><li><a href="chapters/theorynpcomp/proofnpcomp.html"><strong>2.2.</strong> Proving NP-Complete Results</a></li></ul></li><li><a href="chapters/algsInC/intro.html"><strong>3.</strong> Algorithms and Data Structures in C</a></li><li><ul class="section"><li><a href="chapters/algsInC/cprimer.html"><strong>3.1.</strong> C Primer</a></li><li><a href="chapters/algsInC/sorting.html"><strong>3.2.</strong> Sorting</a></li><li><a href="chapters/algsInC/searching.html"><strong>3.3.</strong> Searching</a></li><li><a href="chapters/algsInC/linkedlist.html"><strong>3.4.</strong> Linked Lists</a></li><li><a href="chapters/algsInC/stack.html"><strong>3.5.</strong> Stacks</a></li><li><a href="chapters/algsInC/queue.html"><strong>3.6.</strong> Queues</a></li><li><a href="chapters/algsInC/trees.html"><strong>3.7.</strong> Trees</a></li><li><a href="chapters/algsInC/graphs.html"><strong>3.8.</strong> Graphs</a></li></ul></li><li><a href="chapters/linprog/intro.html"><strong>4.</strong> Linear &amp; Integer Programming</a></li><li><ul class="section"><li><a href="chapters/linprog/linear.html"><strong>4.1.</strong> Linear Programming</a></li><li><a href="chapters/linprog/integer.html"><strong>4.2.</strong> Integer Programming</a></li></ul></li><li><a href="chapters/automata/intro.html"><strong>5.</strong> Langages et Automates</a></li><li><ul class="section"><li><a href="chapters/automata/grammars.html"><strong>5.1.</strong> Grammaires</a></li><li><a href="chapters/automata/automata.html"><strong>5.2.</strong> Automates</a></li></ul></li><li><a href="chapters/ocaml/intro.html"><strong>6.</strong> OCaml Functional Programming</a></li><li><ul class="section"><li><a href="chapters/ocaml/n99exercises.html"><strong>6.1.</strong> 99 Excercises in OCaml</a></li><li><a href="chapters/ocaml/lambdacalc.html"><strong>6.2.</strong> Lambda Calcul</a></li></ul></li><li><a href="chapters/umath/intro.html"><strong>7.</strong> Maths de 1er cycle</a></li><li><ul class="section"><li><a href="chapters/umath/logique.html"><strong>7.1.</strong> Logique</a></li><li><a href="chapters/umath/suites.html"><strong>7.2.</strong> Suites</a></li><li><a href="chapters/umath/fonctions.html"><strong>7.3.</strong> Fonctions</a></li><li><a href="chapters/umath/contin.html"><strong>7.4.</strong> Continuite</a></li><li><a href="chapters/umath/deriv.html"><strong>7.5.</strong> Derivation</a></li><li><a href="chapters/umath/series.html"><strong>7.6.</strong> Series</a></li><li><a href="chapters/umath/arith.html"><strong>7.7.</strong> Arithmetique</a></li><li><a href="chapters/umath/group.html"><strong>7.8.</strong> Groupes</a></li><li><a href="chapters/umath/anneau.html"><strong>7.9.</strong> Anneaux</a></li><li><a href="chapters/umath/corps.html"><strong>7.10.</strong> Corps</a></li><li><a href="chapters/umath/actionsgroup.html"><strong>7.11.</strong> Actions de Groupes</a></li><li><a href="chapters/umath/linalg.html"><strong>7.12.</strong> Algebre Lineaire</a></li><li><a href="chapters/umath/reduction.html"><strong>7.13.</strong> Reduction des Endomorphismes</a></li><li><a href="chapters/umath/suitef.html"><strong>7.14.</strong> Suites de Fonctions</a></li><li><a href="chapters/umath/seriesf.html"><strong>7.15.</strong> Series de Fonctions</a></li><li><a href="chapters/umath/topologie.html"><strong>7.16.</strong> Topologie</a></li><li><a href="chapters/umath/integration.html"><strong>7.17.</strong> Integration</a></li><li><a href="chapters/umath/calcdiff.html"><strong>7.18.</strong> Calcul Differentiel</a></li><li><a href="chapters/umath/proba.html"><strong>7.19.</strong> Probabilites</a></li><li><a href="chapters/umath/stat.html"><strong>7.20.</strong> Statistique</a></li><li><a href="chapters/umath/equadiff.html"><strong>7.21.</strong> Equations Differentielles</a></li><li><a href="chapters/umath/numlinalg.html"><strong>7.22.</strong> Algebre Lineaire Numerique</a></li><li><a href="chapters/umath/analhilbert.html"><strong>7.23.</strong> Analyse Hilbertienne</a></li></ul></li><li><a href="chapters/about/whoami.html"><strong>8.</strong> About</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">The Guides</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="chapters/theorynpcomp/theorynpcomp.html#the-theory-of-np-completeness" id="the-theory-of-np-completeness"><h1>The Theory of NP-Completeness</h1></a>
<a class="header" href="chapters/theorynpcomp/theorynpcomp.html#decision-problems-languages-and-encoding-schemes" id="decision-problems-languages-and-encoding-schemes"><h2>Decision Problems, Languages and Encoding Schemes</h2></a>
<p>The theory of \(NP\)-completeness is designed to be applied only to decision
problems.</p>
<p>A Decision problem is a problem with only two possible solutions: &quot;yes&quot; and &quot;no&quot;.</p>
<p><strong>Definition</strong>
A decision problem \(\Pi\) consists of a set \(D_\Pi\) of instances and a
subset \(Y_\Pi \subseteq D_\Pi\) of <em>yes</em>-instances.</p>
<p>\(\rightarrow\) a more practical approach is to define a <em>generic instance</em>
using a set of various components (graphs, functions, numbers, sets) and a
<em>yes-no</em> question asked in terms of the generic instance.</p>
<p>An instance belongs to \(D_\Pi\) iff it can be obtained from a generic instance
by substiting particular objects of the specified types for all
the generic components.</p>
<p>An instance belongs to \(Y_\Pi\) iff the answer to the stated question,
when particularized to that instance, is <em>&quot;yes&quot;</em>.</p>
<p><strong>Examples</strong></p>
<ul>
<li>
<p><strong>Subgraph Isomorphism</strong></p>
<p><em>Instance</em>: Two graphs \(G_1=(V_1, E_1)\) and \(G_2=(V_2, E_2)\).</p>
<p><em>Question</em>: Does \(G_1\) contain a subgraph isomorphic to \(G2\), that is,
a subset \(V'\subseteq V_1\) and a subset \(E'\subseteq E_1\) such that
\(|V'|=|V_2|\), \(|E'|=|E_2|\), and there exists a one-to-one function
\(f: V_2 \rightarrow V'\) satisfying \(\{u, v\}\in E_2\) iff
\(\{f(u), f(v)\}\in E'\) ?</p>
</li>
<li>
<p><strong>Traveling Salesman</strong></p>
<p><em>Instance</em>: A finite set \(C=\{c_1, ..., c_m\}\) of &quot;cities&quot;, a &quot;distance&quot;
\(d(c_i, c_j)\in\mathbb{Z}^+\) for each pair of cities \(c_i, c_j \in C\)
, and a bound \(B\in\mathbb{Z}^+\).</p>
<p><em>Question</em>: Is there a &quot;tour&quot; of all the cities in \(C\) having total
length no more than \(B\), that is an ordering
\(&lt; c_{\pi(1)}, ..., c_{\pi(m)} &gt;\) of \(C\) such that</p>
<p>\[(\sum_{i=1}^{m-1}{d(c_{\pi(i)}, c_{\pi(i+1)})}) + d(c_{\pi(m)}, c_{\pi(1)}) \leq B ?\]</p>
</li>
</ul>
<p>The traveling salesman problem variant described above is an example of how
a non decision problem can be transformed into a decision problem.</p>
<p><strong>Definition</strong></p>
<p>For any finite set \(\Sigma\) of symbols, we denote by \(\Sigma^* \) the set
of all finite strings of symbols from \(\Sigma\). If \(L\) is a subset
of \(\Sigma^* \), we say that \(L\) is a <strong>language</strong> over the <strong>alphabet</strong>
\(\Sigma\).</p>
<p><strong>Examples</strong></p>
<ul>
<li>If \(\Sigma=\{0, 1\}\) then \(\Sigma^* \) consists of the empty string
&quot;\(\epsilon\)&quot;, the strings \(0, 1, 00, 01, 11, 000, 001\) and all other
finite strings of \(1\)'s and \(0\)'s.</li>
<li>\(\{01, 001, 111, 1101010\}\) is a language over \(\{0, 1\}\), as is
the set of all binary representations of integers that are perfect squares,
as is \(\{0, 1\}^* \) itself.</li>
</ul>
<p><strong>Definition</strong></p>
<p>An encoding scheme \(e\) for a problem \(\Pi\) provides a way of describing
each instance of \(\Pi\) by an appropriate string of symbols over some fixed
alphabet \(\Sigma\).</p>
<p><strong>Remark</strong></p>
<p>The problem \(\Pi\) and the encoding sceme \(e\) for \(\Pi\) partition
\(\Sigma^* \) intro three classes of strings:</p>
<ul>
<li>those that are not encodings of instances of \(\Pi\).</li>
<li>those that encode instances of \(\Pi\) for which the answer is &quot;<em>no</em>&quot;.</li>
<li>those that encode instances of \(\Pi\) for which the answer is &quot;<em>yes</em>&quot;.</li>
</ul>
<p><strong>Definition</strong></p>
<p>Assuming that \(\Sigma\) is the alphabet used by \(e\),
the language associated to the problem \(\Pi\) and the encoding \(e\) is
denoted :
\[
L[\Pi, e] = \{x\in\Sigma^* :  x\
is\ the\ encoding\ under\ e\ of\ an \ instance\ I\in Y_{\Pi}\}.
\]</p>
<p><strong>Lemma</strong>
If a result holds for the language \(L[\Pi, e]\), then it holds for the
problem \(\Pi\) under the encoding scheme \(e\).</p>
<p>Assuming the encodings we employ are &quot;reasonable&quot; most properties are
encoding-independant.</p>
<p>We assume that every decision problem \(\Pi\) has an associated
encoding-independant function \(Length: D_\Pi \rightarrow\mathbb{N}\),
which is &quot;polynomially related&quot; to the input lengths we would we would obtain
from a reasonable encoding scheme.</p>
<p><strong>A Standard Encoding Scheme</strong></p>
<p>The alphabet used is \(\Psi=\{ 0 , 1 , - , [ , ] , ( , ) , , \} \).</p>
<p>We define <strong>structured strings</strong> recursively:</p>
<ol>
<li>An integer \(k\) is represented by a string of \(0\)'s and \(1\)'s
preceded by a minus sign &quot;\(-\)&quot; if \(k\) is negative.</li>
<li>If \(x\) is a structured string representing the integer \(k\), then
\([x]\) is a structured string that can be used as a &quot;name&quot;. (for examples:
a vertex in a graph, a set element, a city in the traveling salesman problem).</li>
<li>If \(x_1, \dots, x_m\) are structured strings representing the objects
\(X_1, ..., X_m\), then \((x_1, ..., x_m)\) is a structured string
representing the sequence \(&lt; X_1, ..., X_m &gt;\).</li>
</ol>
<p>We already know how to encode <strong>integers</strong> and <strong>sequences</strong>.</p>
<ul>
<li>A <strong>set</strong> is represented by ordering its elements as a sequence
\(&lt; X_1, ..., X_m &gt;\) and taking the structured string corresponding
to that sequence.</li>
<li>A <strong>graph</strong> with vertex set \(V\) and edge set \(E\) is represented by a
structured string \((x, y)\), where \(x\) is a structured string
representing the set \(V\) and \(y\) is a structured string representing
the \(E\) (the elements of \(E\) being the two-element subsets of \(V\)
that are edges).</li>
<li>A <strong>finite function</strong>  \(f: \{U_1, ..., U_m\}\rightarrow W\) is
represented by a structured string \(((x_1, y_1), ... ,(x_m, y_m))\) where
\(x_i\) is a structured string representing the object \(U_i\)
and \(y_i\) a structured string representing the object \(f(U_i)\in W\)
, \(\forall \ 1\leq i\leq m\).</li>
<li>A <strong>rational number</strong> \(q\) is represented by a structured string
\((x,y)\) where \(x\) is a structured string representing an integer
\(a\), \(y\) is a structured string representing an integer \(b\),
\(a/b=q\), and \(GCD(a, b)=1\).</li>
</ul>
<p>Two structured strings written in the standard encoding schemes can represent
a same object without being strictly the same.</p>
<p>From now on, an encoding scheme is said to be reasonable if it is equivalent
to the standard encoding scheme, in the sense that there exist polynomial time
algorithms for converting an encoding of an instance back and forth between
the two encoding schemes.</p>
<a class="header" href="chapters/theorynpcomp/theorynpcomp.html#deterministic-turing-machines-and-the-class-p" id="deterministic-turing-machines-and-the-class-p"><h2>Deterministic Turing Machines and the Class P</h2></a>
<p><strong>Definition</strong></p>
<p>A <strong>Deterministic One-Tape Turing Machine</strong> (DTM) is a model of computation
which consists of a <em>finite state control</em>, a <em>read-write head</em> and a two-way
infinite <em>tape</em> of squares labeled (\(..., -2, -1, 0, 1, 2, ...\)).</p>
<p><img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/deterministic_turing_machine.jpg" alt="img" /></p>
<p><strong>Definition</strong></p>
<p>A <em>program</em> for a DTM specifies the following information:</p>
<ol>
<li>A finite set \(\Gamma\) of tape symbols, including a subset
\(\Sigma\subset\Gamma\) of <em>input</em> symbols and a distinguished
<em>blank symbol</em> \(b\in\Gamma\backslash\Sigma\);</li>
<li>a finite set \(\mathcal{Q}\) of <em>states</em>, including a distinguished <em>start-state</em>
\(q_0\) and two distinguished <em>halt-states</em> \(q_Y\) and \(q_N\);</li>
<li>a <em>transition function</em>
\(\delta: (\mathcal{Q}\backslash\{q_Y, q_N\})\times\Gamma\rightarrow
\mathcal{Q}\times\Gamma\times\{-1, +1\}\).</li>
</ol>
<p><strong>Operation of a DTM program</strong></p>
<p>The input to the DTM is a string \(x\in\Sigma^*\).</p>
<p>All the tape squares initially contain the blank symbol \(b\).</p>
<p>The string \(x\) is placed in tape squares 1 through \(|x|\).</p>
<p>The program starts its operation in state \(q_0\), with the head scanning tape
square \(1\).</p>
<p>At each step:</p>
<ul>
<li>If the current state \(q\) is either \(q_Y\) or \(q_N\), then the
computation has ended, with the answer being &quot;\(yes\)&quot; if \(q=q_Y\)
or &quot;\(no\)&quot; if \(q=q_N\).</li>
<li>Else we have \(q\in \mathcal{Q}\backslash \{q_Y, q_N\}\) and there is a symbol
\(s\) in the tape square being scanned. The value of the <em>transition
function</em> can be computed:
\(\delta(q, s)=(q', s', \Delta)\). The <em>read write head</em> then replaces
the symbol \(s\) by \(s'\) in the current square, it then moves one square
right if \(\Delta=1\) or one square left if \(\Delta=-1\). The
<em>finite state control</em> updates the state value from \(q\) to \(q'\).</li>
</ul>
<p><strong>Definition</strong></p>
<p>We say that a DTM program \(M\) with input alphabet \(\Sigma\) <em>accepts</em>
\(x\in\Sigma^*\) if and only if \(M\) halts in state \(q_Y\) when applied
to input \(x\).</p>
<p><strong>Definition</strong>
: The language \(L_M\) recognized by the program \(M\) is given by
\(L_M = \{x\in\Sigma^*: M \ accepts\ x\}\).</p>
<p>If \(x\in(\Sigma^*\backslash L_M)\) then either the computation of \(M\) on
\(x\) halts in state \(q_N\) or it does not halt <em>ie: continues forever</em>.</p>
<p><strong>Definition</strong></p>
<p>We say that a DTM program \(M\) <em>solves</em> the decision problem \(\Pi\) under
encoding scheme \(e\) if \(M\) halts for all input strings over its input
alphabet and \(L_M = L[\Pi, e]\).</p>
<p><strong>Example</strong>: Integer Divisibility by four.</p>
<p>Instance: A positive integer \(N\).</p>
<p>Question: Is there a positive integer \(m\) such that \(N=4m\)?</p>
<p>Using the standard encoding scheme, the integer \(N\) is represented by the
string of  \(0\)'s and \(1\)'s that is its binary representation.</p>
<p>\[
\Gamma=\{0, 1, b\}, \Sigma=\{0, 1\} \\
\mathcal{Q}=\{q_0, q_1, q_2, q_3, q_Y, q_N\} \\
\delta(q_0, 0)=(q_0, 0, +1), \
\delta(q_0, 1)=(q_0, 1, +1)\\
\delta(q_0, b)=(q_1, b, -1), \
\delta(q_1, 0)=(q_2, b, -1)\\
\delta(q_1, 1)=(q_3, b, -1), \
\delta(q_1, b)=(q_N, b, -1)\\
\delta(q_2, 0)=(q_Y, b, -1), \
\delta(q_2, 1)=(q_N, b, -1)\\
\delta(q_2, b)=(q_N, b, -1), \
\delta(q_3, 0)=(q_N, b, -1)\\
\delta(q_3, 1)=(q_N, b, -1), \
\delta(q_3, b)=(q_N, b, -1)\\
M=(\Gamma, \mathcal{Q}, \delta).
\]</p>
<p>Here as example of the execution of this program on the string
\(x=10100\).</p>
<p><img src="media/dtmM.png" alt="dtm execution diagram" /></p>
<p>The language \(L_M\) recognized by the program \(M\) is given by
\(L_M = \{x\in\Sigma^*: M\ accepts \ x\}\).</p>
<p>It can be shown that \(L_M\) is exactly the language</p>
<p>\[
\{x\in\{0, 1\}^*: the \ rightmost \ two \ symbols \ of \ x
\ are \ both \ 0 \}.
\]</p>
<p>Since an integer \(N\) is divisible by \(4\) if and only if the last two
digits of its binary representation are \(0\), the DTM program \(M\) solves
the INTEGER DIVISIBILITY BY FOUR problem.</p>
<p><strong>Remark</strong>: A DTM program can compute functions. HOW???</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="chapters/theorynpcomp/intro.html" class="mobile-nav-chapters previous" title="Previous chapter">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="chapters/theorynpcomp/proofnpcomp.html" class="mobile-nav-chapters next" title="Next chapter">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="chapters/theorynpcomp/intro.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="chapters/theorynpcomp/proofnpcomp.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        
        <script type="text/javascript" src="highlightjs-line-numbers.js"></script>
        

    </body>
</html>
