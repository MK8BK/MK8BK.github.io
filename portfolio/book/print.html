<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>The Guides</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        
        <!-- MathJax -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="intro.html"><strong>1.</strong> Introduction</a></li><li><a href="chapters/ccpp/intro.html"><strong>2.</strong> C/C++ Notes</a></li><li><ul class="section"><li><a href="chapters/ccpp/gcc.html"><strong>2.1.</strong> gcc</a></li><li><a href="chapters/ccpp/c.html"><strong>2.2.</strong> C</a></li></ul></li><li><a href="chapters/theorynpcomp/intro.html"><strong>3.</strong> Theory of NP-Completeness</a></li><li><ul class="section"><li><a href="chapters/theorynpcomp/theorynpcomp.html"><strong>3.1.</strong> The Theory of NP-Completeness</a></li><li><a href="chapters/theorynpcomp/proofnpcomp.html"><strong>3.2.</strong> Proving NP-Complete Results</a></li></ul></li><li><a href="chapters/ocaml/intro.html"><strong>4.</strong> OCaml Functional Programming</a></li><li><ul class="section"><li><a href="chapters/ocaml/n99exercises.html"><strong>4.1.</strong> 99 Excercises in OCaml</a></li><li><a href="chapters/ocaml/lambdacalc.html"><strong>4.2.</strong> Lambda Calcul</a></li></ul></li><li><a href="chapters/umath/intro.html"><strong>5.</strong> Maths de 1er cycle</a></li><li><ul class="section"><li><a href="chapters/umath/logique.html"><strong>5.1.</strong> Logique</a></li><li><a href="chapters/umath/suites.html"><strong>5.2.</strong> Suites</a></li><li><a href="chapters/umath/fonctions.html"><strong>5.3.</strong> Fonctions</a></li><li><a href="chapters/umath/contin.html"><strong>5.4.</strong> Continuite</a></li><li><a href="chapters/umath/deriv.html"><strong>5.5.</strong> Derivation</a></li><li><a href="chapters/umath/series.html"><strong>5.6.</strong> Series</a></li><li><a href="chapters/umath/arith.html"><strong>5.7.</strong> Arithmetique</a></li><li><a href="chapters/umath/group.html"><strong>5.8.</strong> Groupes</a></li><li><a href="chapters/umath/anneau.html"><strong>5.9.</strong> Anneaux</a></li><li><a href="chapters/umath/corps.html"><strong>5.10.</strong> Corps</a></li><li><a href="chapters/umath/actionsgroup.html"><strong>5.11.</strong> Actions de Groupes</a></li><li><a href="chapters/umath/linalg.html"><strong>5.12.</strong> Algebre Lineaire</a></li><li><a href="chapters/umath/reduction.html"><strong>5.13.</strong> Reduction des Endomorphismes</a></li><li><a href="chapters/umath/suitef.html"><strong>5.14.</strong> Suites de Fonctions</a></li><li><a href="chapters/umath/seriesf.html"><strong>5.15.</strong> Series de Fonctions</a></li><li><a href="chapters/umath/topologie.html"><strong>5.16.</strong> Topologie</a></li><li><a href="chapters/umath/integration.html"><strong>5.17.</strong> Integration</a></li><li><a href="chapters/umath/calcdiff.html"><strong>5.18.</strong> Calcul Differentiel</a></li><li><a href="chapters/umath/proba.html"><strong>5.19.</strong> Probabilites</a></li><li><a href="chapters/umath/stat.html"><strong>5.20.</strong> Statistique</a></li><li><a href="chapters/umath/equadiff.html"><strong>5.21.</strong> Equations Differentielles</a></li><li><a href="chapters/umath/numlinalg.html"><strong>5.22.</strong> Algebre Lineaire Numerique</a></li><li><a href="chapters/umath/analhilbert.html"><strong>5.23.</strong> Analyse Hilbertienne</a></li></ul></li><li><a href="chapters/about/whoami.html"><strong>6.</strong> About</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">The Guides</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#mk8bks-technical-guides" id="mk8bks-technical-guides"><h1>MK8BK's Technical Guides</h1></a>
<p>This website is a fusion of a portfolio, a knowledge base
and a blog.</p>
<a class="header" href="print.html#c-notes" id="c-notes"><h1>C++ Notes</h1></a>
<a class="header" href="print.html#gcc" id="gcc"><h1>gcc</h1></a>
<table><thead><tr><th> Extension </th><th> File Type </th></tr></thead><tbody>
<tr><td> .c </td><td> C source file </td></tr>
<tr><td> .cpp/.cc/.cxx </td><td> C++ source file </td></tr>
<tr><td> .o/.obj </td><td> Object file </td></tr>
<tr><td> .exe </td><td> Windows executable </td></tr>
<tr><td> <em>no extension</em> </td><td> Unix/Linux executable </td></tr>
<tr><td> .dll </td><td> Windows dynamic library </td></tr>
<tr><td> .lib </td><td> Windows static library </td></tr>
<tr><td> .so </td><td> Unix/Linux dynamic library </td></tr>
<tr><td> .a </td><td> Unix/Linux/MacOS static library </td></tr>
<tr><td> .dylib </td><td> MacOS dynamic library </td></tr>
</tbody></table>
<a class="header" href="print.html#c" id="c"><h2>C</h2></a>
<pre><code class="language-bash">gcc -c x.c # compile c source file into x.o object file
gcc -c x.c y.c # compile c source files into x.o and y.o object files
gcc -o executable x.o y.o # link object files x.o and y.o into a single executable file

# compile and link source files x.c and y.c into a single executable file
gcc -o executable x.c y.c # intermediate object files are discarded

# compile and link source files x.c and y.c into a single executable file
# looks up any undefined symbols during linking in library named **libsomething**.
gcc -o executable x.c y.c -lsomething # -lABC -&gt; search in libABC
</code></pre>
<a class="header" href="print.html#c-1" id="c-1"><h2>C++</h2></a>
<pre><code class="language-bash">g++ -c x.cpp # compile cpp source file into x.o object file
g++ -c x.cpp y.cpp # compile cpp source files into x.o and y.o object files
g++ -o executable x.o y.o # link object files x.o and y.o into a single executable file
# compile and link source files x.cpp and y.cpp into a single executable file
g++ -o executable x.cpp y.cpp # intermediate object files are discarded

# compile and link source files x.cpp and y.cpp into a single executable file
# looks up any undefined symbols during linking in library named **libsomething**
g++ -o executable x.cpp y.cpp -lsomething # -lABC -&gt; search in libABC

# specify C++ standard -&gt; use -std=bruh flag
g++ -o prog main.cpp -std=c++17
</code></pre>
<a class="header" href="print.html#c-2" id="c-2"><h1>C</h1></a>
<p>A <code>char</code> type is always encoded using 8 bits \(\rightarrow\) just an integer type
with a fixed range.</p>
<p>An <code>int</code> type usually has the same size as the processor's registers.</p>
<p>\[8=taille(char)\leq taille(short)\leq taille(int) \leq taille(long)
\leq taille(long \ long)\]</p>
<p>Operations on integer types ALWAYS return integer types: 3/2 \(\rightarrow\) 1.</p>
<p>IEEE-764 floating point encodings (most frequently used):</p>
<table><thead><tr><th> type </th><th> # bits </th><th> # digits of precision </th></tr></thead><tbody>
<tr><td> float </td><td> 4 </td><td> 6 </td></tr>
<tr><td> double </td><td> 8 </td><td> 15 </td></tr>
<tr><td> long double </td><td> 10 </td><td> 18 </td></tr>
</tbody></table>
<p>If a literal contains a point or exponent (<code>e</code> or <code>E</code>), then it is a floating type.
Otherwise, it is an integer type.</p>
<p>To use a different number base (<em>ie: not decimal</em>), prefix with <code>0b</code> for binary,
<code>0x</code> for hexadecimal and <code>0</code> for octal.</p>
<p>In C: <code>'A'</code> is of type <code>int</code>, in C++: it is of type <code>char</code>.</p>
<pre><code class="language-c">printf(&quot;\a&quot;); // produces a sound
</code></pre>
<p>By default, <code>2.3</code> is of type <code>double</code>.</p>
<p>To specify a literals type, use a suffix (or a combination for unsigned types):</p>
<table><thead><tr><th> type </th><th> suffix </th></tr></thead><tbody>
<tr><td> char </td><td> <em>none</em> </td></tr>
<tr><td> short </td><td> <em>none</em> </td></tr>
<tr><td> int </td><td> <em>none</em> </td></tr>
<tr><td> long </td><td> L </td></tr>
<tr><td> long long </td><td> LL </td></tr>
<tr><td> float </td><td> F/f </td></tr>
<tr><td> double </td><td> <em>none</em> </td></tr>
<tr><td> long double </td><td> L </td></tr>
<tr><td> unsigned int </td><td> U/u </td></tr>
</tbody></table>
<p>Addresses and Pointers Nonsense:</p>
<pre><code class="language-c">char u; // a character
char *pu; // a pointer to a character
char *ppu; // a pointer to a pointer to a character

u = 2; // assign the value of the literal 2 to u
pu = &amp;u; // assign the address of u to pu
ppu = &amp;pu; // assign the address of pu to ppu

// pointer dereference, lines 13, 14 and 15 have the same effect
int a = 2;
int *pa = &amp;a;
int **ppa = &amp;pa;
a = 0; 
*pa = 0;
**ppa = 0;
</code></pre>
<p><code>The value of a pointer is an address.</code></p>
<p>Pointer to Function Example:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int f(int n){
    return n/2;
}

int main(){
    int (*fp)(int) = &amp;f;
    printf(&quot;%d\n&quot;, (*fp)(8));
    return 0;
}
</code></pre>
<p>Always initialize a pointer.</p>
<pre><code class="language-cpp">int *p1 = 0 // the only allowed int to pointer assignment!
int *p2 = NULL // same
p1 = nullptr; // preferable in std&gt;=C++11
</code></pre>
<p>Enumerated int constants:</p>
<pre><code class="language-c">enum {f, t}; // f: 0, t: 1
enum {f=10, t, d=2}; // f: 10, t: 11, d: 2
</code></pre>
<p>Constants and pointers</p>
<pre><code class="language-c">int const  *ptr; 
// ptr is a pointer to constant int -&gt; can't modify the pointed variable with this pointer.
int *const ptr = &amp;x;  
// ptr is a constant pointer to int -&gt; can't modify the address stored in this pointer.
</code></pre>
<a class="header" href="print.html#theory-of-np-completeness" id="theory-of-np-completeness"><h1>Theory of NP-Completeness</h1></a>
<p>This chapter is a summary of the book
&quot;<em>Computers and Intractability: A Guide to the Theory of NP-Completeness</em>&quot;
- <em>Michael R.Garey / David S. Johnson</em>.</p>
<a class="header" href="print.html#basics" id="basics"><h2>Basics</h2></a>
<p><strong>Purpose</strong>:
&quot;<em>In short, the primary application of the theory of \(NP\)-completeness
is to assist algorithm designers in directing their problem-solving efforts
towards those approaches that have the greatest likelihood of leading to
useful algorithms</em>&quot;
<br></p>
<p><strong>Definition</strong></p>
<p>\(f(n)\) is \(O(g(n))\) if there exists a constant \(c\) such that
\(|f(n)|\leq c\cdot|g(n)|\) for all values of \(n\).</p>
<p><strong>Definition</strong></p>
<p>A problem is <strong>intractable</strong> if no polynomial
time algorithm can possibly solve it.</p>
<p><strong>Two cases of intractability</strong></p>
<ol>
<li>A problem is so difficult that an exponential amount of time is required
to find a solution.</li>
<li>A solution to the problem cannot be encoded into an expression having
length bounded by a polynomial fuction of the input length.
<br>\(\longrightarrow\) only problems for which the solution length is
bounded by a polynomial function of the input length will be considered.</li>
</ol>
<p><strong>Definition</strong></p>
<p>A problem is said to be <strong>undecidable</strong> if no algorithm
at all can be given for solving it.</p>
<p><em>Examples</em></p>
<ol>
<li>The halting problem is undecidable: it is impossible to specify an algorithm
which, given an arbitrary computer program and an arbitrary input to that
program, can decide whether or not the program will eventually halt when
applied to that input.</li>
<li>Hilbert's tenth problem: solvability of polynomial equations in integers.</li>
<li>The triviality problem for finitely presented groups
<a href="https://arxiv.org/pdf/1401.2273.pdf">[Rabin 1958]</a>.</li>
</ol>
<p><strong>Remark</strong>
Undecidable problems are intractable.</p>
<p><strong>Definition</strong></p>
<p>A problem is said to be <strong>non-deterministically intractable</strong> if it cannot be solved
in polynomial time using a <strong>non-deterministic computer</strong> model, which has the
ability to pursue an unbounded number of independant computational sequences
in parallel.</p>
<p><strong>Remark</strong>
All provably intractable problems known to date are either undecidable or
non-deterministically intractable.</p>
<p><strong>Definition</strong></p>
<ul>
<li>NP is the set of decision problems solvable in polynomial time by a nondeterministic Turing machine.</li>
<li>NP is the set of decision problems verifiable in polynomial time by a deterministic Turing machine.</li>
</ul>
<p><strong>Reduction</strong> is a technique used for demonstrating that two problems are
related to one another, by giving a constructive transformation that maps
any instance of the first problem into an equivalent instance of the second.</p>
<p>The Complexity of Theorem Proving Procedures - <a href="https://doi.org/10.1145/800157.805047">paper by Cook</a></p>
<ol>
<li>Polynomial time reducibility: If we have a polynomial time reduction
from one problem to another, this ensures that any polynomial time algorithm
for the second problem can be converted into a polynomial time algorithm for
the first problem.</li>
<li>Most of the apparently intractable problems encountered in practice, when
phrased as decision problems belong to the class of \(NP\) decision problems that
can be solved in polynomial time by a non-deterministic computer.</li>
<li>Every problem in NP can be polynomially reduced to the satisfiability problem.</li>
</ol>
<p>The satisfiability problem is the &quot;hardest&quot; problem in \(NP\).</p>
<p>The problem &quot;Does a graph \(G\) contain a
complete subgraph on a given number \(k\) of vertices?&quot; also has this property.</p>
<p>The class of these &quot;hardest&quot; problems in \(NP\) has been shown to include
many other problems by <em>Richard Karp</em> in <em>1972</em>.
See this <a href="https://en.wikipedia.org/wiki/Karp%27s_21_NP-complete_problems">page</a>
for more details.</p>
<p>The equivalence class of the Satisfiability problems is called the set of
<strong>\(NP\)-complete</strong> problems.</p>
<p>Here is a more concrete definition from <a href="https://en.wikipedia.org/wiki/NP-completeness">wikipedia</a>:</p>
<p>A problem is <strong>\(NP\)-complete</strong> if:</p>
<ul>
<li>It is a decision problem, meaning that for any input to the problem,
the output is either &quot;yes&quot; or &quot;no&quot;.</li>
<li>When the answer is &quot;yes&quot;, this can be demonstrated through the existence
of a short (polynomial length) solution.</li>
<li>The correctness of each solution can be verified quickly (namely,
in polynomial time) and a brute-force search algorithm can find a solution
by trying all possible solutions.</li>
<li>The problem can be used to simulate every other problem for which we can
verify quickly that a solution is correct. In this sense, NP-complete
problems are the hardest of the problems to which solutions can be verified
quickly. If we could find solutions of some NP-complete problem quickly,
we could quickly find the solutions of every other problem to which a given
solution can be easily verified.</li>
</ul>
<p><strong>Open Question</strong>: are the \(NP\)-complete problems intractable ?</p>
<a class="header" href="print.html#the-theory-of-np-completeness" id="the-theory-of-np-completeness"><h1>The Theory of NP-Completeness</h1></a>
<a class="header" href="print.html#decision-problems-languages-and-encoding-schemes" id="decision-problems-languages-and-encoding-schemes"><h2>Decision Problems, Languages and Encoding Schemes</h2></a>
<p>The theory of \(NP\)-completeness is designed to be applied only to decision
problems.</p>
<p>A Decision problem is a problem with only two possible solutions: &quot;yes&quot; and &quot;no&quot;.</p>
<p><strong>Definition</strong>
A decision problem \(\Pi\) consists of a set \(D_\Pi\) of instances and a
subset \(Y_\Pi \subseteq D_\Pi\) of <em>yes</em>-instances.</p>
<p>\(\rightarrow\) a more practical approach is to define a <em>generic instance</em>
using a set of various components (graphs, functions, numbers, sets) and a
<em>yes-no</em> question asked in terms of the generic instance.</p>
<p>An instance belongs to \(D_\Pi\) iff it can be obtained from a generic instance
by substiting particular objects of the specified types for all
the generic components.</p>
<p>An instance belongs to \(Y_\Pi\) iff the answer to the stated question,
when particularized to that instance, is <em>&quot;yes&quot;</em>.</p>
<p><strong>Examples</strong></p>
<ul>
<li>
<p><strong>Subgraph Isomorphism</strong></p>
<p><em>Instance</em>: Two graphs \(G_1=(V_1, E_1)\) and \(G_2=(V_2, E_2)\).</p>
<p><em>Question</em>: Does \(G_1\) contain a subgraph isomorphic to \(G2\), that is,
a subset \(V'\subseteq V_1\) and a subset \(E'\subseteq E_1\) such that
\(|V'|=|V_2|\), \(|E'|=|E_2|\), and there exists a one-to-one function
\(f: V_2 \rightarrow V'\) satisfying \(\{u, v\}\in E_2\) iff
\(\{f(u), f(v)\}\in E'\) ?</p>
</li>
<li>
<p><strong>Traveling Salesman</strong></p>
<p><em>Instance</em>: A finite set \(C=\{c_1, ..., c_m\}\) of &quot;cities&quot;, a &quot;distance&quot;
\(d(c_i, c_j)\in\mathbb{Z}^+\) for each pair of cities \(c_i, c_j \in C\)
, and a bound \(B\in\mathbb{Z}^+\).</p>
<p><em>Question</em>: Is there a &quot;tour&quot; of all the cities in \(C\) having total
length no more than \(B\), that is an ordering
\(&lt; c_{\pi(1)}, ..., c_{\pi(m)} &gt;\) of \(C\) such that</p>
<p>\[(\sum_{i=1}^{m-1}{d(c_{\pi(i)}, c_{\pi(i+1)})}) + d(c_{\pi(m)}, c_{\pi(1)}) \leq B ?\]</p>
</li>
</ul>
<p>The traveling salesman problem variant described above is an example of how
a non decision problem can be transformed into a decision problem.</p>
<p><strong>Definition</strong></p>
<p>For any finite set \(\Sigma\) of symbols, we denote by \(\Sigma^* \) the set
of all finite strings of symbols from \(\Sigma\). If \(L\) is a subset
of \(\Sigma^* \), we say that \(L\) is a <strong>language</strong> over the <strong>alphabet</strong>
\(\Sigma\).</p>
<p><strong>Examples</strong></p>
<ul>
<li>If \(\Sigma=\{0, 1\}\) then \(\Sigma^* \) consists of the empty string
&quot;\(\epsilon\)&quot;, the strings \(0, 1, 00, 01, 11, 000, 001\) and all other
finite strings of \(1\)'s and \(0\)'s.</li>
<li>\(\{01, 001, 111, 1101010\}\) is a language over \(\{0, 1\}\), as is
the set of all binary representations of integers that are perfect squares,
as is \(\{0, 1\}^* \) itself.</li>
</ul>
<p><strong>Definition</strong></p>
<p>An encoding scheme \(e\) for a problem \(\Pi\) provides a way of describing
each instance of \(\Pi\) by an appropriate string of symbols over some fixed
alphabet \(\Sigma\).</p>
<p><strong>Remark</strong></p>
<p>The problem \(\Pi\) and the encoding sceme \(e\) for \(\Pi\) partition
\(\Sigma^* \) intro three classes of strings:</p>
<ul>
<li>those that are not encodings of instances of \(\Pi\).</li>
<li>those that encode instances of \(\Pi\) for which the answer is &quot;<em>no</em>&quot;.</li>
<li>those that encode instances of \(\Pi\) for which the answer is &quot;<em>yes</em>&quot;.</li>
</ul>
<p><strong>Definition</strong></p>
<p>Assuming that \(\Sigma\) is the alphabet used by \(e\),
the language associated to the problem \(\Pi\) and the encoding \(e\) is
denoted :
\[
L[\Pi, e] = \{x\in\Sigma^* :  x\
is\ the\ encoding\ under\ e\ of\ an \ instance\ I\in Y_{\Pi}\}.
\]</p>
<p><strong>Lemma</strong>
If a result holds for the language \(L[\Pi, e]\), then it holds for the
problem \(\Pi\) under the encoding scheme \(e\).</p>
<p>Assuming the encodings we employ are &quot;reasonable&quot; most properties are
encoding-independant.</p>
<p>We assume that every decision problem \(\Pi\) has an associated
encoding-independant function \(Length: D_\Pi \rightarrow\mathbb{N}\),
which is &quot;polynomially related&quot; to the input lengths we would we would obtain
from a reasonable encoding scheme.</p>
<p><strong>A Standard Encoding Scheme</strong></p>
<p>The alphabet used is \(\Psi=\{ 0 , 1 , - , [ , ] , ( , ) , , \} \).</p>
<p>We define <strong>structured strings</strong> recursively:</p>
<ol>
<li>An integer \(k\) is represented by a string of \(0\)'s and \(1\)'s
preceded by a minus sign &quot;\(-\)&quot; if \(k\) is negative.</li>
<li>If \(x\) is a structured string representing the integer \(k\), then
\([x]\) is a structured string that can be used as a &quot;name&quot;. (for examples:
a vertex in a graph, a set element, a city in the traveling salesman problem).</li>
<li>If \(x_1, \dots, x_m\) are structured strings representing the objects
\(X_1, ..., X_m\), then \((x_1, ..., x_m)\) is a structured string
representing the sequence \(&lt; X_1, ..., X_m &gt;\).</li>
</ol>
<p>We already know how to encode <strong>integers</strong> and <strong>sequences</strong>.</p>
<ul>
<li>A <strong>set</strong> is represented by ordering its elements as a sequence
\(&lt; X_1, ..., X_m &gt;\) and taking the structured string corresponding
to that sequence.</li>
<li>A <strong>graph</strong> with vertex set \(V\) and edge set \(E\) is represented by a
structured string \((x, y)\), where \(x\) is a structured string
representing the set \(V\) and \(y\) is a structured string representing
the \(E\) (the elements of \(E\) being the two-element subsets of \(V\)
that are edges).</li>
<li>A <strong>finite function</strong>  \(f: \{U_1, ..., U_m\}\rightarrow W\) is
represented by a structured string \(((x_1, y_1), ... ,(x_m, y_m))\) where
\(x_i\) is a structured string representing the object \(U_i\)
and \(y_i\) a structured string representing the object \(f(U_i)\in W\)
, \(\forall \ 1\leq i\leq m\).</li>
<li>A <strong>rational number</strong> \(q\) is represented by a structured string
\((x,y)\) where \(x\) is a structured string representing an integer
\(a\), \(y\) is a structured string representing an integer \(b\),
\(a/b=q\), and \(GCD(a, b)=1\).</li>
</ul>
<p>Two structured strings written in the standard encoding schemes can represent
a same object without being strictly the same.</p>
<p>From now on, an encoding scheme is said to be reasonable if it is equivalent
to the standard encoding scheme, in the sense that there exist polynomial time
algorithms for converting an encoding of an instance back and forth between
the two encoding schemes.</p>
<a class="header" href="print.html#deterministic-turing-machines-and-the-class-p" id="deterministic-turing-machines-and-the-class-p"><h2>Deterministic Turing Machines and the Class P</h2></a>
<p><strong>Definition</strong></p>
<p>A <strong>Deterministic One-Tape Turing Machine</strong> (DTM) is a model of computation
which consists of a <em>finite state control</em>, a <em>read-write head</em> and a two-way
infinite <em>tape</em> of squares labeled (\(..., -2, -1, 0, 1, 2, ...\)).</p>
<p><img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/deterministic_turing_machine.jpg" alt="img" /></p>
<p><strong>Definition</strong></p>
<p>A <em>program</em> for a DTM specifies the following information:</p>
<ol>
<li>A finite set \(\Gamma\) of tape symbols, including a subset
\(\Sigma\subset\Gamma\) of <em>input</em> symbols and a distinguished
<em>blank symbol</em> \(b\in\Gamma\backslash\Sigma\);</li>
<li>a finite set \(\mathcal{Q}\) of <em>states</em>, including a distinguished <em>start-state</em>
\(q_0\) and two distinguished <em>halt-states</em> \(q_Y\) and \(q_N\);</li>
<li>a <em>transition function</em>
\(\delta: (\mathcal{Q}\backslash\{q_Y, q_N\})\times\Gamma\rightarrow
\mathcal{Q}\times\Gamma\times\{-1, +1\}\).</li>
</ol>
<p><strong>Operation of a DTM program</strong></p>
<p>The input to the DTM is a string \(x\in\Sigma^*\).</p>
<p>All the tape squares initially contain the blank symbol \(b\).</p>
<p>The string \(x\) is placed in tape squares 1 through \(|x|\).</p>
<p>The program starts its operation in state \(q_0\), with the head scanning tape
square \(1\).</p>
<p>At each step:</p>
<ul>
<li>If the current state \(q\) is either \(q_Y\) or \(q_N\), then the
computation has ended, with the answer being &quot;\(yes\)&quot; if \(q=q_Y\)
or &quot;\(no\)&quot; if \(q=q_N\).</li>
<li>Else we have \(q\in \mathcal{Q}\backslash \{q_Y, q_N\}\) and there is a symbol
\(s\) in the tape square being scanned. The value of the <em>transition
function</em> can be computed:
\(\delta(q, s)=(q', s', \Delta)\). The <em>read write head</em> then replaces
the symbol \(s\) by \(s'\) in the current square, it then moves one square
right if \(\Delta=1\) or one square left if \(\Delta=-1\). The
<em>finite state control</em> updates the state value from \(q\) to \(q'\).</li>
</ul>
<p><strong>Definition</strong></p>
<p>We say that a DTM program \(M\) with input alphabet \(\Sigma\) <em>accepts</em>
\(x\in\Sigma^*\) if and only if \(M\) halts in state \(q_Y\) when applied
to input \(x\).</p>
<p><strong>Definition</strong>
: The language \(L_M\) recognized by the program \(M\) is given by
\(L_M = \{x\in\Sigma^*: M \ accepts\ x\}\).</p>
<p>If \(x\in(\Sigma^*\backslash L_M)\) then either the computation of \(M\) on
\(x\) halts in state \(q_N\) or it does not halt <em>ie: continues forever</em>.</p>
<p><strong>Definition</strong></p>
<p>We say that a DTM program \(M\) <em>solves</em> the decision problem \(\Pi\) under
encoding scheme \(e\) if \(M\) halts for all input strings over its input
alphabet and \(L_M = L[\Pi, e]\).</p>
<p><strong>Example</strong>: Integer Divisibility by four.</p>
<p>Instance: A positive integer \(N\).</p>
<p>Question: Is there a positive integer \(m\) such that \(N=4m\)?</p>
<p>Using the standard encoding scheme, the integer \(N\) is represented by the
string of  \(0\)'s and \(1\)'s that is its binary representation.</p>
<p>\[
\Gamma=\{0, 1, b\}, \Sigma=\{0, 1\} \\
\mathcal{Q}=\{q_0, q_1, q_2, q_3, q_Y, q_N\} \\
\delta(q_0, 0)=(q_0, 0, +1), \
\delta(q_0, 1)=(q_0, 1, +1)\\
\delta(q_0, b)=(q_1, b, -1), \
\delta(q_1, 0)=(q_2, b, -1)\\
\delta(q_1, 1)=(q_3, b, -1), \
\delta(q_1, b)=(q_N, b, -1)\\
\delta(q_2, 0)=(q_Y, b, -1), \
\delta(q_2, 1)=(q_N, b, -1)\\
\delta(q_2, b)=(q_N, b, -1), \
\delta(q_3, 0)=(q_N, b, -1)\\
\delta(q_3, 1)=(q_N, b, -1), \
\delta(q_3, b)=(q_N, b, -1)\\
M=(\Gamma, \mathcal{Q}, \delta).
\]</p>
<p>Here as example of the execution of this program on the string
\(x=10100\).</p>
<p><img src="media/dtmM.png" alt="dtm execution diagram" /></p>
<p>The language \(L_M\) recognized by the program \(M\) is given by
\(L_M = \{x\in\Sigma^*: M\ accepts \ x\}\).</p>
<p>It can be shown that \(L_M\) is exactly the language</p>
<p>\[
\{x\in\{0, 1\}^*: the \ rightmost \ two \ symbols \ of \ x
\ are \ both \ 0 \}.
\]</p>
<p>Since an integer \(N\) is divisible by \(4\) if and only if the last two
digits of its binary representation are \(0\), the DTM program \(M\) solves
the INTEGER DIVISIBILITY BY FOUR problem.</p>
<p><strong>Remark</strong>: A DTM program can compute functions.
Suppose \(M\) is a DTM with input alphabet \(\Sigma\) and tape alphabet
\(\Gamma\) that halts for all input strings from \(\Sigma^*\).
Then \(M\) computes the function \(f_M : \Sigma^* \rightarrow \Gamma^*\)
where for each \(x \in \Sigma^*\), \(f_M(x)\) is defined to be the
contiguous string obtained by running \(M\) on input \(x\) until it
halts; from tape position 1 up to but not including the first blank symbol.</p>
<p>The <strong>time</strong> used in the computation of a DTM program \(M\) on an input \(x\)
is the number of steps occuring in that computation up until the first
halt state is entered.</p>
<p><strong>Definition</strong>
For a DTM program \(M\) that halts on all inputs \(x\in\Sigma^*\), its
<em>time complexity function</em> \(T_M: \mathbb{Z}^+\rightarrow\mathbb{Z}^+\)
is given by:</p>
<p>\[
T_M(n) = max \{m: there \ is \ a \ string \ x\in\Sigma^* of \ length
\\ \
n \ on \ which \ the \ computation \ of \ M \ takes \ time \ m \}
\]</p>
<p><strong>Remark</strong> \(M\) is a <em>polynomial time DTM program</em> if there exists a
polynomial \(p\) such that \(\forall n \in \mathbb{N} : T_M(n)\leq p(n)\).</p>
<p><strong>Definition</strong></p>
<p>\[
P = \{L: there \ exists \ a \ polynomial \ time \ DTM \ program \\
\ M \ for \ which \ L=L_M\}.
\]</p>
<p>We say that a decision problem \(\Pi\) belongs to \(P\) under the encoding scheme \(e\) if \(L[\Pi, e]\in P\), <em>ie</em> there is a polynomial time DTM
program that solves \(\Pi\) under the encoding \(e\).</p>
<p>If a decision problem \(\Pi\in P\) then its complementary problem is
also in \(P\), this is not necessarily the case for a problem in \(NP\).</p>
<a class="header" href="print.html#nondeterminstic-computation-and-the-class-np" id="nondeterminstic-computation-and-the-class-np"><h2>Nondeterminstic Computation and the class NP</h2></a>
<p>The class \(NP\) is intended to isolate the notion of polynomial time
&quot;verifiability&quot;, which does not imply polynomial time solvability.</p>
<p>A <strong>nondeterministic algorithm</strong> is composed of two separate stages, the first
being a <em>guessing stage</em> and the second a <em>checking stage</em>.
Given a problem instance \(I\), the first stage <em>guesses</em> a structure \(S\).
\(I\) and \(S\) are then passed as inputs to the checking stage, which
performs deterministic computations to verify if the structure \(S\)
proves that the answer to \(I\) is &quot;yes&quot;.</p>
<p>A nondeterministic algorithm <em>solves</em> a decision problem \(\Pi\) iff :</p>
<ol>
<li>If \(I\in Y_{\Pi}\), then there exists some structure \(S\) that, when
guessed for input \(I\), will lead the checking stage to respond &quot;yes&quot; for
\(I\) and \(S\).</li>
<li>If \(I\notin Y_{\Pi}\), then there exists some structure \(S\) that, when
guessed for input \(I\), will lead the checking stage to respond &quot;yes&quot; for
\(I\) and \(S\).</li>
</ol>
<p><strong>Definitions</strong></p>
<p>A <strong>NonDeterministic one-tape Turing Machine</strong> (NDTM)
is a computation model composed of a <em>finite state control</em>, a <em>read-write head</em>
, a two-way infinite <em>tape</em> of squares labeled (\(..., -2, -1, 0, 1, 2, ...\))
and a <em>guessing module</em> having a <em>write-only head</em>.</p>
<p><img src="https://i.stack.imgur.com/lqJWu.png" alt="img" /></p>
<p>An <strong>NDTM program</strong> is specified in exactly the same way as \(DTM\) program.
This includes the tape alphabet \(\Gamma\), input alphabet \(\Sigma\),
blank symbol \(b\), state set \(\mathcal{Q}\), initial state \(q_0\), halt
states \(q_Y\) and \(q_N\) and transition function
\(\delta: (\mathcal{Q} \backslash \{q_Y, q_N\})\times\Gamma
\rightarrow \mathcal{Q}\times\Gamma\times\{-1, +1\}\)</p>
<p>The <strong>computation of an NDTM</strong> on an input string \(x\in\Sigma^*\) differs from
that of a DTM in that it takes place in two distinct stages:</p>
<ul>
<li>the <em>guessing stage</em>:
<ul>
<li>the input string \(x\) is written in tapes \(1\) through \(|x|\).
All other squares contain the blank character.</li>
<li>the read-write head is scanning square \(1\), while the write-only head is
scanning square \(-1\), the finite state control is inactive.</li>
<li>the guessing module then directs the write-only head, one step at a
time, either to write some symbol from \(\Gamma\) in te tape square being
scanned and move one square to the left, or to stop, at which point the
guessing module becomes inactive.</li>
</ul>
</li>
</ul>
<p>The finite state control is then activated in state \(q_0\).</p>
<ul>
<li>the <em>checking stage</em>:
<ul>
<li>the guessing module and its write-only head are no longer involved, having
fulfilled their role by guessing a string on the tape.</li>
<li>the computation proceeds solely under the direction of the NDTM program
according to exactly the same rules as for a DTM.</li>
<li>the guessed string can (and usually will) be examined during this stage.</li>
<li>The computation ceases when and if the finite state control enters one of
the two halting states and is said to be an <em>accepting computation</em> if it
halts in state \(q_Y\). All other computations, halting or not are
classified as <em>non-accepting computations</em>.</li>
</ul>
</li>
</ul>
<p>The choice of whether to remain active, and, if so, which symbol to write, is
made by the guessing module in a totally arbitrary manner. An important
consequence is that the guessing module can write any string from
\(\Gamma^*\) before it halts (if it ever does).</p>
<p><strong>Properties</strong></p>
<p>An NDTM program \(M\) has an infinite number of possible computations for a
given input string \(x\), one for each possible guessed string from
\(\Gamma^*\).</p>
<p>An NDTM program \(M\) accepts \(x\) if at least one of these is an accepting
computation.</p>
<p>The language recongnized by \(M\) is
\[L_M = \{x\in\Sigma^* : M \ accepts \ x\}\]</p>
<p>The <em>time</em> required by an NDTM program \(M\) to accept the string
\(x\in L_M\) is the minimum, over all accepting computations of \(M\) for
\(x\) of the number of steps ocurring in the guessing and checking stages up
until the halt state \(q_Y\) is entered.</p>
<p>The <em>time complexity function</em> \(T_M: \mathbb{Z}^+\rightarrow\mathbb{Z}^+\)
for \(M\) is
\[
T_M(n) = max (\{1\}\cup\{m: \exists x\in\Sigma^* with \ |x|=n \ \
s.t. \ the \ time \ to \ accept \ x \ by \ M \ is \ m
\})
\]</p>
<p>The time complexity function for \(M\) depends only on the number of steps
occurring in <em>accepting computations</em>. By convention, \(T_M(n)\) is \(1\)
for whenever no inputs of length \(n\) are accepted by \(M\).</p>
<p>The NDTM program \(M\) is a <em>polynomial time NDTM program</em> if there exists a
polynomial \(p\) such that \(\forall n\geq 1: \ T_M(n)\leq p(n) \).</p>
<p><strong>Definition</strong>
\[
NP = \{L: there \ is \ a \ polynomial \ time \ NDTM \ program
\ M \ for \ which \ L_M=L\}
\]</p>
<p>A decision problem \(\Pi\) will be said to belong to \(NP\) under encoding
scheme \(e\) if the language \(L[\Pi, e]\in NP\)</p>
<p><strong>Heuristic</strong> We identify \(NP\) with the class of all decision problems
&quot;solvable&quot; by polynomial time nondeterministic algorithms.</p>
<a class="header" href="print.html#the-relationship-between-p-and-np" id="the-relationship-between-p-and-np"><h2>The Relationship between P and NP</h2></a>
<a class="header" href="print.html#proving-np-complete-results" id="proving-np-complete-results"><h1>Proving NP-Complete Results</h1></a>
<a class="header" href="print.html#ocaml-functional-programming" id="ocaml-functional-programming"><h1>Ocaml Functional Programming</h1></a>
<a class="header" href="print.html#ninety-nine-problems-in-ocaml" id="ninety-nine-problems-in-ocaml"><h1>Ninety-Nine Problems in Ocaml</h1></a>
<p><strong>Exercise 1: Tail of a List</strong></p>
<p>Write a function that returns the last element of a list.</p>
<pre><code class="language-ocaml">last : 'a list -&gt; 'a option 
</code></pre>
<p><details open>
<summary>Show Solution</summary></p>
<pre><code class="language-ocaml"> let rec last (l: 'a list): 'a option = 
   match l with
   | [] -&gt; None
   | [e] -&gt; Some e
   | _::tail -&gt; last tail
</code></pre>
<p><strong>Explanation</strong></p>
<p>Here we are defining a recursive function in OCaml.</p>
<p>Notice the optional type hints. The function takes a (homogenous) list <code>l</code>
of a generic type <code>'a</code> (<code>'SOMETHING</code> is OCaml syntax for generic types).</p>
<p>If the list is empty, we return None, there is no last element.</p>
<p>If the list contains a single element <code>e</code>, return <code>Some e</code>.</p>
<p>Otherwise, discard the first element <code>_</code> and call last on the rest of the list.</p>
<p><code>'a option</code> is OCaml's solution to the billion dollar
mistake of the <code>NullPointerException</code>. All values in OCaml are non-null.</p>
<p>The option type allows us to deal with a case where a &quot;null&quot; value would be
useful.</p>
<pre><code class="language-ocaml">type 'a option = 
| Some 'a
| None
</code></pre>
<p>The compiler will force you to handle <code>None</code> values in option types.</p>
<p>The <code>e::l</code> operation appends element <code>e</code> to the beginning of the list <code>l</code>.</p>
<p>The <code>match</code> allows us to perform different action based on the form of the list
<code>l</code>. It is basically an switch statement on steroids that allows us to
deconstruct a value of any type into its possible forms.</p>
<p>The compiler will force you to handle all possible forms of the input type.</p>
<p></details></p>
<p><strong>Exercise 2: Last Two Elements of a List</strong></p>
<p>Find the last but one (last and penultimate) elements of a list.</p>
<pre><code class="language-ocaml">last_two : 'a list -&gt; ('a * 'a) option 
</code></pre>
<p><details open>
<summary>Show Solution</summary></p>
<pre><code class="language-ocaml"> let rec last_two (l: 'a list): ('a * 'a) option = 
   match l with
   | [] 
   | [_] -&gt; None
   | e1::e2::[] -&gt; Some (e1, e2)
   | _::rest -&gt; last_two rest
</code></pre>
<p><strong>Explanation</strong></p>
<p>Same idea, minor tweaks. We are returing a product type <em>ie:</em> tuple.</p>
<p>If the list contains exactly two elements <code>e1</code> and <code>e2</code>, return the tuple
<code>(e1, e2)</code> wrapped in <code>Some</code> (we HAVE to return an option type).</p>
<p>If the list contains 0 or 1 elements, return <code>None</code>, we can match both cases
with one arrow.</p>
<p>Otherwise if the list contains 3 or more elements, discard the first one
and call <code>last_two</code> on the rest of the list.</p>
<p></details></p>
<p><strong>Exercise 3: N'th Element of a List</strong></p>
<p>Find the N'th element of a list.</p>
<pre><code class="language-ocaml">nth: 'a list -&gt; int -&gt; 'a option
</code></pre>
<p><details open>
<summary>Show solution</summary></p>
<pre><code class="language-ocaml">let rec nth (lst: 'a list) (k: int): 'a option = 
  match (k, lst) with 
  | (_, []) -&gt; None
  | (0, x::_) -&gt; Some x
  | (k, _::rest) -&gt; nth rest (k-1)
</code></pre>
<p>This function still returns <code>None</code> for negative values.</p>
<p></details></p>
<p><strong>Exercise 4: Length of a List</strong></p>
<p>Find the number of elements of a list.</p>
<pre><code class="language-ocaml">length: 'a list -&gt; int
</code></pre>
<p><details open>
<summary>Show solution</summary></p>
<pre><code class="language-ocaml">let rec length (lst: 'a list): int = 
  match lst with
  | [] -&gt; 0
  | _::rest -&gt; 1 + length rest
</code></pre>
<p><strong>Explanation</strong></p>
<p>The length of an empty list is 0.</p>
<p>The length of a list having a first element
is one plus the length of the rest of the list.</p>
<p>Here is a tail recursive version.</p>
<pre><code class="language-ocaml">let rec length (lst: 'a list): int = 
  (* Define an inner auxiliary function *)
  let rec aux (lst: 'a list) (sofar: int): int = 
    match lst with
    | [] -&gt; sofar
    | _::rest -&gt; aux rest (sofar + 1)

  (* return this expression that uses the auxiliary function *)
  in aux lst 0
</code></pre>
<p></details></p>
<p><strong>Exercise 5: Reverse a List</strong></p>
<p>Reverse a List</p>
<pre><code class="language-ocaml">rev: 'a list -&gt; 'a list
</code></pre>
<p><details open>
<summary>Show solution</summary></p>
<pre><code class="language-ocaml">let rec rev (lst: 'a list): 'a list =
  let rec aux (reversed: 'a list) (remaining: 'a list): 'a list = 
    match (reversed, remaining) with
    | (reversed, []) -&gt; reversed
    | (reversed, x::tail) -&gt; aux (x::reversed) tail
  in aux [] lst
</code></pre>
<p></details></p>
<p><strong>Exercise 6: Duplicate the Elements of a List</strong></p>
<p>Duplicate the Elements of a List.</p>
<pre><code class="language-ocaml">dupl: 'a list -&gt; 'a list
</code></pre>
<p><details open>
<summary>Show solution</summary></p>
<pre><code class="language-ocaml">let rec dupl (lst: 'a list): 'a list = 
  match lst with 
  | [] -&gt; []
  | x::rest -&gt; x::x::(dupl rest)
</code></pre>
<p></details></p>
<p><strong>Exercise 7: Split a List Into Two Parts</strong></p>
<p>Split a list into two parts; the length of the first part is given.</p>
<p>If the length of the first part is longer than the entire list,
then the first part is the list and the second part is empty.</p>
<pre><code class="language-ocaml">split: 'a list -&gt; int -&gt; 'a list * 'a list 
</code></pre>
<p><details open>
<summary>Show solution</summary></p>
<pre><code class="language-ocaml">let split (l: 'a list) (n: int): 'a list * 'a list = 
      let rec aux (f: 'a list) (l: 'a list) (r: int) : 'a list * 'a list = 
        match (r, l) with 
        | (0, l) 
        | (k, []) -&gt; (List.rev f, l)
        | (k, x::rest) -&gt; aux (x::f) (rest) (k-1)
      in aux [] l n
</code></pre>
<p></details></p>
<p><strong>Exercise n: ptitle</strong></p>
<p>pdescription</p>
<pre><code class="language-ocaml">psig
</code></pre>
<p><details open>
<summary>Show solution</summary></p>
<pre><code class="language-ocaml">   (* solution *)
</code></pre>
<p><strong>Explanation</strong></p>
<p>pexpl</p>
<p></details></p>
<a class="header" href="print.html#lambda-calculus" id="lambda-calculus"><h1>Lambda Calculus</h1></a>
<a class="header" href="print.html#maths-de-1er-cycle" id="maths-de-1er-cycle"><h1>Maths de 1er cycle</h1></a>
<a class="header" href="print.html#logique" id="logique"><h1>Logique</h1></a>
<a class="header" href="print.html#suites" id="suites"><h1>Suites</h1></a>
<a class="header" href="print.html#fonctions" id="fonctions"><h1>Fonctions</h1></a>
<a class="header" href="print.html#continuite" id="continuite"><h1>Continuite</h1></a>
<a class="header" href="print.html#derivation" id="derivation"><h1>Derivation</h1></a>
<a class="header" href="print.html#series" id="series"><h1>Series</h1></a>
<a class="header" href="print.html#arithmetique" id="arithmetique"><h1>Arithmetique</h1></a>
<a class="header" href="print.html#groupes" id="groupes"><h1>Groupes</h1></a>
<a class="header" href="print.html#anneaux" id="anneaux"><h1>Anneaux</h1></a>
<a class="header" href="print.html#corps" id="corps"><h1>Corps</h1></a>
<a class="header" href="print.html#actions-de-groupe" id="actions-de-groupe"><h1>Actions de Groupe</h1></a>
<a class="header" href="print.html#algebre-lineaire" id="algebre-lineaire"><h1>Algebre Lineaire</h1></a>
<a class="header" href="print.html#reduction-des-endomorphismes" id="reduction-des-endomorphismes"><h1>Reduction des Endomorphismes</h1></a>
<!-- <details> -->
<!-- <summary>**Cours**</summary> -->
<p>Soit \(\mathbb{K}\) un corps.</p>
<p>Soit \(E\) un \(\mathbb{K}\)-espace vectoriel.</p>
<p>Soit \(u: E \rightarrow E\) un endomorphisme de \(E\).</p>
<hr />
<p><strong>Definition 1</strong></p>
<p>Un sous-espace vectoriel \(F\) de \(E\) est dit stable par \(u\) si
\(u(F)\subset F\).</p>
<hr />
<hr />
<p><strong>Proposition 1</strong></p>
<p>Si les endomorphismes \(u\) et \(v\) de \(E\) commutent,
<em>c'est a dire si</em> \(u\circ v = v\circ u\)
, alors \(Ker(v)\) et \(Im(v)\) sont stables par \(u\).</p>
<hr />
<hr />
<p><strong>Proposition 2</strong></p>
<p>Si \(F\) est un sous-espace vectoriel de \(E\)
engendré par une famille \((e_i)_{i \in I}\),
alors \(F\) est stable par \(u\) ssi:
\[\forall i \in I\quad u(e_i) \in F.\]</p>
<hr />
<hr />
<p><strong>Corollaire 3: traduction matricielle de la stabilité</strong></p>
<p>Soit \(F\) un sous-espace vectoriel de \(E\) de dimension \(p\) et
\(\mathcal{B}=(e_1, ..., e_n)\)
une base de E adaptée a \(F\), c'est a dire telle que
\(\mathcal{B}' = (e_1, ..., e_p)\) soit une
base de \(F\).</p>
<p>Alors \(F\) est stable par \(u\) ssi sa matrice dans la base
\(\mathcal{B}\) est de la forme
\(\begin{pmatrix}A &amp; C\\0 &amp; B\end{pmatrix}\),
avec \(A\in \mathcal{M}_p(\mathbb{K})\).</p>
<p>Dans ce cas, \(A\) est la matrice dans la base
\(\mathcal{B}'\) de l'endomorphisme induit \(u_F\).</p>
<hr />
<hr />
<p><strong>Definition 3</strong></p>
<ol>
<li>On dit que \(\lambda \in \mathbb{K}\) est <strong>valeur propre</strong>
de \(u\) s'il existe un vecteur non nul \(x \in E\) tel que
\(u(x) = \lambda x\), c'est a dire si l'endomorphisme
\(u - \lambda Id_E\) est non injectif.</li>
<li>On dit que \(x \in E\) est <strong>vecteur propre</strong>
de \(u\) associee a la valeur propre \(\lambda\in\mathbb{K}\)
s'il est non nul et vérifie \(u(x)=\lambda x\).</li>
<li>Si \(\lambda \in \mathbb{K}\) est valeur propre de \(u\),
le <strong>sous-espace propre</strong> de \(u\) associé a la valeur propre \(\lambda\)
est: \[E_\lambda (u)=Ker(u-\lambda Id_E)=
\{x\in E : u(x)=\lambda x\}.\]</li>
</ol>
<hr />
<hr />
<p><strong>Definition 4</strong></p>
<p>Le spectre d'un endomorphisme d'un espace de dimension finie
est l'ensemble de ses valeurs propres.</p>
<hr />
<hr />
<p><strong>Proposition 5</strong></p>
<p>Si les endomorphismes \(u\) et \(v\) commutent,
c'est a dire si \(u\circ v = v\circ u\), alors les sous-espaces propres
de l'un sont stables par l'autre.</p>
<hr />
<hr />
<p><strong>Proposition 6</strong></p>
<ul>
<li>Si \(\lambda_1, ..., \lambda_p\) sont des valeurs propres deux a deux
deux distinctes de \(u\), alors les sous-espaces propres associés
\(E_{\lambda_1}(u), ..., E_{\lambda_p}(u)\) sont en somme directe.</li>
<li>Toute famille de vecteurs propres associés a des valeurs propres deux a deux
distinctes est libre.</li>
</ul>
<hr />
<hr />
<p><strong>Corollaire 7</strong></p>
<p>Si \(E\) est de dimension finie et si \(\lambda_1, ..., \lambda_p\) sont
des valeurs propres deux a deux distinctes de \(u\), alors:
\[
\sum_{i=1}^{p}{dim(E_{\lambda_i} (u))} \leq dim(E)
\]</p>
<hr />
<hr />
<p><strong>Corollaire 8</strong></p>
<p>Un endomorphisme d'un espace vectoriel de dimension \(n\) a au plus \(n\)
valeurs propres distinctes.</p>
<hr />
<hr />
<p><strong>Proposition 9</strong></p>
<p>Si \(F\) est un sous-espace vectoriel de \(E\) stable par \(u\),
les valeurs propres de l'endomorphisme \(u_F\) induit par \(u\) sur \(F\)
sont les valeurs propres \(\lambda\) telles que
\(E_\lambda(u)\cap F \neq \{0\}\). On a alors:
\[E_\lambda(u_F) = E_\lambda(u)\cap F.\]</p>
<hr />
<hr />
<p><strong>Proposition 10</strong></p>
<p>Si \(f\) est un endomorphisme de \(E\) et si \(\mathcal{B}\) et
\(\mathcal{B}'\) sont deux bases de \(E\), alors les matrices \(M\) et
\(M'\) de \(f\) respectivement dans les bases \(\mathcal{B}\) et
\(\mathcal{B}'\) sont reliés par: \[M' = P^{-1}MP,\]
ou \(P\) est la matrice de passage de \(\mathcal{B}\) a \(\mathcal{B}'\).</p>
<hr />
<hr />
<p><strong>Definition 5</strong></p>
<p>Deux matrices \(A\) et \(B\) sont semblables s'il existe
\(P\in GL_n(\mathbb{K})\) telle que \(B=P^{-1}AP\).</p>
<hr />
<hr />
<p><strong>Proposition 11</strong></p>
<p>Deux matrices
\(M\) et \(M'\)
de \(\mathcal{M}_n (\mathbb{K})\) sont
semblables ssi elles representent le meme endomorphisme de
\(\mathbb{K}^n\),
c'est a dire s'il existe \(\mathcal{B}\) et \(\mathcal{B}'\) deux
bases de \(\mathbb{K}^n\) et \(f\in \mathcal{L}(\mathbb{K}^n)\) telles que:</p>
<p>\[
M=Mat_{\mathcal{B}}(f) \quad et \quad M'=Mat_{\mathcal{B}'}(f).
\]</p>
<hr />
<hr />
<p><strong>Proposition 12</strong></p>
<p>Deux matrices semblables ont meme trace et meme determinant.</p>
<hr />
<hr />
<p><strong>Definition 6</strong></p>
<p>Soit \(A\in \mathcal{M}_n(\mathbb{K})\)</p>
<ol>
<li>On dit que \(\lambda\in\mathbb{K}\) est valeur propre de \(A\) s'il
existe une matrice colonne \(X\in\mathcal{M}_{n,1}(\mathbb{K})\)
<em>non nulle</em> telle que \(AX=\lambda X\).</li>
<li>On dit que la matrice colonne \(X\in \mathcal{M}_{n,1}(\mathbb{K})\) est
vecteur propre de \(A\) associée a la valeur propre
\(\lambda\in\mathbb{K}\) si elle est non nulle et vérifie \(AX=\lambda X\).</li>
<li>Si \(\lambda\in\mathbb{K}\) est valeur propre de \(A\), le sous-espace
propre de \(A\) associée a la valeur propre \(\lambda\) est:
\[E_\lambda (A)=Ker(A-\lambda I_n)=
\{X\in \mathcal{M}_{n,1}(\mathbb{K}): AX=\lambda X\}.\]</li>
<li>L'ensemble des valeurs propres de \(A\) est appelé le <strong>spectre</strong> de \(A\)
et noté \(sp(A)\).</li>
</ol>
<hr />
<hr />
<p><strong>Proposition 13</strong></p>
<p>Soit \(A\) une matrice représentant l'endomorphisme \(u\) dans une base
\((e_1, ..., e_n)\). On a alors \(sp(A)=sp(u)\) et, pour tout
\(\lambda\in sp(u)\):
\[
x = \sum_{i=1}^{n}{x_i e_i} \in E_\lambda (u) \iff X=
\begin{bmatrix}
x_1 \\
\vdots \\
x_n \\
\end{bmatrix}
\in E_\lambda (A).
\]</p>
<hr />
<hr />
<p><strong>Corollaire 14</strong></p>
<p>Deux matrices semblables ont meme spectre et les sous-espaces propres
associés sont de meme dimension.</p>
<hr />
<hr />
<p><strong>Proposition 15</strong></p>
<p>Soit \(\mathbb{K}'\) un sous-corps du corps \(\mathbb{K}\) et
\(A\in\mathcal{M}_n(\mathbb{K}')\). Alors</p>
<p>\[sp_{\mathbb{K}'}(A) \subseteq sp_{\mathbb{K}}(A)\]</p>
<hr />
<hr />
<p><strong>Proposition 16</strong></p>
<p>Soit \(A\in \mathcal{M}_n(\mathbb{R})\). Si \(\lambda\in sp_\mathbb{C}(A)\)
, alors \(\overline\lambda\) est valeur propre de \(A\) et:</p>
<p>\[
X\in E_\lambda (A) \iff \overline X \in E_{\overline\lambda}(A).
\]</p>
<p>Si \((X_1, ..., X_k)\) est une base de \( E_\lambda (A) \) alors
\((\overline X_1, ..., \overline X_k)\) est une base de
\( E_\overline\lambda (A) \) donc
\(dim(E_\lambda (A))=dim(E_\overline\lambda (A))\).</p>
<hr />
<hr />
<p><strong>Definition 7</strong></p>
<p>Soit \(u\in\mathcal{L}(E)\) et
\(P=\sum_{k=0}^{p}{a_k X^k} \in\mathbb{K}[X]\).</p>
<p>On note \(P(u)\) l'endomorphisme de \(E\) defini par:</p>
<p>\[
P(u) = \sum_{k=0}^{p}{a_k u^k} .
\]</p>
<p>Pour \(A\in \mathcal{M}_n (\mathbb{K})\), on definit de meme la matrice
\(P(A)\in\mathcal{M}_n (\mathbb{K})\) par:</p>
<p>\[
P(A) = \sum_{k=0}^{p}{a_k A^k} .
\]</p>
<hr />
<p><strong>Proposition 17</strong></p>
<p>Pour tout \((P, Q)\in\mathbb{K}[X]^2\), les endomorphismes \(P(u)\) et
\(Q(u)\) commutent. En particulier, pour tout \(P\in\mathbb{K}[X]\),
\(Im(u)\) et \(Ker(u)\) sont des sous-espaces stables par \(u\).</p>
<hr />
<p><strong>Proposition 18</strong></p>
<ol>
<li>Si \(x\in E_\lambda (u)\) et si \(P\in\mathbb{K}[X]\) alors
\(P(u)(x) = P(\lambda) x\).</li>
<li>En particulier, si \(\lambda\) est valeur propre de \(u\),
alors \(P(\lambda)\) est valeur propre de \(P(u)\) et tout vecteur propre
de \(u\) associé a la valeur propre \(\lambda\) est vecteur propre de
\(P(u)\) associé la valeur propre \(P(\lambda)\).</li>
</ol>
<hr />
<p><strong>Corollaire 19</strong></p>
<p>Soit \(A\in\mathcal{M}_n(\mathbb{K})\).</p>
<ol>
<li>Si \(X\in E_\lambda(A)\) et si \(P\in \mathbb{K}[X]\) alors
\(P(A)X=P(\lambda)X\).</li>
<li>En particulier, si \(\lambda\) est valeur propre de \(A\),
alors \(P(\lambda)\) est valeur propre de \(P(A)\) et tout vecteur propre
de \(A\) associé a la valeur propre \(\lambda\) est vecteur propre de
\(P(A)\) associé la valeur propre \(P(\lambda)\).</li>
</ol>
<hr />
<hr />
<p><strong>Definition 8</strong></p>
<p>On dit que \(P\in\mathbb{K}[X]\) est un polynome annulateur de \(u\), s'il
vérifie \(P(u)=0\).</p>
<p>On dit que \(P\in\mathbb{K}[X]\) est un polynome annulateur de \(A\), s'il
vérifie \(P(A)=0\).</p>
<hr />
<hr />
<p><strong>Proposition 20</strong></p>
<p>Si \(P\) est un polynome annulateur de \(u\in\mathcal{L}(E)\), alors
toute valeur propre de \(u\) est racine de \(P\).</p>
<hr />
<hr />
<p><strong>Corollaire 21</strong></p>
<p>Si \(P\) est un polynome annulateur de \(A\in\mathcal{M}_n(\mathbb{K})\),
alors toute valeur propre de \(A\) est racine de \(P\).</p>
<hr />
<hr />
<p><strong>Corollaire 22</strong></p>
<p>Si \(P\) est un polynome annulateur de \(u\) tel que \(P(0)\neq 0\) et si
\(E\) est de dimension finie, alors \(u\) est bijectif.</p>
<hr />
<hr />
<p><strong>Corollaire 23</strong></p>
<p>Si \(P\) est un polynome annulateur de \(A\) et si \(P(0)\neq 0\), alors
\(A\) est inversible.</p>
<hr />
<hr />
<p><strong>Definition 9</strong></p>
<p>Soit \(A\in\mathcal{M}_n(\mathbb{K})\). On appelle polynome caracteristique de
\(A\) et on note \(\chi_A(X)\) l'unique polynome tel que:</p>
<p>\[
\forall \lambda \in \mathbb{C} \quad \chi_A(\lambda) = det(\lambda I_n - A).
\]</p>
<p>On note alors \(\chi_A(X)=det(XI_n-A)\).</p>
<hr />
<hr />
<p><strong>Theoreme 24</strong></p>
<p>\(\lambda\in\mathbb{K}\) est valeur propre de \(A\) si et seulement s'il est
racine du polynome caracteristique de \(A\).</p>
<hr />
<hr />
<p><strong>Proposition 25</strong></p>
<p>Si \(A\in\mathcal{M}_n(\mathbb{K})\) est triangulaire de diagonale
\((\alpha_1, ..., \alpha_n)\), alors son polynome caracteristique est:
\(\prod_{k=1}^{n}{(X-\alpha_k)}\) et \(sp(A)=\{\alpha_1,...,\alpha_n\}\).</p>
<hr />
<hr />
<p><strong>Corollaire 26</strong></p>
<p>Soit \(A\in\mathcal{M}_n(\mathbb{k})\).</p>
<ul>
<li>Si \(\mathbb{K}=\mathbb{C}\), alors \(A\) a au moins une valeur propre.</li>
<li>Si \(\mathbb{K}=\mathbb{R}\) et si \(n\) est impair, alors \(A\)
a au moins une valeur propre.</li>
</ul>
<hr />
<hr />
<p><strong>Proposition 27</strong></p>
<p>Soit \(A\in\mathcal{M}_n(K)\). Son polynome caracteristique \(\chi_A\) est
un polynome unitaire de degré \(n\) et l'on a :</p>
<p>\[
\chi_A(X) = X^n - (Tr(A))X^{n-1} + ... + (-1)^ndet(A).
\]</p>
<hr />
<hr />
<p><strong>Lemme 28</strong></p>
<p>Deux matrices semblables ont meme polynome caracteristique.</p>
<hr />
<hr />
<p><strong>Définition 10</strong></p>
<p>On appelle polynome caractéristique de l'endomorphisme \(u\) et l'on note
\(\chi_u\), le polynome caractéristique de toute matrice représentant \(u\).</p>
<p>On a donc, pour tout scalaire \(\lambda\),
\(\chi_u(\lambda)=det(\lambda Id_E - u)\).</p>
<hr />
<hr />
<p><strong>Proposition 29</strong></p>
<p>Le polynome caracteristique \(\chi_u\) est unitaire de degré \(n\) et l'on a :</p>
<p>\[
\chi_u(X) = X^n - (Tr(u))X^{n-1} + ... + (-1)^ndet(u).
\]</p>
<hr />
<hr />
<p><strong>Theoreme 30</strong></p>
<p>\(\lambda\in\mathbb{K}\) est valeur propre de \(u\) si et seulement s'il est
racine du polynome caracteristique de \(u\).</p>
<hr />
<hr />
<p><strong>Corollaire 31</strong></p>
<ul>
<li>Si \(\mathbb{K}=\mathbb{C}\), alors \(u\) a au moins une valeur propre.</li>
<li>Si \(\mathbb{K}=\mathbb{R}\) et si \(n\) est impair, alors \(u\)
a au moins une valeur propre.</li>
</ul>
<hr />
<hr />
<p><strong>Proposition 32</strong></p>
<p>Si \(F\) est un sous-espace vectoriel de \(E\) stable par \(u\), alors
le polynome caracteristique \(\chi_{u_F}\) de l'endomorphisme induit par
\(u\) sur \(F\) divise \(\chi_u\).</p>
<hr />
<hr />
<p><strong>Proposition 33</strong></p>
<p>Si le polynome caracteristique de \(u\) est scindé (respectivement scindé a
racines simples), alors celui de l'endomorphisme induit par \(u\) sur tout
sous-espace vectoriel de \(E\) stable par \(u\) l'est aussi.</p>
<hr />
<hr />
<p><strong>Definition 11</strong></p>
<p>On appelle ordre de multiplicité d'une valeur propre \(\lambda\) de \(u\)
(respectivement de \(A\)), son ordre de multiplicité en tant que racine du
polynome caractéristique de \(u\) (respectivement de \(A\)). On le note
\(m(\lambda)\).</p>
<hr />
<hr />
<p><strong>Proposition 34</strong></p>
<p>Pour tout \(\lambda \in sp(u)\), on a:</p>
<p>\[
1 \leq dim(E_\lambda(u)) \leq m(\lambda).
\]</p>
<hr />
<!-- </details> --><a class="header" href="print.html#suites-de-fonctions" id="suites-de-fonctions"><h1>Suites de Fonctions</h1></a>
<a class="header" href="print.html#series-de-fonctions" id="series-de-fonctions"><h1>Series de Fonctions</h1></a>
<a class="header" href="print.html#topologie" id="topologie"><h1>Topologie</h1></a>
<a class="header" href="print.html#integration" id="integration"><h1>Integration</h1></a>
<a class="header" href="print.html#calcul-differentiel" id="calcul-differentiel"><h1>Calcul Differentiel</h1></a>
<a class="header" href="print.html#probabilites-discretes-et-continues" id="probabilites-discretes-et-continues"><h1>Probabilites Discretes et Continues</h1></a>
<a class="header" href="print.html#statistiques" id="statistiques"><h1>Statistiques</h1></a>
<a class="header" href="print.html#equations-differentielles" id="equations-differentielles"><h1>Equations Differentielles</h1></a>
<a class="header" href="print.html#decompositions-de-matrices" id="decompositions-de-matrices"><h1>Decompositions de Matrices</h1></a>
<a class="header" href="print.html#analyse-hilbertienne" id="analyse-hilbertienne"><h1>Analyse Hilbertienne</h1></a>
<a class="header" href="print.html#bases-hilbertiennes" id="bases-hilbertiennes"><h2>Bases Hilbertiennes</h2></a>
<p><strong>Defintion 9</strong></p>
<p>Soit \(H\) un espace de Hilbert. Une famille \((u_i)_{i\in I}\in H^I\) est:</p>
<ul>
<li><em>Orthonormée</em> si
\( \forall i, j\in I \ : \ \langle u_i, u_j \rangle =\delta_{i, j} \).</li>
<li><em>Totale</em> si
\( H = \overline{Vect(u_i)_{i\in I}} \).</li>
<li>Une <em>base hilbetienne</em> de \(H\) si elle est à la fois totale et orthonormée.</li>
</ul>
<p><strong>Proposition 9</strong> Inégalité de Bessel</p>
<p>Soient \(H\) un espace de Hilbert et \((u_n)_{n\in\mathbb{N}}\) une famille
orthonormée. Pour tout \(f\in H\),</p>
<p>\[
\sum_{n=0}^{+\infty}{|\langle f, u_n \rangle|^2} \leq ||f||^2.
\]</p>
<p><strong>Rappel</strong> Séries à termes orthogonaux</p>
<p>Soient \((E, || \cdot ||)\) un \( \mathbb{K} \)-espace vectoriel normé et
\( (x_n)_{n \in \mathbb{N} } \in E^{ \mathbb{N} } \). On pose
\( s_n = \sum_{k=0}^{n} {x_k} \).</p>
<ul>
<li>La série \(\sum_{n\geq 0}{x_n}\) est dite convergente si la suite
\((s_n)_{n\in\mathbb{N}}\) converge dans \((E, ||\cdot||)\). La limite
\(lim_{n\rightarrow\infty}\)</li>
</ul>
<a class="header" href="print.html#about" id="about"><h1>About</h1></a>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        
    <script type="text/javascript">
        var socket = new WebSocket("ws://localhost:3001");
        socket.onmessage = function (event) {
            if (event.data === "reload") {
                socket.close();
                location.reload(true); // force reload from server (not from cache)
            }
        };

        window.onbeforeunload = function() {
            socket.close();
        }
    </script>


        

        

        
        <script>
            $(document).ready(function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        
        <script type="text/javascript" src="highlightjs-line-numbers.js"></script>
        

    </body>
</html>
