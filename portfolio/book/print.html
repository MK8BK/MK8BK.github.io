<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>The Guides</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        
        <!-- MathJax -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="intro.html"><strong>1.</strong> Introduction</a></li><li><a href="chapters/linux/intro.html"><strong>2.</strong> Linux Command Line</a></li><li><ul class="section"><li><a href="chapters/linux/vim.html"><strong>2.1.</strong> vim &amp; neovim</a></li><li><a href="chapters/linux/bash.html"><strong>2.2.</strong> scripting</a></li><li><a href="chapters/linux/utils.html"><strong>2.3.</strong> utilities</a></li></ul></li><li><a href="chapters/ccpp/intro.html"><strong>3.</strong> C/C++ Notes</a></li><li><ul class="section"><li><a href="chapters/ccpp/gcc.html"><strong>3.1.</strong> gcc</a></li><li><a href="chapters/ccpp/c.html"><strong>3.2.</strong> C</a></li><li><a href="chapters/ccpp/cpp.html"><strong>3.3.</strong> C++</a></li></ul></li><li><a href="chapters/algs/intro.html"><strong>4.</strong> Algorithms &amp; Data Structures</a></li><li><ul class="section"><li><a href="chapters/algs/lds.html"><strong>4.1.</strong> Linear Data Structures</a></li><li><a href="chapters/algs/sorting.html"><strong>4.2.</strong> Sorting</a></li><li><a href="chapters/algs/searching.html"><strong>4.3.</strong> Searching</a></li><li><a href="chapters/algs/trees.html"><strong>4.4.</strong> Trees</a></li><li><a href="chapters/algs/graphs.html"><strong>4.5.</strong> Graphs</a></li><li><a href="chapters/algs/dnc.html"><strong>4.6.</strong> Divide &amp; Conquer</a></li><li><a href="chapters/algs/greedy.html"><strong>4.7.</strong> Greedy Algorithms</a></li><li><a href="chapters/algs/dynprog.html"><strong>4.8.</strong> Dynamic Programming</a></li><li><a href="chapters/algs/algs_graphs.html"><strong>4.9.</strong> Graph Algorithms</a></li><li><a href="chapters/algs/linprog.html"><strong>4.10.</strong> Linear Programming</a></li><li><a href="chapters/algs/algs_string.html"><strong>4.11.</strong> String Algorithms</a></li></ul></li><li><a href="chapters/leetcode/main.html"><strong>5.</strong> LeetCode Catalog</a></li><li><a href="chapters/theorynpcomp/intro.html"><strong>6.</strong> Theory of NP-Completeness</a></li><li><ul class="section"><li><a href="chapters/theorynpcomp/theorynpcomp.html"><strong>6.1.</strong> The Theory of NP-Completeness</a></li><li><a href="chapters/theorynpcomp/proofnpcomp.html"><strong>6.2.</strong> Proving NP-Complete Results</a></li></ul></li><li><a href="chapters/ocaml/intro.html"><strong>7.</strong> OCaml Functional Programming</a></li><li><ul class="section"><li><a href="chapters/ocaml/n99exercises.html"><strong>7.1.</strong> 99 Excercises in OCaml</a></li><li><a href="chapters/ocaml/lambdacalc.html"><strong>7.2.</strong> Lambda Calcul</a></li></ul></li><li><a href="chapters/umath/intro.html"><strong>8.</strong> Maths de 1er cycle</a></li><li><ul class="section"><li><a href="chapters/umath/reduction.html"><strong>8.1.</strong> Reduction des Endomorphismes</a></li></ul></li><li><a href="chapters/about/whoami.html"><strong>9.</strong> About</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">The Guides</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#mk8bks-technical-guides" id="mk8bks-technical-guides"><h1>MK8BK's Technical Guides</h1></a>
<p>This website is a fusion of a portfolio, a knowledge base
and a blog.</p>
<a class="header" href="print.html#linux-command-line" id="linux-command-line"><h1>Linux Command Line</h1></a>
<p>A concise guide to tmux:
<a href="https://hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/">Tmux</a>.</p>
<a class="header" href="print.html#vim" id="vim"><h1>Vim</h1></a>
<p>operator number_of_repetitions motion</p>
<p><code>d3e</code></p>
<p>number_of_repetitions motion</p>
<p>3 j</p>
<p>Get rid of spell check in kickstart</p>
<pre><code class="language-bash">LspUninstall typos_lsp
</code></pre>
<a class="header" href="print.html#scripting" id="scripting"><h1>scripting</h1></a>
<a class="header" href="print.html#utilities" id="utilities"><h1>utilities</h1></a>
<p>See this quick <a href="https://hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/">tmux</a>
guide.</p>
<pre><code class="language-bash">clang-format &lt;file.cpp&gt; -i # format file in place
</code></pre>
<p>copy file to clipboard</p>
<pre><code class="language-bash">$ xclip -sel c &lt; input_file
</code></pre>
<a class="header" href="print.html#c-notes" id="c-notes"><h1>C++ Notes</h1></a>
<a class="header" href="print.html#gcc" id="gcc"><h1>gcc</h1></a>
<table><thead><tr><th> Extension </th><th> File Type </th></tr></thead><tbody>
<tr><td> .c </td><td> C source file </td></tr>
<tr><td> .cpp/.cc/.cxx </td><td> C++ source file </td></tr>
<tr><td> .o/.obj </td><td> Object file </td></tr>
<tr><td> .exe </td><td> Windows executable </td></tr>
<tr><td> <em>no extension</em> </td><td> Unix/Linux executable </td></tr>
<tr><td> .dll </td><td> Windows dynamic library </td></tr>
<tr><td> .lib </td><td> Windows static library </td></tr>
<tr><td> .so </td><td> Unix/Linux dynamic library </td></tr>
<tr><td> .a </td><td> Unix/Linux/MacOS static library </td></tr>
<tr><td> .dylib </td><td> MacOS dynamic library </td></tr>
</tbody></table>
<a class="header" href="print.html#c" id="c"><h2>C</h2></a>
<pre><code class="language-bash">gcc -c x.c # compile c source file into x.o object file
gcc -c x.c y.c # compile c source files into x.o and y.o object files
gcc -o executable x.o y.o # link object files x.o and y.o into a single executable file

# compile and link source files x.c and y.c into a single executable file
gcc -o executable x.c y.c # intermediate object files are discarded

# compile and link source files x.c and y.c into a single executable file
# looks up any undefined symbols during linking in library named **libsomething**.
gcc -o executable x.c y.c -lsomething # -lABC -&gt; search in libABC

# use the gcc preprocessor only
gcc -E in.c -o in.i

# see header file content
gcc -include stddef.h -E -dM - &lt;/dev/null | less

# check for memory leaks with valgring
valgrind --leak-check=yes ./program_name # if not in PATH and in working dir
</code></pre>
<a class="header" href="print.html#c-1" id="c-1"><h2>C++</h2></a>
<pre><code class="language-bash">g++ -c x.cpp # compile cpp source file into x.o object file
g++ -c x.cpp y.cpp # compile cpp source files into x.o and y.o object files
g++ -o executable x.o y.o # link object files x.o and y.o into a single executable file
# compile and link source files x.cpp and y.cpp into a single executable file
g++ -o executable x.cpp y.cpp # intermediate object files are discarded

# compile and link source files x.cpp and y.cpp into a single executable file
# looks up any undefined symbols during linking in library named **libsomething**
g++ -o executable x.cpp y.cpp -lsomething # -lABC -&gt; search in libABC

# specify C++ standard -&gt; use -std=bruh flag
g++ -o prog main.cpp -std=c++2a # use c++ 20 with gcc, not fully implemented yet
</code></pre>
<p>debugging tip: undefined reference to smthg \(\rightarrow\) <code>-o ALL.o files</code></p>
<a class="header" href="print.html#c-2" id="c-2"><h1>C</h1></a>
<p>A <code>char</code> type is always encoded using 8 bits (single byte) \(\rightarrow\)
just an integer type with a fixed range.</p>
<p>An <code>int</code> type usually has the same size as the processor's registers.</p>
<p>\[8=taille(char)\leq taille(short)\leq taille(int) \leq taille(long)
\leq taille(long \ long)\]</p>
<p>Operations on integer types ALWAYS return integer types: 3/2 \(\rightarrow\) 1.</p>
<p>IEEE-764 floating point encodings (most frequently used):</p>
<table><thead><tr><th> type </th><th> # bits </th><th> # digits of precision </th></tr></thead><tbody>
<tr><td> float </td><td> 4 </td><td> 6 </td></tr>
<tr><td> double </td><td> 8 </td><td> 15 </td></tr>
<tr><td> long double </td><td> 10 </td><td> 18 </td></tr>
</tbody></table>
<p>If a literal contains a point or exponent (<code>e</code> or <code>E</code>), then it is a floating type.
Otherwise, it is an integer type.</p>
<p>To use a different number base (<em>ie: not decimal</em>), prefix with <code>0b</code> for binary,
<code>0x</code> for hexadecimal and <code>0</code> for octal.</p>
<p>In C: <code>'A'</code> is of type <code>int</code>, in C++: it is of type <code>char</code>.</p>
<pre><code class="language-c">printf(&quot;\a&quot;); // produces a sound
</code></pre>
<p>By default, <code>2.3</code> is of type <code>double</code>.</p>
<p>To specify a literals type, use a suffix (or a combination for unsigned types):</p>
<table><thead><tr><th> type </th><th> suffix </th></tr></thead><tbody>
<tr><td> char </td><td> <em>none</em> </td></tr>
<tr><td> short </td><td> <em>none</em> </td></tr>
<tr><td> int </td><td> <em>none</em> </td></tr>
<tr><td> long </td><td> L </td></tr>
<tr><td> long long </td><td> LL </td></tr>
<tr><td> float </td><td> F/f </td></tr>
<tr><td> double </td><td> <em>none</em> </td></tr>
<tr><td> long double </td><td> L </td></tr>
<tr><td> unsigned int </td><td> U/u </td></tr>
</tbody></table>
<p>Addresses and Pointers Nonsense:</p>
<pre><code class="language-c">char u; // a character
char *pu; // a pointer to a character
char *ppu; // a pointer to a pointer to a character

u = 2; // assign the value of the literal 2 to u
pu = &amp;u; // assign the address of u to pu
ppu = &amp;pu; // assign the address of pu to ppu

// pointer dereference, lines 13, 14 and 15 have the same effect
int a = 2;
int *pa = &amp;a;
int **ppa = &amp;pa;
a = 0; 
*pa = 0;
**ppa = 0;
</code></pre>
<p><code>The value of a pointer is an address.</code></p>
<p>Pointer to Function Example:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int f(int n){
    return n/2;
}

int main(){
    int (*fp)(int) = &amp;f;
    printf(&quot;%d\n&quot;, (*fp)(8));
    return 0;
}
</code></pre>
<p>Always initialize a pointer.</p>
<pre><code class="language-cpp">int *p1 = 0 // the only allowed int to pointer assignment!
int *p2 = NULL // same
p1 = nullptr; // preferable in std&gt;=C++11
</code></pre>
<p>Enumerated int constants:</p>
<pre><code class="language-c">enum {f, t}; // f: 0, t: 1
enum {f=10, t, d=2}; // f: 10, t: 11, d: 2
</code></pre>
<p>Constants and pointers</p>
<pre><code class="language-c">int const  *ptr; 
// ptr is a pointer to constant int -&gt; can't modify the pointed variable with this pointer
int *const ptr = &amp;x; // constant pointer --&gt; needs initilization
// ptr is a constant pointer to int -&gt; can't modify the address stored in this pointer
</code></pre>
<p>Prepend a variable declaration with the <code>volatile</code> keyword to inform the compiler
that the variable may change without being explicitly reassigned; this disables any
optimizations.</p>
<p>Never use <code>volatile</code> with <code>const</code>.</p>
<pre><code class="language-c">char x = 3;
x = ~x; // The bitwise complement operator (unary)
</code></pre>
<p>The binary bitwise AND <code>&amp;</code> and OR <code>|</code> operators.</p>
<p>The binary bitwise XOR <code>^</code> operator.</p>
<pre><code class="language-c">int a = 1&lt;&lt;4; //The left-shift operator; left shift by 4, pad with 0's
// k&lt;&lt;n is equivalent to multiplying by 2^n
int a = 1&gt;&gt;4; //The right-shift operator; right shift by 4, pad with 0's
// k&gt;&gt;n is equivalent to dividing by 2^n
</code></pre>
<p>If a variable <code>x</code> is of type <code>T</code>, the expression <code>&amp;x</code> is of type <code>T*</code>.</p>
<p>If a variable <code>x</code> is of type <code>const T</code>, the expression <code>&amp;x</code> is of type <code>const T *</code>.</p>
<p>Increasing numeric size types:</p>
<ul>
<li><code>char</code>, <code>short</code>, <code>int</code>, <code>long int</code>, <code>long long int</code>.</li>
<li><code>float</code>, <code>double</code>, <code>long double</code>.</li>
</ul>
<p>The unsigned versions have the same sizes.</p>
<pre><code class="language-cpp">void function(const int *p){
    // this function won't use p to alter the pointed variable 
    // (which might or might not actually be const)
    int j = *p;
    *p = 0; // error
}
</code></pre>
<pre><code class="language-c">T a[s]; // an array `a` of size s and containing s elements with type `T`.
T a[s][s2]; // an array of arrays. contains s arrays each of size s2.
</code></pre>
<p>Array initialization:</p>
<pre><code class="language-c">int a[3] = {1, 2, 3};
int b[] = {1, 2, 3, 4};
double c[4] = {3}; // rest are set to zero
int d[4] = {[0]=3, [3]=3}; // rest are set to zero
char carr[] = &quot;bruh&quot;;
</code></pre>
<p>String manipulation in C</p>
<pre><code class="language-c">#include &lt;string.h&gt;
char a[12] = &quot;bruh&quot;;
int length = strlen(a); // length = 4, due to \0 terminated value in a

char b[12];
strcpy(b, &quot;nonsense&quot;); // copy into b
strcpy(a, b); // a now contains nonsense

strcpy(b, &quot;no&quot;); // b = &quot;no&quot;
strcat(b, &quot; nonsense&quot;); // b = &quot;no nonsense&quot;

strcmp(t1, t2); // -&gt; ~ t1 codes - t2 codes

char a[20];
scanf(&quot;%s&quot;, a); // NOT &amp;a
</code></pre>
<p>All these functions consider the null terminator as the end of the string.</p>
<p>Structs</p>
<pre><code class="language-c">struct structure_name {
    member_declarations;
};

struct Color{
    int red;
    int green;
    int blue;
};

struct Color b;
b.red = 0;
b.green = 0;
b.blue = 255;

struct Color *pb;
pb = &amp;b;

(*pc).red = 255;
pc-&gt;red = 255; // the two lines are equivalent

struct Color c = {128, 200, 0};
struct Color c = {.red=128, .green=200, .blue=0};

struct Color d = c; // shallow copy (d.red = c.red, ...)
</code></pre>
<p>Unions (synonym for Useless)</p>
<pre><code class="language-c">union union_name{
    member_declarations;
};
</code></pre>
<p>Can't return an array from a function.</p>
<pre><code class="language-c">do {
    nonsense();
}while(!working());
</code></pre>
<p>Switch</p>
<pre><code class="language-c">switch (selector){ // an int expression
    case val1: // an int expression available at compile time
    instructions1
    break;
    case val2:
    instructions2
    break;
    ...
    default:
    default_instructions
    break;
}
</code></pre>
<p>A switch selects the matching case in constant time.</p>
<p>Program arguments</p>
<pre><code class="language-c">int main(int argc, char *argv[]){
    // ...
}
// is equivalent to 
int main(int argc, char **argv){
    // ...
}
</code></pre>
<p><code>argc</code> is the argument count, <strong>including the program name</strong></p>
<p><code>argv</code> is the argument array, containing <code>argc</code> strings (<code>char*</code> delimited by <code>\0</code>)</p>
<p>Send a different exit code to the os.</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt; // exit declaration

void procedure(){
    exit(17); // equivalent to having an immediate return 17 in main()
}
int main(){
    procedure();
    // ...
    return 0;
}
</code></pre>
<pre><code class="language-c">#define PI 3.0
// ... duh

#define STRUCTURE \
struct bruh\
{\
  double x;\
  double y;\
}
// &lt;=&gt;
#define STRUCTURE struct bruh {double x; double y;}

// macro with no value, boolean flag
#define INT32

// function like macro
#define MAX(a, b) a&gt;b?a:b

// variadic macros
#define DEBUG(fmt, ...) fprintf(stdout, fmt, __VA_ARGS__);\
                        fflush(stdout)
</code></pre>
<p>To avoid operator precedence problems, wrap each macro formal
parameter in parentheses.</p>
<p>NEVER USE AN OPERATION THAT PRODUCES SIDE EFFECTS AS A MACRO ARGUMENT.
no idea how many times it will be called.</p>
<p>Macro names should ALWAYS be all uppercase.</p>
<pre><code class="language-c">#define bruh 
#undef bruh 
// undefine macro named bruh
</code></pre>
<pre><code class="language-c">#define LOGLEVEL 1
#if LOGLEVEL == 0
// ...
#elif LOGLEVEL == 1
// ...
// ...
#elif LOGLEVEL == 4
// ...
#else
// ...
#endif
</code></pre>
<pre><code class="language-c">#define M1 bruh
#define M2
#ifdef M1 // evaluates to true
// ...
#endif
#ifdef M2 // evaluates to true
// ...
#endif
#ifndef M3 // also evaluates to true
// ...
#endif
</code></pre>
<p>The conventional way to include header files, using header guards</p>
<pre><code class="language-c">// file: A.h
#ifndef A_H
#define A_H
//...
#endif
</code></pre>
<p><code>#if expression</code> where</p>
<p><em>The expression is a constant expression, using only literals and identifiers,
defined using #define directive. Any identifier, which is not literal,
non defined using #define directive, evaluates to 0.</em></p>
<p>The # operator transforms a formal macro parameter into a string.</p>
<pre><code class="language-c">#define·DISPLAYCALC(x)·printf(#x·&quot;·=·%d\n&quot;,·x)
// ...
int a = 4;
DISPLAYCALC(a); // prints: a = 4\n
DISPLAYCALC(a*a); // prints: a*a = 4\n
</code></pre>
<p>The ## operator concatenates two formal macro parameters or a formal macro parameter and a string.</p>
<pre><code class="language-c">int k; // both a declaration and definition
extern int j; // is a declaration but not a definition,
              // j is defined in some other compilation unit.
double square(double x) {return x*x;} // is both a declaration and definition
double root2(double); // is a declaration but not a definition
</code></pre>
<p>To define a type alias, declare a variable of the desired type and prefix its
declaration with typedef.</p>
<pre><code class="language-c">// intermediate step
char chess_board[8][8]; // models an 8x8 chess board, as a declaration 
typedef char chess_board[8][8]; // is now a type alias, not a variable
// can now use it to declare variables
chess_board c1, c2;
</code></pre>
<p>For structures, take a similar approach</p>
<pre><code class="language-c">struct point {
    int x, y;
};
struct point p; // intermediate step, variable
typedef struct point p; // final form of type alias
// can now declare variable using p instead of struct point
p point1, point2;
</code></pre>
<p>we can even combine the struct definition and alias</p>
<pre><code class="language-c">typedef struct point{
    int x, y;
} p;

struct point p1; // is ok
p p1; // is also ok
</code></pre>
<p>More useful version with a single identifier consumed</p>
<pre><code class="language-c">typedef struct {
    int x, y;
} p;

struct point p1; // NOOOOOO STOOOUUUPID
p p1; // is also ok
</code></pre>
<p>Parsing complex types</p>
<table><thead><tr><th> operator </th><th> sentence </th><th> priority </th></tr></thead><tbody>
<tr><td> [] </td><td> array of ... </td><td> highest </td></tr>
<tr><td> () </td><td> function returning ... </td><td> mid </td></tr>
<tr><td> * </td><td> pointer to ... </td><td> lowest </td></tr>
</tbody></table>
<pre><code class="language-c">int j = 3; // global variable is accessible to all functions
static int k = 3; // static variable is only accessible to functions in the same
// compilation unit ie same source file
</code></pre>
<pre><code class="language-c">char c = g() + 2; // NO, has to be a constant
char k = 'i' + 2; // Ok, know at compile time

int main(){
    // ...
}
</code></pre>
<p>Pointer p + int k = Pointer pointing k positions after p</p>
<p>Pointer p - int k = Pointer pointing k positions before p</p>
<p>Pointer p1 - Pointer p2 = number of elements in between the pointed elements</p>
<p>(if homogenous, otherwise bruh)</p>
<p>(Pointer p1 &lt; Pointer p2) evaluates to 0 or 1
(boolean result of numeric comparison)</p>
<pre><code class="language-c">int x[3];
// the following expressions are equivalent
x &lt;==&gt; &amp;x[0];
x[i] &lt;==&gt; (&amp;x[0])[i];
*x &lt;==&gt; *(&amp;x[0]) &lt;==&gt; x[0];
*(x+i) &lt;==&gt; x[i]

int t[4];
int *pt = &amp;t[0];
// the following expressions are equivalent
t[i] &lt;==&gt; pt[i] &lt;==&gt; *(t+i) &lt;==&gt; *(pt+i)
</code></pre>
<p>&quot;an array identifier is a constant pointer to the first element of the array&quot;</p>
<pre><code class="language-c">char *word[]; // array of pointers to char NOT pointer to array of char
</code></pre>
<p>dynamic memory management</p>
<pre><code class="language-c">// prototypes
void *malloc(size_t size);
void free(void *ptr);
void *realloc(void *ptr, size_t size);
</code></pre>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
double *p;
int n = 30;
p = malloc(n*sizeof(double)); // in c void* can be assigned to a T*, in C++ NO

for(int i=0; i&lt;n; i++) p[i] = 0.0; // can be used syntactically as an array
</code></pre>
<p>malloc may fail to allocate a block of memory, in which case it will return a
null pointer.</p>
<p>ALWAYS CHECK FOR NULL POINTER AFTER A CALL TO <code>malloc</code>.</p>
<pre><code class="language-c">int *p = malloc(20*sizeof(int));
if(p==NULL){
  // fix it ... or fail catastrophically
}else{
  // go ahead
}

free(p); // free the allocated block
</code></pre>
<pre><code class="language-c">int *p = malloc(20*sizeof(int));
// use, then find out it had an inappropriate size
p = realloc(p, 30*sizeof(int));
// yay, new size
</code></pre>
<p><code>realloc</code> check-list:</p>
<ul>
<li>allocate new block with the appropriate size (if no expansion possible)</li>
<li>copy data from the old block to the new (if could not just expand old block)</li>
<li>free the old block (if changed)</li>
<li>return pointer to the first element of the new block (if different)</li>
</ul>
<p><code>realloc</code> safety</p>
<pre><code class="language-c">double *realloc_safe(double *p, size_t newsize, int *ok){
  *ok = 1; // all is good for now
  int *q = realloc(p, newsize);
  if(q) p = q;
  else *ok = 0; // not good, inform the caller
  return p;
}
</code></pre>
<p>these checks insure that p is always a valid pointer regardless of the success
of the reallocation.</p>
<p>Advice:</p>
<ul>
<li>DO NOT TRY TO INFER THE SUCCESS OF THE OPERATION BY COMPARING THE NEW AND OLD
POINTER ADDRESSES. A SUCCESSFULL REALLOCATION CAN KEEP THE SAME ADDRESS.</li>
<li>ALWAYS FREE ALLOCATED BLOCKS</li>
<li>NEVER USE A POINTER AFTER FREEING ITS POINTED BLOCK</li>
<li>NEVER FREE MORE THAN ONCE (including realloc with 0 size)</li>
<li>NEVER ACCESS MEMORY BEYOND THE ALLOCATED LIMIT
(even worse than array out of bound access)</li>
</ul>
<pre><code class="language-c">// Generate all permutations of an array
#include &lt;stdio.h&gt;

void swap(int *a, int *b){
  int t = *a;
  *a = *b;
  *b = t;
}

void printarray(int n, int *a){
  for(int i=0; i&lt;n; i++)
    printf(&quot;%d &quot;, a[i]);
  printf(&quot;\n&quot;);
}

void auxperm(int n, int k, int *a){
  if(n==k) {printarray(n, a); return;}
  for(int i=k; i&lt;n; i++){
    swap(a+i, a+k);
    auxperm(n, k+1, a);
    swap(a+i, a+k);
  }
}

void perm(int n, int *a){
  auxperm(n, 0, a);
}

int main(){
  int n = 5;
  int a[n];
  for(int i=1; i&lt;=n; i++) a[i-1] = i;

  perm(n, a);

  return 0;
}
</code></pre>
<pre><code class="language-c">typedef const char *(*txtptr)(double);
</code></pre>
<p><code>txtptr</code> is the type &quot;pointer to function taking a double and returning a
pointer to a constant char&quot;.</p>
<pre><code class="language-c">assert((&quot;message&quot;, expr)); // efficient use of the comma operator
</code></pre>
<p>C function name nonsense</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void printchar(char c){
  printf(&quot;%c&quot;, c);
}

int main(){
  printchar('M'); // prints: M
  (*printchar)('M'); // compiles, prints: M 
  printf(&quot;\n&quot;);
  return 0;
}
</code></pre>
<p>Functions readily decay into pointers to themselves, see more on
<a href="https://www.reddit.com/r/C_Programming/comments/1az5qnz/comment/krz6bnr/?utm_source=share&amp;utm_medium=web3x&amp;utm_name=web3xcss&amp;utm_term=1&amp;utm_content=share_button"><code>reddit</code></a>
.</p>
<p>staticrap</p>
<pre><code class="language-c">void foo() {
    static int x = 5; // assigns value of 5 only once, at compile time
    x++;
    printf(&quot;%d&quot;, x);
}

int main() {
    foo(); // x = 6
    foo(); // x = 7
    return 0;
}
</code></pre>
<p>See more on <a href="https://stackoverflow.com/a/23777789"><code>StackOverflow</code></a>.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main() {
  int nv[] = {1, 2, 3};
  // common idiom to get the number of elements in an array in c
  int n = sizeof(nv) / sizeof(*nv);
  printf(&quot;%d\n&quot;, n); // prints: 3
  return 0;
}
</code></pre>
<a class="header" href="print.html#c-3" id="c-3"><h1>C++</h1></a>
<p>In C++, a true <code>bool</code> type is available with only <code>true</code> and <code>false</code> values.</p>
<p>In C, <code>'x'</code> and <code>'\n'</code> are of type <code>int</code>. In C++, they are of type <code>char</code>.</p>
<p>Can decorate <code>1000000</code> as <code>1'000'000</code>.</p>
<table><thead><tr><th> C header file </th><th> C++ header file </th></tr></thead><tbody>
<tr><td> <code>assert.h</code> </td><td> <code>cassert</code> </td></tr>
<tr><td> <code>ctype.h</code> </td><td> <code>cctype</code> </td></tr>
<tr><td> <code>errno.h</code> </td><td> <code>cerrno</code> </td></tr>
<tr><td> <code>float.h</code> </td><td> <code>cfloat</code> </td></tr>
<tr><td> <code>limits.h</code> </td><td> <code>climits</code> </td></tr>
<tr><td> <code>math.h</code> </td><td> <code>cmath</code> </td></tr>
<tr><td> <code>stdarg.h</code> </td><td> <code>cstdarg</code> </td></tr>
<tr><td> <code>stddef.h</code> </td><td> <code>cstddef</code> </td></tr>
<tr><td> <code>stdint.h</code> </td><td> <code>cstdint</code> </td></tr>
<tr><td> <code>stdio.h</code> </td><td> <code>cstdio</code> </td></tr>
<tr><td> <code>stdlib.h</code> </td><td> <code>cstdlib</code> </td></tr>
<tr><td> <code>string.h</code> </td><td> <code>cstring</code> </td></tr>
<tr><td> <code>time.h</code> </td><td> <code>ctime</code> </td></tr>
</tbody></table>
<p>Use C function in C++, if function is a common library function or was compiled
by a c compiler.</p>
<pre><code class="language-c">// in.c
#include &lt;stdio.h&gt;

void my_printer(char *s){
  printf(&quot;%s\n&quot;, s);
}
</code></pre>
<p>compile with</p>
<pre><code class="language-bash">gcc -c in.c
</code></pre>
<pre><code class="language-cpp">// extern.cpp
#include &lt;iostream&gt;

extern &quot;C&quot; double sin(double);

extern &quot;C&quot;
{
  double cos(double);
  double tan(double);
  void my_printer(char*);
}

int main(){
  std::cout &lt;&lt; sin(1.0) &lt;&lt; std::endl;
  std::cout &lt;&lt; cos(1.0) &lt;&lt; std::endl;
  std::cout &lt;&lt; tan(1.0) &lt;&lt; std::endl;
  char a[] = {'c', ' ', 'c', 'o', 'd', 'e'};
  my_printer(a);
  return 0;
}
</code></pre>
<p>compile with</p>
<pre><code class="language-bash">g++ -o extern extern.cpp in.o
</code></pre>
<p>In C++ a function can be oveloaded: same name, different signatures
and definitions.</p>
<p>If an overloaded function can handle <code>int</code> and <code>double</code> arguments, a compiler
error occurs if it is invoked on a <code>long</code> value \(\rightarrow\) the compiler
can't know to which type it should cast the <code>long</code>. Do an explicit cast.</p>
<p>Formal paramaters having default values should only be present in the function
declaration. They should not be followed by formal parameters having no default
values.</p>
<p>A namespace declaration can only contain declarations and no definitions, use
extern for namespace variable to avoid defining it and breaking the One
Definition Rule.</p>
<p>Extracting namespace component for use inside of a single compilation unit.</p>
<pre><code class="language-cpp">// ...
y = Math::power(x, 3)*Math::pi;
</code></pre>
<p>becomes</p>
<pre><code class="language-cpp">using Math::power;
using Math::pi;
// ...
y = power(x, 3)*pi;
</code></pre>
<p>Extracting all namespace components, USE ONLY IF A FEW NAMESPACES ARE USED.</p>
<pre><code class="language-cpp">using namespace Math;
</code></pre>
<p>Explicitly use a function in the globale namespace (<em>ie: not declared in any
namespace</em>)</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;

int main(){
    ::printf(&quot;bruh\n&quot;);
    return 0;
}
</code></pre>
<p>Anonymous Namespaces can only contain definitions (any declarations cannot
be accessed bruh). These definitions can only be used in the current compilation
unit.</p>
<pre><code class="language-cpp">namespace {
    int f(n) {return n*n;}
}
</code></pre>
<p>has the same effect as</p>
<pre><code class="language-cpp">static int f(n) {return n*n;}
</code></pre>
<p>all references must be initialized</p>
<pre><code class="language-cpp">double x, y;
double &amp;r = x; // r is a reference to the variable x
r = y; // the variable x now contains the value of the variable y
</code></pre>
<p>Never return a reference to a local variable or to a parameter not
passed by reference (<em>ie passed by value</em>).</p>
<pre><code class="language-cpp">// OK
double&amp; maximum(double&amp; a, double&amp; b){
    return (a&gt;=b)?a:b;
}
// STOOPID
double&amp; maximum(double a, double b){
    return (a&gt;=b)?a:b;
}
</code></pre>
<p>A lot to unpack, but the common idiom is to declare a function receiving const
references and returning a const reference, and an overloaded version which
receives non const references and returns a non const reference.</p>
<pre><code class="language-cpp">double&amp; maxi(double&amp; a, double&amp; b){
    return (a&gt;b) ? a : b;
}
const double&amp; maxi(const double&amp; a, const double&amp; b){
    return (a&gt;b) ? a : b;
}
</code></pre>
<p>a reference must always be initialized or declared extern (<em>initialized in an
other compilation unit</em>).</p>
<pre><code class="language-cpp">double&amp; r1; // NOOOOO
extern double&amp; r2; // OK, make sure it's defined elsewhere
</code></pre>
<p>&quot;References behave like constant pointers who are automatically dereferenced&quot;</p>
<pre><code class="language-cpp">auto i = ... ; // let the compiler deduce the appropriate type
decltype(expr) j = ... ; // declare the variable j as having the same type as expr
</code></pre>
<p>use <code>using</code> instead of <code>typedef</code> in C++</p>
<pre><code class="language-cpp">using txtptr = const char * (*) (double);
using y = x; // y is the new (hopefully more intuitive) name for the type x
</code></pre>
<p>Use <code>nullptr</code> (of type <code>nullptr_t</code>) instead of <code>0</code> or <code>NULL</code>.</p>
<p>Favor the four kinds of modern C++ casts to standard C casts.</p>
<pre><code class="language-cpp">static_cast&lt;new_type&gt;(expr); // use for numeric types
const_cast&lt;new_type&gt;(expr); // get something non constant or non volatile
reinterpret_cast&lt;new_type&gt;(expr); // use for pointer cast, often nonsensical
dynamic_cast&lt;new_type&gt;(expr); // stoopid oop nonsense
</code></pre>
<p>A function whose result is declared to be constexr can be evaluated at compile
time if its arguments are const, constexpr or litterals.</p>
<p><img src="media/constexpr_func.png" width=600/></p>
<p><code>consteval</code> - specifies that a function is an immediate function, that is,
every call to the function must produce a compile-time constant.</p>
<p><img src="media/consteval.png" width=600/></p>
<p>Conditionally compile with <code>if constexpr(expr)</code> where <code>expr</code> is an expression
known at compile time.</p>
<pre><code class="language-cpp">static_assert(expr, &quot;message&quot;); // expr must be evaluated at compile time
</code></pre>
<pre><code class="language-cpp">double a[30];
for(double x : a)
    x = 0; // STOOPID, x is a copy of an element of a
for(double&amp; x : a)
    x = 0; // OK, will modify, since x references an element of a
// if large elements, and no modification needed, favor a constant reference
for(const double&amp; x : a) // or const auto&amp;
    std::cout &lt;&lt; x;
</code></pre>
<pre><code class="language-cpp">double *p;
p = new double; // uninitialized
double *x = new double(5); // initialized to value 5
double *y = new double{6}; // initialized to value 6
double *z = new double(); // initialized to 0

double *p = new double[n]; // pointer to first element of
                           // array dynamically allocated
double *p = new double[3]{1.0, 3.0, 3.0}; // initialized version
delete p; // ok
double *q = reinterpret_cast&lt;double*&gt;(malloc(sizeof(int)));
delete q; // NOOOOO, STOOPID
</code></pre>
<p>Anything declared with <code>new[]</code> must be deleted with <code>delete[]</code>.
U.B. .
If a type <code>T</code> aliases an array type, any allocated <code>new T</code> must be unallocated
with <code>delete[]</code></p>
<pre><code class="language-cpp">class TClass {
    private:
    // ... //
    protected:
    // ... //
    public:
    // ... //
}
// if absent, private
// can repeat sections
</code></pre>
<p>In C, <code>struct X</code> declares a type <code>struct X</code>, in C++ it declares a type <code>X</code>
(similar to <code>class X</code>).</p>
<p>Always place class declaration in <code>.h</code> header file with the same name as the
class, place the implementation in a <code>.cpp</code> file with the same filename.</p>
<p><code>this</code> is a constant pointer to the object, it is automatically added to member
methods by compilers.</p>
<p>For a setter, returning <code>*this</code> allows method chaining.</p>
<pre><code class="language-cpp">class T{
  public:
    RT method(params) const; // this method won't modify the object 
};
</code></pre>
<p>If a method does not modify its calling object, declare it <code>const</code>.</p>
<p>A <code>const</code> method cannot call a non <code>const</code> method. It can however call a <code>static</code>
method.</p>
<p>Functions who are friends of a class can access all fields and methods of this
class.</p>
<p>Inline functions must be declared and defined (below) in header files.
The compiler needs the definition.</p>
<p>A method defined in the class declaration is implicitly inline.</p>
<p>Inline functions can't be recursive.</p>
<p>The default constructor is invoked automatically if an object is not initialized.</p>
<p>If fields are initialized (using constants), the default constructor and all
other constructors will not have to initialize the fields. (... helpfull)</p>
<p>If a constructor with parameters exists, the compiler won't provide the default
parameterless constructor. To specifically request it, use:</p>
<pre><code class="language-cpp">class S{
    public:
      S() = default; // request the default parameterless constructor
};
</code></pre>
<pre><code class="language-cpp">class X{
    public:
      X(const X&amp; x); // cloning constructor
};
</code></pre>
<pre><code class="language-cpp">X x;
X y(x); // same as
X y = x; // this
X y{x}; // same as
</code></pre>
<p>Always provide a cloning constructor for classes that have dynamically allocated
fields (pointers, new nonsense ... etc). A cloner for class <code>T</code> has <code>T(const T&amp;)</code>
for a signature.</p>
<pre><code class="language-cpp">class Z{
  // assumed to have a parameterless AND a cloning constructor
  // assumed to be assignable: Z z1, z2; ...; z1 = z2;
};
class X{
  private:
    int k_;
    Z z_;
    X(int k, const Z&amp; z); // constructor
};

// NO, STOOPID
X::X(int k, const Z&amp; z){
  k_ = k;
  z_ = z; // here z_ is initialized first with the parameterless constructor
  // it is then reaffected using the cloning constructor
}

// CHAD
X::X(int k, const Z&amp; z):k_(k), z_(z){ // call the cloning constructor first
}
</code></pre>
<pre><code class="language-cpp">class C{
    public:
      ~C(); // Destructor
};
</code></pre>
<p>the <code>delete</code> operator calls the destructor before freeing the memory dynamically
allocated with <code>new</code>.</p>
<blockquote>
<p>The expression <code>const_cast&lt;T&gt;(v)</code> can be used to change the <code>const</code> or <code>volatile</code>
qualifiers of pointers or references. (Among new-style casts, only <code>const_cast&lt;&gt;</code>
can remove const qualifiers.) <code>T</code> must be a pointer, reference, or
pointer-to-member type.</p>
</blockquote>
<p>If an object can have multiple equivalent physical representations, consider
using the <code>mutable</code> qualifier on fields that should be modifiable even if the
object is declared <code>const</code>.</p>
<p><code>mutable</code> vs <code>const_cast&lt;...&gt;(this)</code> : EPIC FIGHT</p>
<ul>
<li><code>const_cast</code>: make all fields modifiable, just now</li>
<li><code>mutable</code>: permits modification of the class member declared mutable even if
the containing object is declared const.</li>
</ul>
<p>Operators that cannot be overloaded: <code>::</code>, <code>.*</code>, <code>.</code>, <code>?:</code>, <code>sizeof</code>.</p>
<p><code>=</code>, <code>[]</code>, <code>()</code>, <code>-&gt;</code>: always overload these operators with methods.</p>
<p><code>T&amp; operator=(const T&amp;);</code> is the proper signature for the overloaded assignement
operator.</p>
<p><code>ostream&amp; operator&lt;&lt;(ostream&amp;, const T&amp;)</code> is the (only) proper signature for
the overloaded <code>&lt;&lt;</code> operator.</p>
<p><code>istream&amp; operator&lt;&lt;(ostream&amp;, T&amp;)</code> is the (only) proper signature for
the overloaded <code>&gt;&gt;</code> operator.</p>
<p>Call a method from within these two overloaded operators; this allows for
subclasses to define their own standards for stream operations \(\rightarrow\)
polymorphism.</p>
<p><code>x[j]</code> is equivalent to <code>x.operator[](j)</code></p>
<p><code>explicit</code> specifies that a constructor is explicit, that is, it cannot be
used for implicit conversions and copy-initialization.</p>
<p>To convert an instance of class <code>T</code> into an instance of type <code>X</code>:</p>
<pre><code class="language-cpp">T t;
X x;
x = t; // is equivalent to 
x = t.operator X(); // this
T.operator X() // -&gt; convert the instance of type T into an equivalent instance of type X
</code></pre>
<pre><code class="language-cpp">class A 
{
    public:
       int x;
    protected:
       int y;
    private:
       int z;
};

class B : public A
{
    // x is public
    // y is protected
    // z is not accessible from B
};

class C : protected A
{
    // x is protected
    // y is protected
    // z is not accessible from C
};

class D : private A    // 'private' is default for classes
{
    // x is private
    // y is private
    // z is not accessible from D
};
</code></pre>
<p>Constructors are never inherited.</p>
<p>Always call the parent constructor in the inherited constructor.</p>
<pre><code class="language-cpp">class Y{
  private:
  T1 t1_;
  public:
  Y(T1 t1);
};

Y::Y(T1 t1){
  t1_ = t1;
}

class X : public Y{
  private:
  T2 t2_;
  public: 
    X(T1 t1, T2 t2);
};

X::X(T1 t1, T2 t2) : Y(t1){
  t2_ = t2;
}
</code></pre>
<pre><code class="language-cpp">// multiple inheritance
class Child: public parent1, private parent2 {};
</code></pre>
<p>A pointer (or reference) to class <code>T</code> used to call method <code>m()</code>
uses the definition of <code>m</code> in the class <code>T</code>, even if the pointed instance is of
a subclass of <code>T</code> which overrides <code>m</code>.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class X {
public:
  void do_smthg();
  virtual void do_smthg_else();
};

class Y : public X{
public:
  void do_smthg();
  void do_smthg_else() override;
};

void Y::do_smthg(){
  cout &lt;&lt; &quot;y do\n&quot;;
}

void Y::do_smthg_else(){
  cout &lt;&lt; &quot;y do\n&quot;;
}

void X::do_smthg(){
  cout &lt;&lt; &quot;x do\n&quot;;
}

void X::do_smthg_else(){
  cout &lt;&lt; &quot;x do\n&quot;;
}

int main(){
  X *a[3];
  a[0] = new Y();
  a[0]-&gt;do_smthg(); // x do: static dispatch
  a[0]-&gt;do_smthg_else(); // y do: dynamic dispatch
  return 0;
}
</code></pre>
<p>use <code>virtual</code> on base type, <code>virtual</code> or preferrably <code>override</code> on the child
type.</p>
<p><code>static</code> methods (class methods) and constructors cannot be virtual.</p>
<p>A call to a virtual method in the constructor of a base class uses the definition
of the method in the base class. Avoid calling virtual methods in a constructor.</p>
<p>If polymorphism is used, USE A VIRTUAL DESTRUCTOR. Why ? Because.</p>
<p>If you have a virtual function that is not abstract, then you must implement it.</p>
<p>To declare a method abstract:</p>
<pre><code class="language-cpp">virtual qualifiers returntype method(params) qualifiers = 0;
// also called pure virtual method
</code></pre>
<p>A class having at least one abstract method is considered abstract,
it can't be instanciated (incomplete class).</p>
<p>An interface is a class that only contains pure virtual methods.</p>
<blockquote>
<p>A destructor can be declared virtual (10.3) or pure virtual (10.4); if any
objects of that class or any derived class are created in the program,
the destructor shall be defined. If a class has a base class with a virtual
destructor, its destructor (whether user- or implicitly-declared) is virtual.</p>
</blockquote>
<p>The destructor of a base class is always called from the destructor of the
derived class, even if it is declared virtual pure. It must always be
implemented.</p>
<p>An abstract subclass of an abstract class can implement part of a virtual pure
method, and still declare it virtual pure; its subclasses can then call its
implementation in their (hopefully) final implementation. Still, DECLARE IT
VIRTUAL PURE.</p>
<p>If a method is supposed to override a virtual method in a base class, use the
<code>override</code> keyword, this way if the method signatures don't match (forgot
<code>const</code> for example), there will be a compile time error.</p>
<p>To overload a method in a base class, reinject it into the scope
<code>using Base::method;</code>.
See unqualified name lookup in
<a href="https://stackoverflow.com/questions/35870081/c-base-class-function-overloading-in-a-subclass"><code>StackOverflow</code></a>
and <a href="https://en.cppreference.com/w/cpp/language/unqualified_lookup"><code>cppreference</code></a>.</p>
<p>Templates</p>
<pre><code class="language-cpp">template &lt;int k, typename R, typename T&gt;
T f(R){
  for(int n=0; n&lt;k; k++) 
   // ...
}
</code></pre>
<p>either a type <code>T</code> or <code>int</code> param or <code>bool</code> param. can also be used for a class.</p>
<p>template default values</p>
<pre><code class="language-cpp">template &lt;int d, typename NT&gt; // ok
class X{
  // ...
};
template &lt;int d, typename NT=double&gt; // ok
class X{
  // ...
};
template &lt;int d=3, typename NT=double&gt; // ok
class X{
  // ...
};
X&lt;&gt; ; // ok
X&lt;2&gt; ; // ok
X&lt;2,double&gt; ; // ok
X&lt;,double&gt; ; // no

template &lt;int d=3, typename NT&gt; // NOOOO
class X{
  // ...
};
</code></pre>
<p>Stack allocated objects created within a try bloc before an exception is thrown
are automatically deleted. (NOT tru for dynamically allocated objects with new).</p>
<pre><code class="language-cpp">try{
  int k;
  std::cin &gt;&gt; k;
  if(k&lt;0)
    throw k;
  else if(k==0)
    throw std::exception;
}catch(int i){
  // if exception is of type int, execute this and jump after all catch blocks
}catch(std::exception e){
}
</code></pre>
<p>Standard Exceptions are in the header <code>&lt;stdexcept&gt;</code>,
they all inherit from <code>std::exception</code>.</p>
<p>Favor using exception classes instead of string and numeric constants in catch
block parameters. (create classes that inherit from the std::exception class).</p>
<ul>
<li>An exception forces calling code to recognize an error condition and handle it. Unhandled exceptions stop program execution.</li>
<li>An exception jumps to the point in the call stack that can handle the error. Intermediate functions can let the exception propagate. They don't have to coordinate with other layers.</li>
<li>The exception stack-unwinding mechanism destroys all objects in scope after an exception is thrown, according to well-defined rules.</li>
<li>An exception enables a clean separation between the code that detects the error and the code that handles the error.</li>
</ul>
<pre><code class="language-cpp">try{
  executeProgram();
}catch(...){ // universal exception handler, catch all exceptions, unknown
  prepareProgramStop();
}
</code></pre>
<pre><code class="language-cpp">// some dynamic memory is allocated
// some exception is thrown
catch(...){
// deallocate memory
  throw; // rethrow the exception
}
</code></pre>
<pre><code class="language-cpp">class X{
  public:
  X(const X&amp;) = delete; // don't allow copy constructor
};
</code></pre>
<p>See <a href="https://stackoverflow.com/questions/5513881/meaning-of-delete-after-function-declaration">StackOverflow</a>
for more details on <code>method = delete</code>.</p>
<p>See Resource Acquisition is initialization (RAII) on
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">wikipedia</a>.</p>
<pre><code class="language-cpp">// careful, slicing: will only get base type and message
catch(std::exception e) 
catch(const std::exception e) 
// ok, virtual message, no slicing 
catch(const std::exception&amp; e) // favor using const reference -&gt; no slicing
</code></pre>
<p>The <code>catch</code> exception handlers are examined in order when an exception is
thrown in the <code>try</code> block; as soon as one has a matching parameter type (even
if superclass), its block is executed. The other <code>catch</code> blocks are all skipped
, even when the parameters match. ORDEEEER!</p>
<p>Throwing an exception should never cause a memory leak, use RAII.</p>
<p>IOS INBREEDING</p>
<p><img src="media/family1.png" width=300 height=200/>
<img src="media/family2.png" width=300 height=200/>
<img src="media/family3.png" width=300 height=200/>
<img src="media/family4.png" width=300 height=200/>
<img src="media/iostream_fam.png" width=600 /></p>
<p><code>std::cout</code>, <code>std::cerr</code> and <code>std::clog</code> are all instances of <code>std::ostream</code>,
<em>ie:</em> <code>std::basic_ostream&lt;char&gt;</code>.</p>
<p><code>std::cin</code> is an instance of <code>std::istream</code>,
<em>ie:</em> <code>std::basic_istream&lt;char&gt;</code>.</p>
<p>A stream can have four (non exclusive) states: <code>fail</code>, <code>good</code>, <code>bad</code> and <code>eof</code>.</p>
<ul>
<li>fail: error, but no data loss, cant read or write from now on</li>
<li>bad: error, with data loss, cant read or write from now on</li>
<li>eof: end of stream encountered, not an error,
but cant read or write from now on</li>
<li>good: good ... (duh)</li>
</ul>
<p>a stream is automatically cast to a bool using <code>!fail()</code>. It is considered
<code>true</code> if the last IO operation succeded.</p>
<pre><code class="language-cpp">while(std::cin){ // while the last input was successful &lt;==&gt; !(std::cin.fail())
  // continue processing
}
</code></pre>
<p>Force stream state</p>
<pre><code class="language-cpp">std::cin.clear(std::ios_base::failbit);
std::cin.clear(std::ios_base::badbit);
std::cin.clear(std::ios_base::eofbit);
std::cin.clear(); // defaults to std::ios_base::goodbit
</code></pre>
<p>A stream's openmode is of type <code>std::ios_base::openmode</code>. It is a bitmask type
<em>ie:</em> can be combined with <code>|</code>;
ex: <code>(ios_base::in | ios_base::out | ios_base::binary )</code></p>
<p>See <a href="https://en.cppreference.com/w/cpp/io/ios_base/openmode"><code>cppreference</code></a> for
more information.</p>
<p>Input Stream Methods</p>
<ul>
<li>
<p><code>std::ios_base::app</code> comes from 'append' - all output will be added (appended) to the end of
the file. In other words you cannot write anywhere else in the file but at
the end.</p>
</li>
<li>
<p><code>std::ios_base::ate</code> comes from 'at end' - it sets the stream position at the end of the
file when you open it, but you are free to move it around (seek) and write
wherever it pleases you.</p>
</li>
</ul>
<p>More details on <a href="https://stdcxx.apache.org/doc/stdlibug/30-3.html">openmodes</a>.</p>
<ul>
<li><code>is::get(char &amp;)</code> -&gt; get a char from a stream. returns the stream. Does not ignore
non printable chars.</li>
<li><code>is::unget()</code> -&gt; last char read is put back in the buffer, as if it was never read
also returns the stream.</li>
<li><code>is::putback(char_type)</code> -&gt; char parameter is put in the buffer, also returns
the stream.</li>
<li><code>is::peek()</code> -&gt; returns the next character in the stream, does not read it.</li>
<li><code>getline(input_stream, string_storage, delimiter)</code> -&gt;  reads until delimiter
or EOF and writes into string until length is reached.
see <a href="https://en.cppreference.com/w/cpp/string/basic_string/getline"><code>cppreference</code></a>.</li>
<li><code>is::read(char* storage, count)</code> -&gt; reads and stores into storage until count
or EOF is reached.
See <a href="https://en.cppreference.com/w/cpp/io/basic_istream/read"><code>cppreference</code></a>.</li>
<li><code>basic_istream&amp; ignore(std::streamsize count=1, int_type delim=Traits::eof());</code>
bruh look it <a href="https://en.cppreference.com/w/cpp/io/basic_istream/ignore">up</a>.</li>
</ul>
<p>Some input streams (non interactive ones, unline std::cin) support positioning
with the <a href="https://en.cppreference.com/w/cpp/io/basic_istream/tellg"><code>tellg()</code></a> and
<a href="https://en.cppreference.com/w/cpp/io/basic_istream/seekg"><code>seekg(pos | offset, seekdir)</code></a>
functions.</p>
<p><code>seekdir</code> can be <code>ios_base::beg</code>, <code>ios_base::end</code> or <code>ios_base::cur</code>.</p>
<p>Positioning often requires a stream to be open in <code>std::io_base::binary</code>.</p>
<p><code>std::ifstream</code> follows RAII idiom, its constructor takes a file name as a string
and an optional (default = <code>std::ios_base::in</code>) <code>std::ios_base::openmode</code>;
see more on <a href="https://en.cppreference.com/w/cpp/io/basic_ifstream/basic_ifstream"><code>cppreference</code></a>.</p>
<p>The <code>rdbuf()</code> method returns a pointer to the stream_buffer associated with the
basic_ios.
<a href="https://en.cppreference.com/w/cpp/io/basic_ios/rdbuf"><code>cppreference</code></a>.</p>
<pre><code class="language-cpp">#include &lt;fstream&gt;
#include &lt;iostream&gt;
int main(){
  std::ifstream dat(&quot;test.dat&quot;, std::ios_base::in | std::ios_base::binary);
  std::cout &lt;&lt; &quot;ifstream rdbuffer is open? &quot; &lt;&lt; dat.rdbuf()-&gt;is_open() &lt;&lt; std::endl;
  dat.rdbuf()-&gt;close();
  std::cout &lt;&lt; &quot;ifstream rdbuffer is open? &quot; &lt;&lt; dat.rdbuf()-&gt;is_open() &lt;&lt; std::endl;
  return 0;
}
</code></pre>
<p>The <code>void open( const char* filename,std::ios_base::openmode mode=std::ios_base::in)</code>
method opens and associates the file with name <code>filename</code> with the file stream.
See <a href="https://en.cppreference.com/w/cpp/io/basic_ifstream/open"><code>cppreference</code></a> for more
details.</p>
<p>The <code>void close()</code> method of <code>ifstream</code> closes the associated file.
This function is called by the destructor of basic_fstream when the stream
object goes out of scope and is not usually invoked directly.
<a href="https://en.cppreference.com/w/cpp/io/basic_fstream/close"><code>cppreference</code></a>.</p>
<p>The method <code>bool is_open()</code> checks if the file stream has an associated file.
<a href="https://en.cppreference.com/w/cpp/io/basic_fstream/is_open"><code>cppreference</code></a>.
Used to ckeck if a file opened for reading exists.</p>
<p><a href="https://stackoverflow.com/questions/4872361/why-are-there-two-different-getline-functions-if-indeed-there-are"><code>stackoverflow</code></a></p>
<blockquote>
<p>The global getline() function works with C++ std::string objects.
The istream::getline() methods work with &quot;classic&quot; C strings (pointers to char).</p>
</blockquote>
<p>Use <a href="https://en.cppreference.com/w/cpp/io/basic_istringstream"><code>istringstream</code></a>
to convert a string into an objet whose class supports the <code>&gt;&gt;</code> operator.</p>
<p><a href="https://en.cppreference.com/w/cpp/io/basic_istringstream/str"><code>istringstream::str()</code></a>
returns a copy of the underlying string.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sstream&gt;
int main(){
  std::string s1 = &quot;1 2&quot;;
  std::istringstream is(s1);

  // obtain string in the input string stream
  std::cout &lt;&lt; is.str() &lt;&lt; std::endl; // prints: 1 2

  // change string in the input string stream
  std::string s2 = &quot;3 4&quot;;
  is.str(s2);

  int a, b;
  is &gt;&gt; a &gt;&gt; b; // read input string stream
  std::cout &lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; &quot; b=&quot; &lt;&lt; b &lt;&lt; std::endl; // prints: a=3 b=4
  return 0;
}
</code></pre>
<p><a href="https://en.cppreference.com/w/cpp/io/basic_istringstream"><code>istringstream</code></a> supports
positioning with <a href="https://en.cppreference.com/w/cpp/io/basic_istream/seekg"><code>seekg(...)</code></a>
and <a href="https://en.cppreference.com/w/cpp/io/basic_istream/tellg"><code>tellg()</code></a>.</p>
<p>Similarly to <code>istream</code>,
<a href="https://en.cppreference.com/w/cpp/io/basic_ofstream"><code>ostream</code></a>
can handle 3 kinds of operations:</p>
<ul>
<li>formatted (output) with <code>&lt;&lt;</code></li>
<li>unformatted (output) with
<a href="https://en.cppreference.com/w/cpp/io/basic_ostream/put"><code>put</code></a> and
<a href="https://en.cppreference.com/w/cpp/io/basic_ostream/write"><code>write(char*, count)</code></a></li>
<li>positioning with
<a href="https://en.cppreference.com/w/cpp/io/basic_ostream/tellp"><code>tellp()</code></a> and
<a href="https://en.cppreference.com/w/cpp/io/basic_ostream/seekp"><code>write(pos | offset, seekdir)</code></a></li>
</ul>
<p><a href="https://en.cppreference.com/w/cpp/io/basic_ofstream"><code>ofstream</code></a>
has a destructor that automagically closes the associated file \(\rightarrow\)
RAII. A useful constructor is
<a href="https://en.cppreference.com/w/cpp/io/basic_ofstream/basic_ofstream"><code>ofstream(filename, openmode)</code></a>.</p>
<p><a href="https://en.cppreference.com/w/cpp/io/basic_ofstream"><code>ofstream</code></a>
also has the usual
<a href="https://en.cppreference.com/w/cpp/io/basic_ofstream/rdbuf"><code>rdbuf</code></a>,
<a href="https://en.cppreference.com/w/cpp/io/basic_ofstream/open"><code>open</code></a>,
<a href="https://en.cppreference.com/w/cpp/io/basic_ofstream/close"><code>close</code></a> and
<a href="https://en.cppreference.com/w/cpp/io/basic_ofstream/is_open"><code>is_open</code></a>
methods.</p>
<p>Use <a href="https://en.cppreference.com/w/cpp/io/basic_ostringstream"><code>ostringstream</code></a>
to convert an objet whose class supports the <code>&lt;&lt;</code> operator into a string.
Its constructor takes a char sequence and an <code>openmode</code>
(default is <code>ios_base::out</code>). Its
<a href="https://en.cppreference.com/w/cpp/io/basic_ostringstream/str"><code>str</code></a> method
manages the contents of the underlying string object, that object can be changed
through it.</p>
<p>The <a href="https://en.cppreference.com/w/cpp/io/basic_ostringstream/str"><code>str</code></a> method
comes is overloaded:</p>
<ul>
<li>one version (&lt;=3) returns a copy of the string associated with the ostringstream.</li>
<li>another version (&gt;=4) can copy a string into the internal
<a href="https://en.cppreference.com/w/cpp/io/basic_stringbuf"><code>stringbuf</code></a>.</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;sstream&gt;
template &lt;typename T&gt;
std::string toString(const T&amp; x){
  std::ostringstream os(std::ios_base::app); // append to file
  std::string buf = &quot;*&quot;; // arbitrary prefix to show the effect of append mode
  os.str(buf);
  os &lt;&lt; x;
  return os.str();
}
int main(){
  std::string pi_str = toString(std::acos(-1.0));
  std::cout &lt;&lt; &quot;PI=&quot; &lt;&lt; pi_str &lt;&lt; std::endl; // PI=*3.14159
  return 0;
}
</code></pre>
<p>Some important io manipulators in <code>&lt;ios&gt;</code></p>
<pre><code class="language-cpp">#include &lt;iomanip&gt;
#include &lt;ios&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;

int main() {
  bool v = true;

  // boolalpha , noboolalpha
  std::cout &lt;&lt; std::boolalpha &lt;&lt; v &lt;&lt; &quot; &quot; &lt;&lt; std::noboolalpha &lt;&lt; v &lt;&lt; std::endl;
  v = false; // print: true 1
  std::cout &lt;&lt; std::boolalpha &lt;&lt; v &lt;&lt; &quot; &quot; &lt;&lt; std::noboolalpha &lt;&lt; v
            &lt;&lt; std::endl; // print: false 0

  // showbase, noshowbase, dec, hex, oct
  std::cout &lt;&lt; std::showbase;
  std::cout &lt;&lt; std::dec &lt;&lt; 15 &lt;&lt; &quot; &quot; &lt;&lt; std::hex &lt;&lt; 15 &lt;&lt; std::oct &lt;&lt; &quot; &quot; &lt;&lt; 15
            &lt;&lt; std::endl; // prints: 15 0xf 017
  std::cout &lt;&lt; std::noshowbase;
  std::cout &lt;&lt; std::dec &lt;&lt; 15 &lt;&lt; &quot; &quot; &lt;&lt; std::hex &lt;&lt; 15 &lt;&lt; std::oct &lt;&lt; &quot; &quot; &lt;&lt; 15
            &lt;&lt; std::endl; // prints: 15 f 17

  // showpoint, noshowpoint
  double d = 33.0, q = 33.1;
  std::cout &lt;&lt; std::showpoint &lt;&lt; d &lt;&lt; &quot; &quot; &lt;&lt; std::noshowpoint &lt;&lt; d &lt;&lt; &quot; &quot; &lt;&lt; q
            &lt;&lt; std::endl; // prints: 33.0000 33 33.1

  // showpos, noshowpos
  double pi = 3.14159;
  std::cout &lt;&lt; std::showpos &lt;&lt; pi &lt;&lt; &quot; &quot; &lt;&lt; 0.0 &lt;&lt; &quot; &quot; &lt;&lt; std::noshowpos &lt;&lt; pi
            &lt;&lt; std::endl; // prints: +3.14159 +0 3.14159

  // skipws, noskipws
  char c1, c2, c3;
  std::cout &lt;&lt; &quot;type&gt;&quot;;
  std::cin &gt;&gt; std::skipws &gt;&gt; c1 &gt;&gt; std::noskipws &gt;&gt; c2 &gt;&gt;
      c3; // type: &lt;space&gt; A &lt;space&gt; B
  std::cout &lt;&lt; std::hex &lt;&lt; std::showbase &lt;&lt; static_cast&lt;int&gt;(c1) &lt;&lt; &quot; &quot;
            &lt;&lt; static_cast&lt;int&gt;(c2) &lt;&lt; &quot; &quot; &lt;&lt; static_cast&lt;int&gt;(c3)
            &lt;&lt; std::endl; // prints: 0x41 0x20 0x42

  // scientific, fixed, defaultfloat, hexfloat
  double x = 0.00002;
  std::cout &lt;&lt; std::fixed &lt;&lt; x &lt;&lt; std::endl;        // prints: 0.000020
  std::cout &lt;&lt; std::scientific &lt;&lt; x &lt;&lt; std::endl;   // prints: 2.000000e-05
  std::cout &lt;&lt; std::defaultfloat &lt;&lt; x &lt;&lt; std::endl; // prints: 2e-05
  std::cout &lt;&lt; std::hexfloat &lt;&lt; x &lt;&lt; std::endl; // prints: 0x1.4f8b588e368f1p-16

  // uppercase, nouppercase
  double y = 300.1234;
  int k = -559038737;
  std::cout &lt;&lt; std::scientific &lt;&lt; std::hex;
  std::cout &lt;&lt; std::uppercase &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; k
            &lt;&lt; std::endl; // prints: 3.001234E+02 0XDEADBEEF
  std::cout &lt;&lt; std::nouppercase &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; k
            &lt;&lt; std::endl; // prints: 3.001234e+02 0xdeadbeef

  // std::setfill, std::left, std::right and std::internal
  std::cout &lt;&lt; std::hex &lt;&lt; std::showbase;
  std::cout &lt;&lt; std::setfill('#') &lt;&lt; std::setw(12);
  std::cout &lt;&lt; std::left &lt;&lt; 24 &lt;&lt; std::endl; // prints: 0x18########
  std::cout &lt;&lt; std::setfill('#') &lt;&lt; std::setw(12);
  std::cout &lt;&lt; std::right &lt;&lt; 24 &lt;&lt; std::endl; // prints: ########0x18
  std::cout &lt;&lt; std::setfill('#') &lt;&lt; std::setw(12);
  std::cout &lt;&lt; std::internal &lt;&lt; 24 &lt;&lt; std::endl; // prints: 0x########18

  // std::ws
  char c4, c5;
  std::cout &lt;&lt; &quot;type&gt;&quot;;
  std::cin &gt;&gt; std::skipws &gt;&gt; c4 &gt;&gt; std::noskipws &gt;&gt; std::ws &gt;&gt;
      c5; // type: &lt;space&gt; A &lt;space&gt; B
  std::cout &lt;&lt; std::hex &lt;&lt; std::showbase &lt;&lt; static_cast&lt;int&gt;(c4) &lt;&lt; &quot; &quot;
            &lt;&lt; static_cast&lt;int&gt;(c5) &lt;&lt; std::endl; // prints: 0x41 0x42

  // std::ends
  std::ostringstream os;
  os &lt;&lt; &quot;AAA&quot; &lt;&lt; std::ends &lt;&lt; &quot;BBB&quot; &lt;&lt; std::ends &lt;&lt; &quot;CCC&quot; &lt;&lt; std::ends
     &lt;&lt; std::flush; // make c style strings
  std::string s = os.str();
  for (auto c : s)
    std::cout &lt;&lt; std::hex &lt;&lt; std::showbase &lt;&lt; static_cast&lt;int&gt;(c) &lt;&lt; &quot; &quot;;
  // prints: 0x41 0x41 0x41 0 0x42 0x42 0x42 0 0x43 0x43 0x43 0
  std::cout &lt;&lt; std::endl;

  return 0;
}
</code></pre>
<p><a href="https://en.cppreference.com/w/cpp/io/manip/unitbuf"><code>unitbuf/nounitbuf</code></a>
enables or disables automatic flushing of the output stream after any
output operation.</p>
<p>The oracle at <a href="https://stackoverflow.com/a/6027938"><code>stackoverflow</code></a> informs us
that <a href="https://en.cppreference.com/w/cpp/io/cerr"><code>cerr/wcerr</code></a> default to
<code>unitbuf</code>. You do want to see the errors if a crash happens.</p>
<p>What's the difference between <code>ws</code> and <code>skipws</code> ?
<a href="https://stackoverflow.com/a/68341644"><code>🔮</code></a></p>
<ul>
<li>
<p><a href="https://en.cppreference.com/w/cpp/io/manip/skipws"><code>skipws</code></a> enables or
disables skipping of leading whitespace by the formatted input functions.</p>
</li>
<li>
<p><a href="https://en.cppreference.com/w/cpp/io/manip/ws"><code>ws</code></a> discards leading
whitespace from an input stream \(\rightarrow\)
<a href="https://en.cppreference.com/w/cpp/named_req/UnformattedInputFunction"><code>unformatted input function</code></a></p>
</li>
</ul>
<p><code>&lt;ostream&gt;</code> declares 3 manipulators:</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/io/manip/flush"><code>flush</code></a> flushes the
stream <em>ie:</em> writes all unwritten data on the stream buffer to the peripheral
(file, string, whatever else), <code>unitbuf</code> performs a flush after each operation.</li>
<li><a href="https://en.cppreference.com/w/cpp/io/manip/endl"><code>endl</code></a>
inserts a newline character into the output stream and flushes it.</li>
<li><a href="https://en.cppreference.com/w/cpp/io/manip/ends"><code>ends</code></a>
inserts a null character into the output stream, does not flush.</li>
</ul>
<p><a href="https://en.cppreference.com/w/cpp/io/manip/setw"><code>setw(n)</code></a>
(declared in <code>&lt;iomanip&gt;</code>) specifies that the next operation should use a width <code>n</code>.
If write: shorter than <code>n</code> will be padded with the filler char set by</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/io/manip/setfill"><code>setfill</code></a>, longer won't be
troncated.</li>
<li>If read: shorter than <code>n</code> is read entirely, longer is troncated (unless numeric).</li>
</ul>
<p><a href="https://en.cppreference.com/w/cpp/io/manip/setbase"><code>setbase</code></a>
sets the numeric base of the stream.</p>
<p><a href="https://en.cppreference.com/w/cpp/io/manip/setfill"><code>setfill</code></a> is self
explanatory ... bruh.</p>
<p><a href="https://en.cppreference.com/w/cpp/io/manip/setprecision"><code>setprecision</code></a>
set the precision used to write or read floating point types, see the page
reference examples.</p>
<p>Formatted io for basic types is symmetic: a value written with <code>&lt;&lt;</code> can
be read with <code>&gt;&gt;</code> (without loss of information). The only exception is the string
class: the <code>&lt;&lt;</code> operator writes the whole string, but the <code>&gt;&gt;</code> operator only
reads a word into the string.</p>
<p>The <a href="https://en.cppreference.com/w/cpp/io/manip/quoted"><code>quoted</code></a>
allows insertion and extraction of quoted strings,
such as the ones found in csv, json or xml.</p>
<pre><code class="language-cpp">#include &lt;iomanip&gt;
#include &lt;iostream&gt;

int main(){
  std::string s, q = &quot;c++ is fabulous&quot;;

  std::stringstream flow;
  flow &lt;&lt; q;
  flow &gt;&gt; s;
  std::cout &lt;&lt; s &lt;&lt; std::endl; // prints: c++

  std::stringstream qflow; // implicit &quot;
  qflow &lt;&lt; std::quoted(q);
  qflow &gt;&gt; std::quoted(s);
  std::cout &lt;&lt; s &lt;&lt; std::endl; // prints: c++ is fabulous

  std::stringstream bflow;
  bflow &lt;&lt; std::quoted(q, '|');
  bflow &gt;&gt; std::quoted(s, '|');
  std::cout &lt;&lt; s &lt;&lt; std::endl; // prints: c++ is fabulous

  std::stringstream xflow;
  xflow &lt;&lt; std::quoted(q, '&lt;', '&gt;');
  xflow &gt;&gt; std::quoted(s, '&lt;', '&gt;');
  std::cout &lt;&lt; s &lt;&lt; std::endl; // prints: c++ is fabulous

  return 0;
}
</code></pre>
<p>To create a paramterless output manipulator use the 18-20 overload
of the <a href="https://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt"><code>&lt;&lt;</code></a>
operator of the <code>basic_ostream</code> class.</p>
<pre><code class="language-cpp">// prototype
std::basic_ostream&amp; operator&lt;&lt;(
    std::basic_ostream&lt;CharT, Traits&gt;&amp; (*func)
        (std::basic_ostream&lt;CharT, Traits&gt;&amp;) );
// so if a function manip is declared as
std::ostream&amp; manip(std::ostream&amp;);
// the expression 
flow &lt;&lt; manip; // is equivalent to
manip(flow);
</code></pre>
<p>Example:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;ostream&gt;

template&lt;typename C, typename T&gt;
std::basic_ostream&lt;C,T&gt;&amp; compilation_date(std::basic_ostream&lt;C,T&gt;&amp; os){
  return os &lt;&lt; __DATE__ &lt;&lt; &quot; &quot; &lt;&lt; __TIME__ &lt;&lt; std::flush;
}

int main(){
  std::cout &lt;&lt; &quot;Version : &quot; &lt;&lt; compilation_date;
  std::endl(std::cout); // equivalent to
  std::cout &lt;&lt; std::endl;
  return 0;
}
</code></pre>
<p>Left and right shift nonsense</p>
<pre><code class="language-cpp">std::cout &lt;&lt; (4&lt;&lt;2) &lt;&lt; std::endl; // equivalent to 4 * 2^2
std::cout &lt;&lt; (8&gt;&gt;2) &lt;&lt; std::endl; // equivalent to 8 / 2^2
</code></pre>
<p>Lambda expressions in C++: C++11 onwards</p>
<ul>
<li>the return type is automatically is automagically deduced by the compiler.</li>
</ul>
<pre><code class="language-cpp">auto f = [](const char *s=&quot; default\n&quot;){std::cout &lt;&lt; 42 &lt;&lt; s &lt;&lt; std::endl;};
f(); // prints: 42 default
f(&quot; not default&quot;); // prints: 42 not default
[](int n){std::cout &lt;&lt; n &lt;&lt; std::endl;}(32); // prints: 32
</code></pre>
<p>Use <code>decltype(name)</code> to get the type of a lambda function named <code>name</code> (often
declared auto). Two lambda expressions, even if having the exact same definitions
don't have the same type. In a generic context, we need to name a lambda expression
to use its type as a template parameter.</p>
<p>Starting from C++17, the compiler can infer the template parameters of an instance
from the types of the constructor real parameters. So can do dis:</p>
<pre><code class="language-cpp">auto lam = [](int n){return 2*n};
Feval&lt;int, decltype(lam)&gt; f(2, lam);
Feval f(2, lam); // works and is equivalent to 
Feval f(2, [](int n){return 2*n;}); // dis
</code></pre>
<p>Starting from C++14, lambda parameters can be auto: works as if there was
a generic type for each <code>auto</code> parameter.</p>
<pre><code class="language-cpp">auto maxi = [](auto a, auto b){
  if(a&gt;b) return a; else return b;
};

std::cout &lt;&lt; maxi(1, 3) &lt;&lt; std::endl; // prints: 3
std::cout &lt;&lt; maxi(1, 0) &lt;&lt; std::endl; // prints: 1
std::cout &lt;&lt; maxi('a', 'c') &lt;&lt; std::endl; // prints: c
std::cout &lt;&lt; maxi(1, 3.14) &lt;&lt; std::endl; // does not compile
// maxi would have to return either a or b of type int or double -- incompatible
// &quot; Inconsistent types 'double' and 'int'
</code></pre>
<p>to force a lambda to return a type:</p>
<pre><code class="language-cpp">auto maxi = [](auto a, auto b) -&gt; decltype(a) {
  if(a&gt;b) return a; else return b;
};
std::cout &lt;&lt; maxi(1, 3.14) &lt;&lt; std::endl; // now compiles and prints: 3
</code></pre>
<p>Other example</p>
<pre><code class="language-cpp">auto div3 = [](int n=3) -&gt; bool {
  return n%3==0;
};
std::cout &lt;&lt; div3() &lt;&lt; std::endl; // prints: 1
std::cout &lt;&lt; div3(43) &lt;&lt; std::endl; // prints: 0
</code></pre>
<p>A lambda can access all global and <code>static</code> local variables in the scope in
which it is defined. To capture a (nonstatic!) variable in the local context,
use the <code>[]</code> operator to specify what local entities to capture:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
  int x = 1, y = 2, w = 3;
  auto impure = [=]() {
    std::cout &lt;&lt; x &lt;&lt; std::endl;
  }; // total capture, can use x, y, w and any variable defined in main are
     // accessible to impure
  impure(); // prints: 1
  auto heathen = [w, y](int k = 0) {
    std::cout &lt;&lt; w + k &lt;&lt; y + k &lt;&lt; std::endl;
  }; // selective capture, can only use w, y and global or static local
     // variables.
  heathen(2); // prints: 54
  // auto stoopid = [x, w]() {
  //   return x + y;
  // }; // has no access to y, so skoozy no compilo, no habla ingles
  x = 3;
  impure(); // prints: 1
  // x was captured with value 1, at the definition of impure, not at this call
  auto smort = [k = x, n = y]() {
    std::cout &lt;&lt; k &lt;&lt; n &lt;&lt; std::endl;
  }; // rename param
  smort(); // prints: 3

  auto modx = [&amp;]() { x = 7; }; // total reference capture, can modify all
                                // variables in the calling context.
  std::cout &lt;&lt; x &lt;&lt; std::endl;
  modx(); // modifies x
  std::cout &lt;&lt; x &lt;&lt; std::endl;

  int nonsense1 = 2, nonsense2 = 1;
  auto affine = [&amp;a = nonsense1, &amp;b = nonsense2](int x) {
    return a * x + b;
  }; // selective reference capture with renaming
  std::cout &lt;&lt; affine(0) &lt;&lt; std::endl; // prints: 1
  std::cout &lt;&lt; affine(3) &lt;&lt; std::endl; // prints: 7

  return 0;
}
</code></pre>
<p>Reference captures can cause UB.</p>
<pre><code class="language-cpp">double *nonsense = new double(3);
auto mulNonsense = [&amp;a = *nonsense](double x) { return a * x; };
std::cout &lt;&lt; mulNonsense(4.0) &lt;&lt; std::endl; // prints: 12.0
delete nonsense;
std::cout &lt;&lt; mulNonsense(4.0)
          &lt;&lt; std::endl; // UB, dangling reference used in lambda
</code></pre>
<p>Avoid three things with lambdas:</p>
<ul>
<li>functions that return lambdas that capture by reference
any elements of the function context.</li>
<li>a lambda capturing references of the current context is stored for futher use
(using the generic
<a href="https://en.cppreference.com/w/cpp/utility/functional/function"><code>function</code></a>
wrapper for example).</li>
<li>thread shenanigans with lambdas capturing by reference.</li>
</ul>
<pre><code class="language-cpp">// an example of a mixed capture
#include &lt;iostream&gt;

int main() {
  int x = 32, y = 3;
  std::cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; &quot; y=&quot; &lt;&lt; y &lt;&lt; std::endl; // prints: x=32 y=3
  [&amp;a = x, b = y]() { a = b;}();
  std::cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; &quot; y=&quot; &lt;&lt; y &lt;&lt; std::endl; // prints: x=3 y=3
  return 0;
}
</code></pre>
<p>An example of relevant uses of lambdas:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

// the common reduce function common in the functional paradigm
// T is a type, BinF is a callable object with the parameters (T,T) which return a T
template &lt;typename T, typename F&gt; 
// init is the initial value, list contains the other values in the calculation
T reduce(T list[], int n, T init, F f) { 
  for (int i = 0; i &lt; n; i++){
    init = f(init, list[i]);
  }
  return init;
}
int main() {
  int v[] = {1, 2, 3, 4, 5, 6, 7, 8};
  int nv = sizeof(v) / sizeof(*v); // number of values in v
  int r1 = reduce(v, nv, 0, [](int a, int b) { return a + b; });
  // performs summations, prints: 36
  int r2 = reduce(v, nv, 1, [](int a, int b) { return a * b; });
  // performs products, prints: 40320
  int r3 = reduce(v, nv, 0, [](int a, int b) { return a ^ b; });
  // performs consecutive xor's (checksum), prints: 8
  std::cout &lt;&lt; r1 &lt;&lt; &quot; &quot; &lt;&lt; r2 &lt;&lt; &quot; &quot; &lt;&lt; r3 &lt;&lt; std::endl;
  return 0;
}
</code></pre>
<p>Let <code>M</code> &gt; <code>N</code> and <code>f</code> be a function of <code>M</code> parameters. Currying is the
process of creating a function <code>g</code> of <code>N</code> parameters by fixing <code>M-N</code> parameters
in <code>f</code>.</p>
<p>example:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
  // lambda returning lambda
  auto in = [](auto min, decltype(min) max) {
    return [min, max](decltype(min) valeur) -&gt; bool {
      return valeur &gt;= min &amp;&amp; valeur &lt;= max;
    };
  };

  auto lowercase = in('a', 'z');
  std::cout &lt;&lt; std::boolalpha &lt;&lt; lowercase('v') &lt;&lt; std::endl; // prints: true
  std::cout &lt;&lt; lowercase('V') &lt;&lt; std::endl;                   // prints: false

  auto proba = in(0.0, 1); // is a valid probability value
  std::cout &lt;&lt; proba(2) &lt;&lt; std::endl; // prints: false
  std::cout &lt;&lt; proba(0) &lt;&lt; std::endl; // prints: true
  std::cout &lt;&lt; proba(1) &lt;&lt; std::endl; // prints: true
  std::cout &lt;&lt; proba(0.4) &lt;&lt; std::endl; // prints: true
  return 0;
}
</code></pre>
<p>The Standard Template Library contains</p>
<ul>
<li>Algorithms</li>
<li>Containers (~15 class templates)</li>
<li>Iterators</li>
</ul>
<p><a href="https://en.cppreference.com/w/cpp/container/list"><code>std::list</code></a> implements a
bidirectional linked list.</p>
<p>An iterator is a pointer-like object used to cycle through all
the elements stored in a container.
Iterators are a standard way to access a container. Each container type <code>X</code>
provides a type <code>X::iterator</code> to access its elements. The <code>begin()</code> method
returns an iterator that points to the first element of the container. Its value
can be accessed by using the <code>*</code> operator as if it was a pointer dereference.
The <code>++</code> operator applied (suffix or prefix) to an iterator goes to the next
element in the container.</p>
<p>ITERATORS ARE NOT POINTERS.</p>
<p>All containers offer at least the <code>begin()</code> and <code>end()</code> methods.</p>
<p>Careful, The <code>end()</code> method returns an iterator to the element
following the last element, not the last element.</p>
<p>NEVER DEREFERENCE THE OPERATOR RETURNED BY <code>end()</code>.</p>
<p>However, one can compare that iterator with another iterator of the same type
and pointing to an element of the same container.</p>
<p>We can iterate through a container by using an iterator that goes through
\([c.begin(), c.end()[\)</p>
<p>Application</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;vector&gt;

template &lt;typename C&gt; void displayAll(C &amp;c) {
  // C::iterator it; // does'nt work, compiler does'nt know that C::iterator is
  // a type and not a member of class C
  typename C::iterator it; // specify explicitly that C::iterator is a type, and
                           // declare it to be of that type
  for (it = c.begin(); it != c.end(); it++)
    std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
  // // or in C++11 onward:
  // for(auto it = c.begin(); it!=c.end(); it++)
  //   std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
  std::cout &lt;&lt; std::endl;
}

int main() {
  std::list&lt;double&gt; li = {1, 2, 3, 4};
  std::vector&lt;double&gt; ve = {20, 30, 70};
  displayAll(li); // prints: 1 2 3 4
  displayAll(ve); // prints: 20 30 70
  return 0;
}
</code></pre>
<p>There is not necessarily an order relation between iterators, USE <code>!=c.end()</code> and
not <code>&lt;c.end()</code>.</p>
<p>If there is no need to modify the container elements, use a
<a href="https://en.cppreference.com/w/cpp/iterator/basic_const_iterator"><code>const_iterator</code></a></p>
<pre><code class="language-cpp">template &lt;typename C&gt; void displayAll(const C &amp;c) {
  for(auto it = c.begin(); it!=c.end(); it++) // it is a const_iterator
    std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
  std::cout &lt;&lt; std::endl;
}
</code></pre>
<table><thead><tr><th> Iterator form </th><th> Description </th></tr></thead><tbody>
<tr><td> input iterator </td><td> Read only, forward moving </td></tr>
<tr><td> output iterator </td><td> Write only, forward moving </td></tr>
<tr><td> forward iterator </td><td> Both read and write, forward moving </td></tr>
<tr><td> bidirectional iterator </td><td> Read and write, forward and backward moving </td></tr>
<tr><td> random access iterator </td><td> Read and write, Red and write, random access </td></tr>
</tbody></table>
<p><img src="media/iterator_examples.png" width=400 /></p>
<p>There are three principal types of iterators:</p>
<ul>
<li>Iterators that move forward (
<a href="https://en.cppreference.com/w/cpp/iterator/input_iterator"><code>input_iterator</code></a>,
<a href="https://en.cppreference.com/w/cpp/iterator/output_iterator"><code>output_iterator</code></a> and
<a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator"><code>forward_iterator</code></a>
) and the associated named requirements. operators: <code>++</code>, <code>*</code>, <code>==</code>, <code>!=</code>.
More details on the
<a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator"><code>forward_iterator</code></a>
can be found on
<a href="https://www.quora.com/Whats-the-difference-between-an-InputIterator-and-a-ForwardIterator"><code>Quora</code></a>,
<a href="https://docs.oracle.com/cd/E19422-01/819-3703/2_2.htm"><code>Oracle Docs</code></a> and
<a href="https://cplusplus.com/reference/iterator/ForwardIterator/"><code>CPlusPlus.com</code></a>.</li>
<li>Bidirectional Iterators  like
<a href="https://en.cppreference.com/w/cpp/iterator/bidirectional_iterator"><code>bidirectional_iterator</code></a>
also implement the <code>--</code> operator.</li>
<li>Random Access Iterators implement the <code>[]</code>, <code>+</code>, <code>+=</code>, <code>-</code>, <code>-=</code>, <code>&lt;</code>, <code>&lt;=</code>,
<code>&gt;</code> , <code>&gt;=</code> on top of the other usual operators. There exists an order relation
among Random Access Iterators of a container.
An example is the the <code>std::vector::iterator</code> class and
<a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator"><code>std::random_access_iterator</code></a>.</li>
</ul>
<p>Output iterators are never constant, and input iterators always are.</p>
<p>Ordinary pointers are random access iterators, which are a superset of output
iterators.</p>
<p>See <a href="https://cplusplus.com/reference/iterator/"><code>CPlusPlus.com</code></a>,
<a href="https://docs.oracle.com/cd/E19422-01/819-3703/2.htm"><code>Oracle Docs</code></a> and
<a href="https://cplusplus.com/reference/iterator/"><code>CPlusPlus.com</code></a> for a general
view of iterators. (especially the Oracle Docs, good stuff).</p>
 <!-- VECTOR -->
<p><a href="https://en.cppreference.com/w/cpp/container/vector"><code>std::vector</code></a> is a dynamic
size array.</p>
<p><code>Vector&lt;T, A&gt;</code> T is the type of the elements stored, A is the type of the allocators
that can manage the memory of the elements.</p>
<p>Useful constuctors of the <code>vector</code> class:</p>
<pre><code class="language-cpp">// empty vector
std::vector&lt;int&gt; vi;
// vector initialized with 7 elements equal to 3
std::vector&lt;int&gt; vd(7, 3);
// vector initialized with initializer list
std::vector&lt;int&gt; vil({1,2,3,4});
// vector initialized with initializer list 
std::vector&lt;int&gt; wil = {1,2,3,4};
// vector initialized with the copy constructor
std::vector&lt;int&gt; cwil=wil;
// vector initialized with the copy constructor (same)
std::vector&lt;int&gt; c2wil(wil);
</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

class X {
  double x_;
  char c_;

public:
  X(double x, char c = 'c') : x_(x), c_(c) {}
  friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const X &amp;x) {
    return os &lt;&lt; x.c_ &lt;&lt; &quot;:&quot; &lt;&lt; x.x_;
  }
};

template &lt;typename T&gt;
std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, std::vector&lt;T&gt; v) {
  os &lt;&lt; &quot;{&quot;;
  for (auto val = v.begin(); val != v.end(); val++) {
    os &lt;&lt; *val &lt;&lt; &quot;,&quot;;
  }
  return os &lt;&lt; &quot;}&quot;;
}

int main() {
  std::vector&lt;X&gt; v;
  // construct at the end of the vector
  v.emplace_back(2, '3');
  std::cout &lt;&lt; v &lt;&lt; std::endl; // prints: {3:2,}
  // insert at the end of the vector
  v.push_back(X(2));
  std::cout &lt;&lt; v &lt;&lt; std::endl; // prints: {3:2, c:2}
  // insert using a back insert iterator,
  std::back_insert_iterator&lt;std::vector&lt;X&gt;&gt; i(v);
  // litteraly just calls push_back according to the doc
  *i++ = X(3.14);
  *i++ = X(1. / 2);
  std::cout &lt;&lt; v &lt;&lt; std::endl; // prints: {3:2,c:2,c:3.14,c:0.5,}
  
  // insert using an insert iterator, start inserting at start+2
  std::insert_iterator&lt;std::vector&lt;X&gt;&gt; ia(v, v.begin()+2);
  // litteraly just calls insert at 2 according to the doc
  *ia++ = X(13);
  std::cout &lt;&lt; v &lt;&lt; std::endl; // prints: {3:2,c:2,c:13,c:3.14,c:0.5,}
  return 0;
}
</code></pre>
<p><a href="https://en.cppreference.com/w/cpp/container/vector/emplace_back"><code>emplace_back</code></a>
passes its arguments to the constructor of the class, it creates a new object and
appends it. This saves the cost of copying an intermediary object.</p>
<p>See more on the
<a href="https://en.cppreference.com/w/cpp/iterator/back_insert_iterator"><code>back_insert_iterator</code></a>
and
<a href="https://en.cppreference.com/w/cpp/iterator/insert_iterator"><code>insert_iterator</code></a>.</p>
<p>Vector elements can be accessed:</p>
<ul>
<li>with the
<a href="https://en.cppreference.com/w/cpp/container/vector/at"><code>at</code></a>
method; accessess the elements at the specified index, it returns a reference to
it. throws an
<a href="https://en.cppreference.com/w/cpp/error/out_of_range"><code>std::out_of_range</code></a>
exception if incompatible index.</li>
<li>the <code>[]</code> operator; UB if index incompatible index.</li>
<li>by dereferencing an iterator pointing to some vector element. UB if invalid.</li>
<li>using a range based for loop (C++&gt;=11)</li>
<li>using the
<a href="https://en.cppreference.com/w/cpp/container/vector/front"><code>front</code></a> and
<a href="https://en.cppreference.com/w/cpp/container/vector/back"><code>back</code></a> methods
which return references to the first and last element in the vector.</li>
</ul>
<pre><code class="language-cpp">std::vector&lt;int&gt; v(3,5);
for(const auto&amp; val : v) // uses iterators in the background
  std::cout &lt;&lt; val &lt;&lt; std::endl;
</code></pre>
<p>Vector elements are necessarily contiguous in memory (dictated by the C++
standard).</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; v({1,2,3,4,5});
int *p = v.data();
std::cout &lt;&lt; *p &lt;&lt; std::endl; // prints: 1
p = &amp;v[3];
std::cout &lt;&lt; *p &lt;&lt; std::endl; // prints: 4
std::cout &lt;&lt; *(&amp;v[0] + 3) &lt;&lt; std::endl; // prints: 4
</code></pre>
<p>Use the
<a href="https://en.cppreference.com/w/cpp/container/vector/front"><code>capacity()</code></a> method
to get the storage size of that array (always &gt;= #elems).</p>
<p>Use the
<a href="https://en.cppreference.com/w/cpp/container/vector/resize"><code>resize(newsize, optional filler)</code></a>
method to resize the vector container and fill the new elements with a filler
default value.</p>
<p>Application: using a pointer to traverse a vector</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; v({1,2,3,4,5});
auto p = &amp;v[0];
auto pmax = p+v.size();
for(; p!=pmax; p++)
  std::cout &lt;&lt; *p &lt;&lt; &quot; &quot;; // prints: 1 2 3 4 5
</code></pre>
<table><thead><tr><th>operation</th><th>cost</th></tr></thead><tbody>
<tr><td>memory</td><td>\(\propto N\) </td></tr>
<tr><td>insertion at the front</td><td>\(\propto N\) </td></tr>
<tr><td>insertion at the back</td><td> Constant (and cheap)</td></tr>
<tr><td>insertion at position \(p\)</td><td> \(\propto (N-p)\)</td></tr>
<tr><td>deletion at the front</td><td>\(\propto N\) </td></tr>
<tr><td>deletion at the back</td><td> Constant (and cheap)</td></tr>
<tr><td>deletion at position \(p\)</td><td> \(\propto (N-p)\)</td></tr>
<tr><td>access via index</td><td> Constant (and very cheap)</td></tr>
<tr><td>reference and pointer invalidation on modification</td><td> YES ⚠️ </td></tr>
<tr><td>iterator invalidation on modification</td><td> YES ⚠️ </td></tr>
</tbody></table>
 <!-- DEQUE -->
<p><a href="https://en.cppreference.com/w/cpp/container/deque"><code>std::deque</code></a>
is double-ended
queue. Insertions and deletions at the front and back are constant time.</p>
<p>The elements of a deque are not contiguous in memory \( \rightarrow \) can't
iterate with a pointer.</p>
<p>Some useful constructors for a deque</p>
<pre><code class="language-cpp">// empty deque
std::deque&lt;int&gt; di;
// deque containing 10 elements all with value 5
std::deque&lt;int&gt; dd(10, 5);
// deque initialized with an initializer_list
std::deque&lt;int&gt; dil1({1, 2, 3, 4, 5});
// deque initialized with an initializer_list (same)
std::deque&lt;int&gt; dil2 = {1, 2, 3, 4, 5};
// cloning constructor
std::deque&lt;int&gt; dc1(di);
// cloning constructor (same)
std::deque&lt;int&gt; dc2=di;
</code></pre>
<p><code>deque</code> provides the
<a href="https://en.cppreference.com/w/cpp/container/deque/push_back"><code>push_back</code></a>,
<a href="https://en.cppreference.com/w/cpp/container/deque/emplace_back"><code>emplace_back</code></a>,
<a href="https://en.cppreference.com/w/cpp/container/deque/push_front"><code>push_front</code></a> and the
<a href="https://en.cppreference.com/w/cpp/container/deque/emplace_front"><code>emplace_front</code></a>
methods.</p>
<p>we can also use
<a href="https://en.cppreference.com/w/cpp/iterator/back_insert_iterator"><code>back_insert_iterator</code></a>,
<a href="https://en.cppreference.com/w/cpp/iterator/front_insert_iterator"><code>front_insert_iterator</code></a>,
<a href="https://en.cppreference.com/w/cpp/iterator/insert_iterator"><code>insert_iterator</code></a>,
for example:</p>
<pre><code class="language-cpp">// assume di is an empty deque&lt;int&gt;
std::back_insert_iterator&lt;std::deque&lt;int&gt;&gt; i(di); 
*i++ = 100;
*i++ = 299;
for (const auto &amp;val : di)
  std::cout &lt;&lt; val &lt;&lt; &quot; &quot;; // prints: 100 299
std::cout &lt;&lt; std::endl;

std::front_insert_iterator&lt;std::deque&lt;int&gt;&gt; fi(di); 
*fi++ = 0;
*fi++ = 1;
for (const auto &amp;val : di)
  std::cout &lt;&lt; val &lt;&lt; &quot; &quot;; // prints: 1 0 100 299
std::cout &lt;&lt; std::endl;

std::insert_iterator&lt;std::deque&lt;int&gt;&gt; ii(di, di.begin()+2);
*ii++ = -1;
*ii++ = -2;
for (const auto &amp;val : di)
  std::cout &lt;&lt; val &lt;&lt; &quot; &quot;; // prints: 1 0 -1 -2 100 299
std::cout &lt;&lt; std::endl;
</code></pre>
<p>Deque elements can be accessed:</p>
<ul>
<li>using the
<a href="https://en.cppreference.com/w/cpp/container/deque/at"><code>at</code></a>
method; accessess the elements at the specified index, it returns a reference to
it. throws an
<a href="https://en.cppreference.com/w/cpp/error/out_of_range"><code>std::out_of_range</code></a>
exception if incompatible index.</li>
<li>using the <code>[]</code> operator; UB if index incompatible index.</li>
<li>by dereferencing an iterator pointing to some vector element. UB if invalid.</li>
<li>using a range based for loop (C++&gt;=11) // same as with vector, no example here</li>
<li>using the
<a href="https://en.cppreference.com/w/cpp/container/deque/front"><code>front</code></a> and
<a href="https://en.cppreference.com/w/cpp/container/deque/back"><code>back</code></a> methods
which return references to the first and last element in the deque.</li>
</ul>
<p>// not done</p>
<table><thead><tr><th>operation</th><th>cost</th></tr></thead><tbody>
<tr><td>memory</td><td>\(\propto N\) (&gt; vector) </td></tr>
<tr><td>insertion at the front</td><td>Constant (and cheap) </td></tr>
<tr><td>insertion at the back</td><td> Constant (and cheap)</td></tr>
<tr><td>insertion at position \(p\)</td><td> \(\propto N\)</td></tr>
<tr><td>deletion at the front</td><td> Constant (and cheap)</td></tr>
<tr><td>deletion at the back</td><td> Constant (and cheap)</td></tr>
<tr><td>deletion at position \(p\)</td><td> \(\propto N\)</td></tr>
<tr><td>access via index</td><td> Constant (&gt;vector)</td></tr>
<tr><td>reference and pointer invalidation on modification</td><td> NO ✅️ </td></tr>
<tr><td>iterator invalidation on modification</td><td> YES ⚠️ </td></tr>
</tbody></table>
<p>Use a deque when operations at the front are common and the number of elements
is high.</p>
<p>An <a href="https://en.cppreference.com/w/cpp/container/array"><code>std::array&lt;T, N&gt;</code></a>
cannot be extended.</p>
<p>Useful constructors:</p>
<pre><code class="language-cpp">std::array&lt;int,5&gt; a0;
for(const auto&amp; x:a0) std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; 
// prints: whatever was stored there before, garbage
std::cout &lt;&lt; std::endl;

std::array&lt;int,5&gt; a1 = {1,2,3,4};
// std::array&lt;int,5&gt; a1({1,2,3,4}); // equivalent
for(const auto&amp; x:a1) std::cout &lt;&lt; x &lt;&lt; &quot; &quot;;
// prints: 1 2 3 4 0
std::cout &lt;&lt; std::endl;

// std::array&lt;int, 5&gt; a2 = {1,2,3,4,5,6}; // compilation error

std::array&lt;int, 5&gt; c(a1); // cloning constructor
for(const auto&amp; x:c) std::cout &lt;&lt; x &lt;&lt; &quot; &quot;;
// prints: 1 2 3 4 0
std::cout &lt;&lt; std::endl;
</code></pre>
<p>The logical size of an <code>array</code> is always equal to its physical size.
Can't insert elements, can overwrite.</p>
<p>Array elements can be accessed:</p>
<ul>
<li>using the
<a href="https://en.cppreference.com/w/cpp/container/array/at"><code>at</code></a>
method; accessess the elements at the specified index, it returns a reference to
it. throws an
<a href="https://en.cppreference.com/w/cpp/error/out_of_range"><code>std::out_of_range</code></a>
exception if incompatible index.</li>
<li>using the <code>[]</code> operator; UB if index incompatible index.</li>
<li>by dereferencing an iterator pointing to some array element, UB if invalid.</li>
<li>using a range based for loop (C++&gt;=11)</li>
<li>using the
<a href="https://en.cppreference.com/w/cpp/container/array/front"><code>front</code></a> and
<a href="https://en.cppreference.com/w/cpp/container/array/back"><code>back</code></a> methods
which return references to the first and last element in the array.</li>
<li>using the
<a href="https://en.cppreference.com/w/cpp/container/array/data"><code>data</code></a> method, which:
returns a pointer to the underlying array serving as element storage.
The pointer is such that range <code>[data(), data() + size()]</code> is always a valid
range, even if the container is empty (<code>data()</code> is not dereferenceable
in that case).</li>
</ul>
<p>Contrary to a C style array, an <code>std::array</code> object is not automatically converted
to a pointer to its first element; for a function to receive an <code>std::array&lt;T, N&gt;</code>
use a formal parameter of type <code>std::array&lt;T, N&gt;</code> or <code>std::array&lt;T,N&gt;&amp;</code> but never
<code>T*</code>.</p>
<table><thead><tr><th>operation</th><th>cost</th></tr></thead><tbody>
<tr><td>memory</td><td>\(\propto N\)</td></tr>
<tr><td>insertions and deletions</td><td>NO ES POSIBLE!</td></tr>
<tr><td>access via index</td><td> Constant </td></tr>
<tr><td>reference and pointer invalidation on modification</td><td> NO ✅️ </td></tr>
<tr><td>iterator invalidation on modification</td><td> NO ✅️ </td></tr>
</tbody></table>
<p>The <code>std::array&lt;T,N&gt;</code> container is NEVER REALLOCATED.</p>
<p>Use an <code>array</code> if you want to use C style arrays with an OO interface.</p>
<p><code>std::array::size()</code> is <code>constexpr</code>. Two arrays of different sizes don't even
have the same type (bcoz template param <code>N</code> is the size).</p>
<p><a href="https://en.cppreference.com/w/cpp/string/basic_string"><code>std::basic_string&lt;C,T,A&gt;</code></a></p>
<ul>
<li><code>C</code> is the character type</li>
<li><code>T</code> is the traits type (used to manipulate objects of type <code>C</code>)</li>
<li><code>A</code> is the allocater type for type <code>C</code></li>
</ul>
<p>classes defined in <code>&lt;string&gt;</code>:</p>
<table><thead><tr><th>name</th><th>definition</th><th>encoding</th></tr></thead><tbody>
<tr><td>string</td><td>basic_string<char></td><td>ASCII</td></tr>
<tr><td>wstring</td><td>basic_string&lt;wchar_t&gt;</td><td>unicode 16 or 32</td></tr>
<tr><td>u16string</td><td>basic_string&lt;char16_t&gt;</td><td>unicode 16</td></tr>
<tr><td>u32string</td><td>basic_string&lt;char32_t&gt;</td><td>unicode 32</td></tr>
</tbody></table>
<p>characters in the string class are stored contiguously.</p>
<p>some useful constructors of <code>std::string</code></p>
<pre><code class="language-cpp">std::string s1;
std::cout &lt;&lt; &quot;[&quot; &lt;&lt; s1 &lt;&lt; &quot;]&quot; &lt;&lt; std::endl; // []
std::string s2 = &quot;abcdf fjd&quot;;
std::cout &lt;&lt; &quot;[&quot; &lt;&lt; s2 &lt;&lt; &quot;]&quot; &lt;&lt; std::endl; // [abcdf fjd]
std::string s3 = s2;
std::cout &lt;&lt; &quot;[&quot; &lt;&lt; s3 &lt;&lt; &quot;]&quot; &lt;&lt; std::endl; // [abcdf fjd]
std::string s4(s2, 4, 3);
std::cout &lt;&lt; &quot;[&quot; &lt;&lt; s4 &lt;&lt; &quot;]&quot; &lt;&lt; std::endl; // [f f]
std::string s5 = {'a', 'e', 'i', 'o', 'u', 'y'};
std::cout &lt;&lt; &quot;[&quot; &lt;&lt; s5 &lt;&lt; &quot;]&quot; &lt;&lt; std::endl; // [aeiouy]
std::string s6(6, '-');
std::cout &lt;&lt; &quot;[&quot; &lt;&lt; s6 &lt;&lt; &quot;]&quot; &lt;&lt; std::endl; // [------]
</code></pre>
<p>String characters can be accessed:</p>
<ul>
<li>using the
<a href="https://en.cppreference.com/w/cpp/string/basic_string/at"><code>at</code></a>
method; accessess the elements at the specified index, it returns a reference to
it. throws an
<a href="https://en.cppreference.com/w/cpp/error/out_of_range"><code>std::out_of_range</code></a>
exception if incompatible index.</li>
<li>using the <code>[]</code> operator; UB if index incompatible index.</li>
<li>by dereferencing an iterator pointing to some character in the string,
UB if invalid.</li>
<li>using a range based for loop (C++&gt;=11)</li>
<li>using the
<a href="https://en.cppreference.com/w/cpp/string/basic_string/front"><code>front</code></a> and
<a href="https://en.cppreference.com/w/cpp/string/basic_string/back"><code>back</code></a> methods
which return references to the first and last characters in the string.</li>
<li>using the
<a href="https://en.cppreference.com/w/cpp/string/basic_string/c_str"><code>c_str</code></a> method,
which: returns a pointer to a null-terminated character array with data
equivalent to those stored in the string (<em>ie:</em> an equivalent C style string).</li>
</ul>
<table><thead><tr><th>operation</th><th>cost</th></tr></thead><tbody>
<tr><td>memory</td><td>\(\propto N\)</td></tr>
<tr><td>insertions and deletions at the end</td><td>Constant</td></tr>
<tr><td>insertions and deletions at the beginning</td><td>\(\propto N\)</td></tr>
<tr><td>insertions and deletions at the position \(p\)</td><td>\(\propto (N-p)\)</td></tr>
<tr><td>access via index</td><td> Constant </td></tr>
<tr><td>reference and pointer invalidation on modification</td><td> YES ⚠️ </td></tr>
<tr><td>iterator invalidation on modification</td><td> YES ⚠️</td></tr>
</tbody></table>
<p><code>void f(const string&amp;);</code> accepts the parameter <code>&quot;c style string&quot;</code>, convesion
by constructor: <code>f (string(&quot;c style string&quot;))</code>. To get a <code>string</code> instance
directly, use the suffix <code>s</code> after the <code>&quot;</code>. <code>f(&quot;real string instance&quot;s)</code>,
this way no data needs to be copied.</p>
<p><a href="https://en.cppreference.com/w/cpp/container/list"><code>list&lt;T,A&gt;</code></a> and
<a href="https://en.cppreference.com/w/cpp/container/forward_list"><code>forward_list&lt;T,A&gt;</code></a>
are declared in the <code>&lt;list&gt;</code> and <code>&lt;forward_list&gt;</code> headers respectively.
They are both parametrised by:</p>
<ul>
<li><code>T</code> the type of elements stored.</li>
<li><code>A</code> the type of allocators used for 'T' (default is
<a href="https://en.cppreference.com/w/cpp/memory/allocator"><code>std::allocator&lt;T&gt;</code></a>
).</li>
</ul>
<p>typical implementation of a list (doubly linked list):</p>
<p><img src="media/list.png" width=400/></p>
<p>typical implementation of a forward_list (linked list):</p>
<p><img src="media/forward_list.png" width=400/></p>
<p>The implementations are non intrusive: the stored elements don't need to store
pointers to ther successors and predecessors.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;string&gt;

template &lt;typename T&gt; void printList(const std::list&lt;T&gt; &amp;l) {
  std::cout &lt;&lt; '[';
  for (const T &amp;e : l)
    std::cout &lt;&lt; e &lt;&lt; &quot; &quot;;
  std::cout &lt;&lt; ']' &lt;&lt; std::endl;
}

int main() {
  std::list&lt;int&gt; li1;
  printList(li1); // prints: []
  std::list&lt;std::string&gt; li2 = {&quot;first&quot;, &quot;second&quot;};
  printList(li2); // prints: [first second ]
  std::list&lt;std::string&gt; li3 = li2;
  printList(li3); // prints: [first second ]

  auto istart_li2 = li2.begin();
  auto iend_li2 = li2.end();
  // can't just do li2.begin()+1 , list has a bidirectional operator, which
  // is not a random access iterator
  istart_li2++; // ignore first element of li2
  std::list&lt;std::string&gt; li4(istart_li2, iend_li2);
  printList(li4); // prints: [second ]

  std::list&lt;double&gt; li5(4, 3.14159);
  printList(li5); // prints: [3.14159 3.14159 3.14159 3.14159 ]

  return 0;
}
</code></pre>
<p>List elements can be accessed by</p>
<ul>
<li>dereferencing an iterator pointing to some list element. UB if invalid.</li>
<li>using a range based for loop (C++&gt;=11).</li>
<li>using the
<a href="https://en.cppreference.com/w/cpp/container/list/front"><code>list::front</code></a> and
<a href="https://en.cppreference.com/w/cpp/container/list/back"><code>list::back</code></a> methods
which return references to the first and last element in the list.
(analogous methods are provided for <code>forward_list</code> ... RTFD)</li>
</ul>
<p>NO RANDOM ACCESS</p>
<p>To delete all elements in a list, use the
<a href="https://en.cppreference.com/w/cpp/container/list/clear"><code>list::clear</code></a> and
<a href="https://en.cppreference.com/w/cpp/container/forward_list/clear"><code>forward_list::clear</code></a>
methods.</p>
<p>Insert elements before an iterator's position using the
<a href="https://en.cppreference.com/w/cpp/container/list/insert"><code>insert</code></a> method.</p>
<p>For a <code>foward_list</code>, it is inefficient to insert before a specified item, thus
the <a href="https://en.cppreference.com/w/cpp/container/forward_list/insert_after"><code>insert_after</code></a>
method is provided.</p>
<p>The
<a href="https://en.cppreference.com/w/cpp/container/list/emplace"><code>emplace</code></a> and
<a href="https://en.cppreference.com/w/cpp/container/forward_list/emplace_after"><code>emplace_after</code></a>
methods play analogous roles, the elements are constructed in-place,
<em>i.e.</em> no copy or move operations are performed.
The constructor of the element is called with exactly the same arguments,
as supplied to the function.</p>
<p>The
<a href="https://en.cppreference.com/w/cpp/container/list/push_back"><code>list::push_back</code></a>,
<a href="https://en.cppreference.com/w/cpp/container/list/emplace_back"><code>list::emplace_back</code></a>,
<a href="https://en.cppreference.com/w/cpp/container/forward_list/push_back"><code>forward_list::push_back</code></a>
and
<a href="https://en.cppreference.com/w/cpp/container/forward_list/emplace_back"><code>forward_list::emplace_back</code></a>
methods can be used to add an element to the end of a list (or construct one).</p>
<p>The
<a href="https://en.cppreference.com/w/cpp/container/list/pop_back"><code>list::pop_back</code></a>,
methods can be used to remove the last element in the list.</p>
<p>The
<a href="https://en.cppreference.com/w/cpp/container/list/push_front"><code>list::push_front</code></a>,
<a href="https://en.cppreference.com/w/cpp/container/list/emplace_front"><code>list::emplace_front</code></a>,
<a href="https://en.cppreference.com/w/cpp/container/list/pop_front"><code>list::pop_front</code></a>,
<a href="https://en.cppreference.com/w/cpp/container/forward_list/push_front"><code>forward_list::push_front</code></a>,
<a href="https://en.cppreference.com/w/cpp/container/forward_list/emplace_front"><code>forward_list::emplace_front</code></a>
and
<a href="https://en.cppreference.com/w/cpp/container/forward_list/pop_front"><code>forward_list::pop_front</code></a>
methods can respectively: add, construct and remove the first element in a list
or forward_list.</p>
<p>// not done 448
Some algorithms provided as methods for lists and forward_lists:</p>
<ul>
<li>the
<a href="https://en.cppreference.com/w/cpp/container/list/merge"><code>list::merge</code></a> and
<a href="https://en.cppreference.com/w/cpp/container/forward_list/merge"><code>forward_list::merge</code></a>
can merge two sorted lists. No elements are copied, and the passed in container
becomes empty after the merge.</li>
<li>the
<a href="https://en.cppreference.com/w/cpp/container/list/splice"><code>list::splice</code></a> and
<a href="https://en.cppreference.com/w/cpp/container/forward_list/splice_after"><code>forward_list::splice_after</code></a>
methods transfer elements from one list to another.
No elements are copied or moved, only the internal pointers of the list nodes
are re-pointed. The elements are inserted respectively before and after the
element pointed to by the passed in iterator .</li>
<li>the
<a href="https://en.cppreference.com/w/cpp/container/list/sort"><code>list::sort</code></a> and
<a href="https://en.cppreference.com/w/cpp/container/forward_list/sort"><code>forward_list::sort</code></a>
methods sort the list elements while preserving the order of equivalent elements.
Uses the <code>operator&lt;</code> or the passed in <code>compare</code> parameter, which has to satisfy
the <a href="https://en.cppreference.com/w/cpp/named_req/Compare"><code>Compare</code></a> named
requirement.</li>
<li>the
<a href="https://en.cppreference.com/w/cpp/container/list/remove"><code>list::remove</code></a>,
<a href="https://en.cppreference.com/w/cpp/container/forward_list/remove"><code>forward_list::remove</code></a>,
<a href="https://en.cppreference.com/w/cpp/container/list/remove"><code>list::remove_if</code></a> and
<a href="https://en.cppreference.com/w/cpp/container/forward_list/remove"><code>forward_list::remove_if</code></a>
methods remove all elements that are <code>==</code> to the passed in value, or satisfy the
passed in <code>UnaryPredicate</code> parameter which must satisfy the
<a href="https://en.cppreference.com/w/cpp/named_req/Predicate"><code>Predicate</code></a> named requirement.</li>
<li>the
<a href="https://en.cppreference.com/w/cpp/container/list/reverse"><code>list::reverse</code></a> and
<a href="https://en.cppreference.com/w/cpp/container/forward_list/reverse"><code>forward_list::reverse</code></a>
methods reverse the order of the elements in the list. No references or iterators
become invalidated.</li>
<li>the
<a href="https://en.cppreference.com/w/cpp/container/list/unique"><code>list::unique</code></a> and
<a href="https://en.cppreference.com/w/cpp/container/forward_list/unique"><code>forward_list::unique</code></a>
methods remove all consecutive duplicate elements from the list.
Only the first element in each group of equal elements is left.
Invalidates only the iterators and references to the removed elements.</li>
</ul>
<p>Example:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;list&gt;

int main() {
  std::list&lt;int&gt; l({2, 3, 4, 4, 3, 4, 4, 4, 5, 6, 1, 1, 1, 1, 2});
  for (const auto &amp;val : l)
    std::cout &lt;&lt; val &lt;&lt; &quot; &quot;;
  std::cout &lt;&lt; std::endl;
  // prints: 2 3 4 4 3 4 4 4 5 6 1 1 1 1 2

  l.unique();

  for (const auto &amp;val : l)
    std::cout &lt;&lt; val &lt;&lt; &quot; &quot;;
  std::cout &lt;&lt; std::endl;
  // prints: 2 3 4 3 4 5 6 1 2

  return 0;
}
</code></pre>
<table><thead><tr><th>operation</th><th>cost</th></tr></thead><tbody>
<tr><td>memory</td><td>\(\propto N\) (&gt; vector)</td></tr>
<tr><td>insertion and deletion at each point</td><td>constant</td></tr>
<tr><td>reference and pointer invalidation on modification</td><td> NO ✅️ </td></tr>
<tr><td>iterator invalidation on modification</td><td> NO ✅️ </td></tr>
</tbody></table>
<p>Use <code>list</code> and <code>forward_list</code> if the insertion and deletion operations not to
the front and back of the container are frequent.</p>
<p>The
<a href="https://en.cppreference.com/w/cpp/container/map"><code>map&lt;K,V,C,A&gt;</code></a> and
<a href="https://en.cppreference.com/w/cpp/container/multimap"><code>multimap&lt;K,V,C,A&gt;</code></a>
structures are associative containers parametrized by</p>
<ul>
<li><code>K</code> is the type of the keys.</li>
<li><code>V</code> is the type of the values.</li>
<li><code>C</code> is the type of the comparator of the keys (<code>default=std::less&lt;K&gt;</code>).</li>
<li><code>A</code> is the type of the allocator of the of the elements
(<code>default=std::allocator&lt;std::pair&lt;const K, V&gt;&gt;</code>).</li>
</ul>
<p>The elements in a <code>map</code> or multimap are <code>std::pair&lt;const K, V&gt;</code>.</p>
<p><code>map</code> and <code>multimap</code> structures are often implemented using
<a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree"><code>red-black trees</code></a>.</p>
<p>Why is <code>std::map</code> implemented using a red black tree and not hash table ?
<a href="https://stackoverflow.com/questions/22665902/why-stdmap-is-red-black-tree-and-not-hash-table"><code>bcoz</code></a>
(history and deadlines).</p>
<p>Example usage:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;
using namespace std::literals;

int main() {
  // using an initializer_list&lt;pair&lt;const K, V&gt;&gt;
  std::map&lt;int, std::string&gt; dep = {{2, &quot;item 2&quot;s},
                                    {1, &quot;item 1&quot;s},
                                    {3, &quot;item 3&quot;s},
                                    {4, &quot;item 4&quot;s},
                                    {5, &quot;item 5&quot;s}};
  for (const auto &amp;d : dep)
    std::cout &lt;&lt; d.second &lt;&lt; &quot;-&gt;&quot; &lt;&lt; d.first &lt;&lt; std::endl;
  std::cout &lt;&lt; dep[4] &lt;&lt; std::endl;

  // prints:
  //  item 1-&gt;1
  //  item 2-&gt;2
  //  item 3-&gt;3
  //  item 4-&gt;4
  //  item 5-&gt;5
  //  item 4

  return 0;
}
</code></pre>
<p>Two keys <code>a</code> and <code>b</code> are equal if <code>!(a&lt;b) &amp;&amp; !(b&lt;a)</code> \(\iff\)
<code>!comp(a,b) &amp;&amp; !comp(b,a)</code>. <code>comp</code> has to be a strict order relation for
equality to be well defined this way.</p>
<p>Always use a strict order comparator in <code>map</code> and <code>multimap</code>, otherwise the
equality will not be well defined.</p>
<p>std::multimap is an associative container that contains a sorted list of
key-value pairs, while permitting multiple entries with the same key.</p>
<p>Sorting is done according to the comparison function Compare, applied to the
keys. Search, insertion, and removal operations have logarithmic complexity.</p>
<p>The order of the key-value pairs whose keys compare equivalent is the order of
insertion and does not change.</p>
<p>The
<a href="https://en.cppreference.com/w/cpp/container/map/operator_at"><code>std::map::operator[]</code></a>
returns a reference to the value that is mapped to a key equivalent to key or
x respectively, performing an insertion if such key does not already exist. No
equivalent exists for a <code>multimap</code>.</p>
<p>The
<a href="https://en.cppreference.com/w/cpp/container/multimap/find"><code>std::multimap::find</code></a>
and
<a href="https://en.cppreference.com/w/cpp/container/multimap/insert"><code>std::multimap::insert</code></a>
methods are sometimes useful.</p>
<p>Useful map (and multimap) constructors:</p>
<ul>
<li>with no params: empty map.</li>
<li>using an <code>initializer_list&lt;pair&lt;const K, V&gt;&gt;</code>.</li>
<li>using the cloning constructor.</li>
<li>using two iterators: partial copy of range.</li>
</ul>
<p>Inserting elements into a <code>map&lt;K,V&gt;</code> (elements are <code>pair&lt;K,V&gt;</code>).</p>
<ul>
<li>using the
<a href="https://en.cppreference.com/w/cpp/container/map/operator_at"><code>std::map::operator[]</code></a>
.</li>
<li>using the
<a href="https://en.cppreference.com/w/cpp/container/map/insert"><code>std::map::insert</code></a>
method (pass in a <code>pair&lt;K,V&gt;</code> instance).</li>
<li>using the
<a href="https://en.cppreference.com/w/cpp/container/map/emplace"><code>std::map::emplace</code></a>
method (pass in the arguments of the constructor of <code>pair&lt;K,V&gt;</code>); constructs
the element in-place in the map, saves the cost of a copy.</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;
using namespace std::literals;

int main() {
  std::vector&lt;std::pair&lt;std::string, int&gt;&gt; nonsense({{&quot;first item&quot;s, 1},
                                                     {&quot;second item&quot;s, 2},
                                                     {&quot;third item&quot;s, 3},
                                                     {&quot;fourth item&quot;s, 4}});
// use override (7) for map insert
  std::map&lt;std::string, int&gt; copnonsense(nonsense.begin(), nonsense.end());
  for (const auto &amp;val : copnonsense)
    std::cout &lt;&lt; val.first &lt;&lt; &quot;:&quot; &lt;&lt; val.second &lt;&lt; std::endl;
  //  prints:
  //    first item:1
  //    fourth item:4
  //    second item:2
  //    third item:3
  return 0;
}
</code></pre>
<ul>
<li>using the
<a href="https://en.cppreference.com/w/cpp/container/map/merge"><code>std::map::merge</code></a>
method merges two the passed in <code>map</code> into the support map, the passed in map
is empty by the end. No elements are copied or moved, only the internal
pointers of the container nodes are repointed. If there is an element in
<code>*this</code> with key equivalent to the key of an element from source, then
that element is not extracted from source.</li>
</ul>
<p>Access the elements in a map:</p>
<ul>
<li>using the
<a href="https://en.cppreference.com/w/cpp/container/map/operator_at"><code>std::map::operator[]</code></a>
method. ⚠️ if element does not exist, create it.</li>
<li>using the
<a href="https://en.cppreference.com/w/cpp/container/map/at"><code>std::map::at</code></a>
method. If the element does not exist, throws <code>std::out_of_range</code> exception.</li>
<li>using the
<a href="https://en.cppreference.com/w/cpp/container/map/find"><code>std::map::find</code></a>
and
<a href="https://en.cppreference.com/w/cpp/container/multimap/find"><code>std::multimap::find</code></a>
methods which finds an element by passed in key and returns an iterator pointing
to the associated element of <code>end()</code> if not found. For a <code>multimap</code>: if there
are several elements with the requested key in the container, any of
them may be returned.</li>
<li>using the
<a href="https://en.cppreference.com/w/cpp/container/map/equal_range"><code>std::map::equal_range</code></a>
and
<a href="https://en.cppreference.com/w/cpp/container/multimap/equal_range"><code>std::multimap::equal_range</code></a>
method returns a range containing all elements with the given key in the
container. The range is defined by two iterators, one pointing to the first
element that is not less than key and another pointing to the first element
greater than key. Alternatively, the first iterator may be obtained with
<code>lower_bound()</code>, and the second with <code>upper_bound()</code>.
If there are no elements not less than key, past-the-end (see end()) iterator
is returned as the first element. Similarly if there are no elements greater
than key, past-the-end iterator is returned as the second element.</li>
<li>using a rang-based for loop ... duh.</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;map&gt;
 
int main(){
  std::multimap&lt;int, char&gt; dict
  {
    {1, 'A'},
    {2, 'B'},
    {2, 'C'},
    {2, 'D'},
    {4, 'E'},
    {3, 'F'}
  };
 
  auto range = dict.equal_range(2);
 
  for (auto i = range.first; i != range.second; ++i)
    std::cout &lt;&lt; i-&gt;first &lt;&lt; &quot;: &quot; &lt;&lt; i-&gt;second &lt;&lt; '\n';
  // prints:
  //   2: B
  //   2: C
  //   2: D
}
</code></pre>
<p>why does <code>map</code> also have an <code>equal_range</code> method if there can be no duplicate keys
? <a href="https://stackoverflow.com/a/53521124"><code>bcoz 🔮</code></a> (consistency and generic
usage of containers).</p>
<table><thead><tr><th>operation</th><th>cost</th></tr></thead><tbody>
<tr><td>memory</td><td>\(\propto N\) (&gt; list)</td></tr>
<tr><td>element access time</td><td>\(\propto log_2(N)\)</td></tr>
<tr><td>insertion and deletion EVERYWHERE</td><td>Constant</td></tr>
<tr><td>reference and pointer invalidation on modification</td><td> NO ✅️ </td></tr>
<tr><td>iterator invalidation on modification</td><td> NO ✅️ </td></tr>
</tbody></table>
<p>Careful with the memory consumption of map. If associative access is required
but <code>log_2(N)</code> is too inefficient (lots of reads), favor an <code>unordered_map</code>.
Also, <code>map</code> and <code>multimap</code> are unusable if no strict order relation can be
established among the would be keys.</p>
<p>An
<a href="https://en.cppreference.com/w/cpp/container/unordered_map"><code>unordered_map&lt;K,V,H,C,A&gt;</code></a>
is an associative container that contains key-value pairs with unique keys.
Search, insertion, and removal of elements have average constant-time complexity.</p>
<p>An
<a href="https://en.cppreference.com/w/cpp/container/unordered_multimap"><code>unordered_multimap&lt;K,V,H,C,A&gt;</code></a>
std::unordered_map is an associative container that contains key-value pairs
with unique keys. Search, insertion, and removal of elements have average
constant-time complexity.</p>
<p>Both are implemented with hash tables (contrast with RB-Trees for the ordered
versions of theses data structures).</p>
<p>These classes are parametrised by 5 types:</p>
<ul>
<li><code>K</code> the type of the keys.</li>
<li><code>V</code> the type of the values.</li>
<li><code>H</code> the type of the hash function.</li>
<li><code>C</code> the type of the comparator indicating if two keys are equal.</li>
<li><code>A</code> the type of the .</li>
</ul>
<p>460</p>
<p>🔮</p>
<a class="header" href="print.html#algorithms--data-structures" id="algorithms--data-structures"><h1>Algorithms &amp; Data Structures</h1></a>
<a class="header" href="print.html#linear-data-structures" id="linear-data-structures"><h1>Linear Data Structures</h1></a>
<a class="header" href="print.html#sorting" id="sorting"><h1>Sorting</h1></a>
<a class="header" href="print.html#searching" id="searching"><h1>Searching</h1></a>
<a class="header" href="print.html#trees" id="trees"><h1>Trees</h1></a>
<a class="header" href="print.html#graphs" id="graphs"><h1>Graphs</h1></a>
<a class="header" href="print.html#divide--conquer" id="divide--conquer"><h1>Divide &amp; Conquer</h1></a>
<a class="header" href="print.html#greedy-algorithms" id="greedy-algorithms"><h1>Greedy Algorithms</h1></a>
<a class="header" href="print.html#dynamic-programming" id="dynamic-programming"><h1>Dynamic Programming</h1></a>
<a class="header" href="print.html#graph-algorithms" id="graph-algorithms"><h1>Graph Algorithms</h1></a>
<a class="header" href="print.html#linear-programming" id="linear-programming"><h1>Linear Programming</h1></a>
<a class="header" href="print.html#string-algorithms" id="string-algorithms"><h1>String Algorithms</h1></a>
<a class="header" href="print.html#leetcode-catalog" id="leetcode-catalog"><h1>LeetCode Catalog</h1></a>
<a class="header" href="print.html#theory-of-np-completeness" id="theory-of-np-completeness"><h1>Theory of NP-Completeness</h1></a>
<p>This chapter is a summary of the book
&quot;<em>Computers and Intractability: A Guide to the Theory of NP-Completeness</em>&quot;
- <em>Michael R.Garey / David S. Johnson</em>.</p>
<a class="header" href="print.html#basics" id="basics"><h2>Basics</h2></a>
<p><strong>Purpose</strong>:
&quot;<em>In short, the primary application of the theory of \(NP\)-completeness
is to assist algorithm designers in directing their problem-solving efforts
towards those approaches that have the greatest likelihood of leading to
useful algorithms</em>&quot;
<br></p>
<p><strong>Definition</strong></p>
<p>\(f(n)\) is \(O(g(n))\) if there exists a constant \(c\) such that
\(|f(n)|\leq c\cdot|g(n)|\) for all values of \(n\).</p>
<p><strong>Definition</strong></p>
<p>A problem is <strong>intractable</strong> if no polynomial
time algorithm can possibly solve it.</p>
<p><strong>Two cases of intractability</strong></p>
<ol>
<li>A problem is so difficult that an exponential amount of time is required
to find a solution.</li>
<li>A solution to the problem cannot be encoded into an expression having
length bounded by a polynomial fuction of the input length.
<br>\(\longrightarrow\) only problems for which the solution length is
bounded by a polynomial function of the input length will be considered.</li>
</ol>
<p><strong>Definition</strong></p>
<p>A problem is said to be <strong>undecidable</strong> if no algorithm
at all can be given for solving it.</p>
<p><em>Examples</em></p>
<ol>
<li>The halting problem is undecidable: it is impossible to specify an algorithm
which, given an arbitrary computer program and an arbitrary input to that
program, can decide whether or not the program will eventually halt when
applied to that input.</li>
<li>Hilbert's tenth problem: solvability of polynomial equations in integers.</li>
<li>The triviality problem for finitely presented groups
<a href="https://arxiv.org/pdf/1401.2273.pdf">[Rabin 1958]</a>.</li>
</ol>
<p><strong>Remark</strong>
Undecidable problems are intractable.</p>
<p><strong>Definition</strong></p>
<p>A problem is said to be <strong>non-deterministically intractable</strong> if it cannot be solved
in polynomial time using a <strong>non-deterministic computer</strong> model, which has the
ability to pursue an unbounded number of independant computational sequences
in parallel.</p>
<p><strong>Remark</strong>
All provably intractable problems known to date are either undecidable or
non-deterministically intractable.</p>
<p><strong>Definition</strong></p>
<ul>
<li>NP is the set of decision problems solvable in polynomial time by a nondeterministic Turing machine.</li>
<li>NP is the set of decision problems verifiable in polynomial time by a deterministic Turing machine.</li>
</ul>
<p><strong>Reduction</strong> is a technique used for demonstrating that two problems are
related to one another, by giving a constructive transformation that maps
any instance of the first problem into an equivalent instance of the second.</p>
<p>The Complexity of Theorem Proving Procedures - <a href="https://doi.org/10.1145/800157.805047">paper by Cook</a></p>
<ol>
<li>Polynomial time reducibility: If we have a polynomial time reduction
from one problem to another, this ensures that any polynomial time algorithm
for the second problem can be converted into a polynomial time algorithm for
the first problem.</li>
<li>Most of the apparently intractable problems encountered in practice, when
phrased as decision problems belong to the class of \(NP\) decision problems that
can be solved in polynomial time by a non-deterministic computer.</li>
<li>Every problem in NP can be polynomially reduced to the satisfiability problem.</li>
</ol>
<p>The satisfiability problem is the &quot;hardest&quot; problem in \(NP\).</p>
<p>The problem &quot;Does a graph \(G\) contain a
complete subgraph on a given number \(k\) of vertices?&quot; also has this property.</p>
<p>The class of these &quot;hardest&quot; problems in \(NP\) has been shown to include
many other problems by <em>Richard Karp</em> in <em>1972</em>.
See this <a href="https://en.wikipedia.org/wiki/Karp%27s_21_NP-complete_problems">page</a>
for more details.</p>
<p>The equivalence class of the Satisfiability problems is called the set of
<strong>\(NP\)-complete</strong> problems.</p>
<p>Here is a more concrete definition from <a href="https://en.wikipedia.org/wiki/NP-completeness">wikipedia</a>:</p>
<p>A problem is <strong>\(NP\)-complete</strong> if:</p>
<ul>
<li>It is a decision problem, meaning that for any input to the problem,
the output is either &quot;yes&quot; or &quot;no&quot;.</li>
<li>When the answer is &quot;yes&quot;, this can be demonstrated through the existence
of a short (polynomial length) solution.</li>
<li>The correctness of each solution can be verified quickly (namely,
in polynomial time) and a brute-force search algorithm can find a solution
by trying all possible solutions.</li>
<li>The problem can be used to simulate every other problem for which we can
verify quickly that a solution is correct. In this sense, NP-complete
problems are the hardest of the problems to which solutions can be verified
quickly. If we could find solutions of some NP-complete problem quickly,
we could quickly find the solutions of every other problem to which a given
solution can be easily verified.</li>
</ul>
<p><strong>Open Question</strong>: are the \(NP\)-complete problems intractable ?</p>
<a class="header" href="print.html#the-theory-of-np-completeness" id="the-theory-of-np-completeness"><h1>The Theory of NP-Completeness</h1></a>
<a class="header" href="print.html#decision-problems-languages-and-encoding-schemes" id="decision-problems-languages-and-encoding-schemes"><h2>Decision Problems, Languages and Encoding Schemes</h2></a>
<p>The theory of \(NP\)-completeness is designed to be applied only to decision
problems.</p>
<p>A Decision problem is a problem with only two possible solutions: &quot;yes&quot; and &quot;no&quot;.</p>
<p><strong>Definition</strong>
A decision problem \(\Pi\) consists of a set \(D_\Pi\) of instances and a
subset \(Y_\Pi \subseteq D_\Pi\) of <em>yes</em>-instances.</p>
<p>\(\rightarrow\) a more practical approach is to define a <em>generic instance</em>
using a set of various components (graphs, functions, numbers, sets) and a
<em>yes-no</em> question asked in terms of the generic instance.</p>
<p>An instance belongs to \(D_\Pi\) iff it can be obtained from a generic instance
by substiting particular objects of the specified types for all
the generic components.</p>
<p>An instance belongs to \(Y_\Pi\) iff the answer to the stated question,
when particularized to that instance, is <em>&quot;yes&quot;</em>.</p>
<p><strong>Examples</strong></p>
<ul>
<li>
<p><strong>Subgraph Isomorphism</strong></p>
<p><em>Instance</em>: Two graphs \(G_1=(V_1, E_1)\) and \(G_2=(V_2, E_2)\).</p>
<p><em>Question</em>: Does \(G_1\) contain a subgraph isomorphic to \(G2\), that is,
a subset \(V'\subseteq V_1\) and a subset \(E'\subseteq E_1\) such that
\(|V'|=|V_2|\), \(|E'|=|E_2|\), and there exists a one-to-one function
\(f: V_2 \rightarrow V'\) satisfying \(\{u, v\}\in E_2\) iff
\(\{f(u), f(v)\}\in E'\) ?</p>
</li>
<li>
<p><strong>Traveling Salesman</strong></p>
<p><em>Instance</em>: A finite set \(C=\{c_1, ..., c_m\}\) of &quot;cities&quot;, a &quot;distance&quot;
\(d(c_i, c_j)\in\mathbb{Z}^+\) for each pair of cities \(c_i, c_j \in C\)
, and a bound \(B\in\mathbb{Z}^+\).</p>
<p><em>Question</em>: Is there a &quot;tour&quot; of all the cities in \(C\) having total
length no more than \(B\), that is an ordering
\(&lt; c_{\pi(1)}, ..., c_{\pi(m)} &gt;\) of \(C\) such that</p>
<p>\[(\sum_{i=1}^{m-1}{d(c_{\pi(i)}, c_{\pi(i+1)})}) + d(c_{\pi(m)}, c_{\pi(1)}) \leq B ?\]</p>
</li>
</ul>
<p>The traveling salesman problem variant described above is an example of how
a non decision problem can be transformed into a decision problem.</p>
<p><strong>Definition</strong></p>
<p>For any finite set \(\Sigma\) of symbols, we denote by \(\Sigma^* \) the set
of all finite strings of symbols from \(\Sigma\). If \(L\) is a subset
of \(\Sigma^* \), we say that \(L\) is a <strong>language</strong> over the <strong>alphabet</strong>
\(\Sigma\).</p>
<p><strong>Examples</strong></p>
<ul>
<li>If \(\Sigma=\{0, 1\}\) then \(\Sigma^* \) consists of the empty string
&quot;\(\epsilon\)&quot;, the strings \(0, 1, 00, 01, 11, 000, 001\) and all other
finite strings of \(1\)'s and \(0\)'s.</li>
<li>\(\{01, 001, 111, 1101010\}\) is a language over \(\{0, 1\}\), as is
the set of all binary representations of integers that are perfect squares,
as is \(\{0, 1\}^* \) itself.</li>
</ul>
<p><strong>Definition</strong></p>
<p>An encoding scheme \(e\) for a problem \(\Pi\) provides a way of describing
each instance of \(\Pi\) by an appropriate string of symbols over some fixed
alphabet \(\Sigma\).</p>
<p><strong>Remark</strong></p>
<p>The problem \(\Pi\) and the encoding sceme \(e\) for \(\Pi\) partition
\(\Sigma^* \) intro three classes of strings:</p>
<ul>
<li>those that are not encodings of instances of \(\Pi\).</li>
<li>those that encode instances of \(\Pi\) for which the answer is &quot;<em>no</em>&quot;.</li>
<li>those that encode instances of \(\Pi\) for which the answer is &quot;<em>yes</em>&quot;.</li>
</ul>
<p><strong>Definition</strong></p>
<p>Assuming that \(\Sigma\) is the alphabet used by \(e\),
the language associated to the problem \(\Pi\) and the encoding \(e\) is
denoted :
\[
L[\Pi, e] = \{x\in\Sigma^* :  x\
is\ the\ encoding\ under\ e\ of\ an \ instance\ I\in Y_{\Pi}\}.
\]</p>
<p><strong>Lemma</strong>
If a result holds for the language \(L[\Pi, e]\), then it holds for the
problem \(\Pi\) under the encoding scheme \(e\).</p>
<p>Assuming the encodings we employ are &quot;reasonable&quot; most properties are
encoding-independant.</p>
<p>We assume that every decision problem \(\Pi\) has an associated
encoding-independant function \(Length: D_\Pi \rightarrow\mathbb{N}\),
which is &quot;polynomially related&quot; to the input lengths we would we would obtain
from a reasonable encoding scheme.</p>
<p><strong>A Standard Encoding Scheme</strong></p>
<p>The alphabet used is \(\Psi=\{ 0 , 1 , - , [ , ] , ( , ) , , \} \).</p>
<p>We define <strong>structured strings</strong> recursively:</p>
<ol>
<li>An integer \(k\) is represented by a string of \(0\)'s and \(1\)'s
preceded by a minus sign &quot;\(-\)&quot; if \(k\) is negative.</li>
<li>If \(x\) is a structured string representing the integer \(k\), then
\([x]\) is a structured string that can be used as a &quot;name&quot;. (for examples:
a vertex in a graph, a set element, a city in the traveling salesman problem).</li>
<li>If \(x_1, \dots, x_m\) are structured strings representing the objects
\(X_1, ..., X_m\), then \((x_1, ..., x_m)\) is a structured string
representing the sequence \(&lt; X_1, ..., X_m &gt;\).</li>
</ol>
<p>We already know how to encode <strong>integers</strong> and <strong>sequences</strong>.</p>
<ul>
<li>A <strong>set</strong> is represented by ordering its elements as a sequence
\(&lt; X_1, ..., X_m &gt;\) and taking the structured string corresponding
to that sequence.</li>
<li>A <strong>graph</strong> with vertex set \(V\) and edge set \(E\) is represented by a
structured string \((x, y)\), where \(x\) is a structured string
representing the set \(V\) and \(y\) is a structured string representing
the \(E\) (the elements of \(E\) being the two-element subsets of \(V\)
that are edges).</li>
<li>A <strong>finite function</strong>  \(f: \{U_1, ..., U_m\}\rightarrow W\) is
represented by a structured string \(((x_1, y_1), ... ,(x_m, y_m))\) where
\(x_i\) is a structured string representing the object \(U_i\)
and \(y_i\) a structured string representing the object \(f(U_i)\in W\)
, \(\forall \ 1\leq i\leq m\).</li>
<li>A <strong>rational number</strong> \(q\) is represented by a structured string
\((x,y)\) where \(x\) is a structured string representing an integer
\(a\), \(y\) is a structured string representing an integer \(b\),
\(a/b=q\), and \(GCD(a, b)=1\).</li>
</ul>
<p>Two structured strings written in the standard encoding schemes can represent
a same object without being strictly the same.</p>
<p>From now on, an encoding scheme is said to be reasonable if it is equivalent
to the standard encoding scheme, in the sense that there exist polynomial time
algorithms for converting an encoding of an instance back and forth between
the two encoding schemes.</p>
<a class="header" href="print.html#deterministic-turing-machines-and-the-class-p" id="deterministic-turing-machines-and-the-class-p"><h2>Deterministic Turing Machines and the Class P</h2></a>
<p><strong>Definition</strong></p>
<p>A <strong>Deterministic One-Tape Turing Machine</strong> (DTM) is a model of computation
which consists of a <em>finite state control</em>, a <em>read-write head</em> and a two-way
infinite <em>tape</em> of squares labeled (\(..., -2, -1, 0, 1, 2, ...\)).</p>
<p><img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/deterministic_turing_machine.jpg" alt="img" /></p>
<p><strong>Definition</strong></p>
<p>A <em>program</em> for a DTM specifies the following information:</p>
<ol>
<li>A finite set \(\Gamma\) of tape symbols, including a subset
\(\Sigma\subset\Gamma\) of <em>input</em> symbols and a distinguished
<em>blank symbol</em> \(b\in\Gamma\backslash\Sigma\);</li>
<li>a finite set \(\mathcal{Q}\) of <em>states</em>, including a distinguished <em>start-state</em>
\(q_0\) and two distinguished <em>halt-states</em> \(q_Y\) and \(q_N\);</li>
<li>a <em>transition function</em>
\(\delta: (\mathcal{Q}\backslash\{q_Y, q_N\})\times\Gamma\rightarrow
\mathcal{Q}\times\Gamma\times\{-1, +1\}\).</li>
</ol>
<p><strong>Operation of a DTM program</strong></p>
<p>The input to the DTM is a string \(x\in\Sigma^*\).</p>
<p>All the tape squares initially contain the blank symbol \(b\).</p>
<p>The string \(x\) is placed in tape squares 1 through \(|x|\).</p>
<p>The program starts its operation in state \(q_0\), with the head scanning tape
square \(1\).</p>
<p>At each step:</p>
<ul>
<li>If the current state \(q\) is either \(q_Y\) or \(q_N\), then the
computation has ended, with the answer being &quot;\(yes\)&quot; if \(q=q_Y\)
or &quot;\(no\)&quot; if \(q=q_N\).</li>
<li>Else we have \(q\in \mathcal{Q}\backslash \{q_Y, q_N\}\) and there is a symbol
\(s\) in the tape square being scanned. The value of the <em>transition
function</em> can be computed:
\(\delta(q, s)=(q', s', \Delta)\). The <em>read write head</em> then replaces
the symbol \(s\) by \(s'\) in the current square, it then moves one square
right if \(\Delta=1\) or one square left if \(\Delta=-1\). The
<em>finite state control</em> updates the state value from \(q\) to \(q'\).</li>
</ul>
<p><strong>Definition</strong></p>
<p>We say that a DTM program \(M\) with input alphabet \(\Sigma\) <em>accepts</em>
\(x\in\Sigma^*\) if and only if \(M\) halts in state \(q_Y\) when applied
to input \(x\).</p>
<p><strong>Definition</strong>
: The language \(L_M\) recognized by the program \(M\) is given by
\(L_M = \{x\in\Sigma^*: M \ accepts\ x\}\).</p>
<p>If \(x\in(\Sigma^*\backslash L_M)\) then either the computation of \(M\) on
\(x\) halts in state \(q_N\) or it does not halt <em>ie: continues forever</em>.</p>
<p><strong>Definition</strong></p>
<p>We say that a DTM program \(M\) <em>solves</em> the decision problem \(\Pi\) under
encoding scheme \(e\) if \(M\) halts for all input strings over its input
alphabet and \(L_M = L[\Pi, e]\).</p>
<p><strong>Example</strong>: Integer Divisibility by four.</p>
<p>Instance: A positive integer \(N\).</p>
<p>Question: Is there a positive integer \(m\) such that \(N=4m\)?</p>
<p>Using the standard encoding scheme, the integer \(N\) is represented by the
string of  \(0\)'s and \(1\)'s that is its binary representation.</p>
<p>\[
\Gamma=\{0, 1, b\}, \Sigma=\{0, 1\} \\
\mathcal{Q}=\{q_0, q_1, q_2, q_3, q_Y, q_N\} \\
\delta(q_0, 0)=(q_0, 0, +1), \
\delta(q_0, 1)=(q_0, 1, +1)\\
\delta(q_0, b)=(q_1, b, -1), \
\delta(q_1, 0)=(q_2, b, -1)\\
\delta(q_1, 1)=(q_3, b, -1), \
\delta(q_1, b)=(q_N, b, -1)\\
\delta(q_2, 0)=(q_Y, b, -1), \
\delta(q_2, 1)=(q_N, b, -1)\\
\delta(q_2, b)=(q_N, b, -1), \
\delta(q_3, 0)=(q_N, b, -1)\\
\delta(q_3, 1)=(q_N, b, -1), \
\delta(q_3, b)=(q_N, b, -1)\\
M=(\Gamma, \mathcal{Q}, \delta).
\]</p>
<p>Here as example of the execution of this program on the string
\(x=10100\).</p>
<p><img src="media/dtmM.png" alt="dtm execution diagram" /></p>
<p>The language \(L_M\) recognized by the program \(M\) is given by
\(L_M = \{x\in\Sigma^*: M\ accepts \ x\}\).</p>
<p>It can be shown that \(L_M\) is exactly the language</p>
<p>\[
\{x\in\{0, 1\}^*: the \ rightmost \ two \ symbols \ of \ x
\ are \ both \ 0 \}.
\]</p>
<p>Since an integer \(N\) is divisible by \(4\) if and only if the last two
digits of its binary representation are \(0\), the DTM program \(M\) solves
the INTEGER DIVISIBILITY BY FOUR problem.</p>
<p><strong>Remark</strong>: A DTM program can compute functions.
Suppose \(M\) is a DTM with input alphabet \(\Sigma\) and tape alphabet
\(\Gamma\) that halts for all input strings from \(\Sigma^*\).
Then \(M\) computes the function \(f_M : \Sigma^* \rightarrow \Gamma^*\)
where for each \(x \in \Sigma^*\), \(f_M(x)\) is defined to be the
contiguous string obtained by running \(M\) on input \(x\) until it
halts; from tape position 1 up to but not including the first blank symbol.</p>
<p>The <strong>time</strong> used in the computation of a DTM program \(M\) on an input \(x\)
is the number of steps occuring in that computation up until the first
halt state is entered.</p>
<p><strong>Definition</strong>
For a DTM program \(M\) that halts on all inputs \(x\in\Sigma^*\), its
<em>time complexity function</em> \(T_M: \mathbb{Z}^+\rightarrow\mathbb{Z}^+\)
is given by:</p>
<p>\[
T_M(n) = max \{m: there \ is \ a \ string \ x\in\Sigma^* of \ length
\\ \
n \ on \ which \ the \ computation \ of \ M \ takes \ time \ m \}
\]</p>
<p><strong>Remark</strong> \(M\) is a <em>polynomial time DTM program</em> if there exists a
polynomial \(p\) such that \(\forall n \in \mathbb{N} : T_M(n)\leq p(n)\).</p>
<p><strong>Definition</strong></p>
<p>\[
P = \{L: there \ exists \ a \ polynomial \ time \ DTM \ program \\
\ M \ for \ which \ L=L_M\}.
\]</p>
<p>We say that a decision problem \(\Pi\) belongs to \(P\) under the encoding scheme \(e\) if \(L[\Pi, e]\in P\), <em>ie</em> there is a polynomial time DTM
program that solves \(\Pi\) under the encoding \(e\).</p>
<p>If a decision problem \(\Pi\in P\) then its complementary problem is
also in \(P\), this is not necessarily the case for a problem in \(NP\).</p>
<a class="header" href="print.html#nondeterminstic-computation-and-the-class-np" id="nondeterminstic-computation-and-the-class-np"><h2>Nondeterminstic Computation and the class NP</h2></a>
<p>The class \(NP\) is intended to isolate the notion of polynomial time
&quot;verifiability&quot;, which does not imply polynomial time solvability.</p>
<p>A <strong>nondeterministic algorithm</strong> is composed of two separate stages, the first
being a <em>guessing stage</em> and the second a <em>checking stage</em>.
Given a problem instance \(I\), the first stage <em>guesses</em> a structure \(S\).
\(I\) and \(S\) are then passed as inputs to the checking stage, which
performs deterministic computations to verify if the structure \(S\)
proves that the answer to \(I\) is &quot;yes&quot;.</p>
<p>A nondeterministic algorithm <em>solves</em> a decision problem \(\Pi\) iff :</p>
<ol>
<li>If \(I\in Y_{\Pi}\), then there exists some structure \(S\) that, when
guessed for input \(I\), will lead the checking stage to respond &quot;yes&quot; for
\(I\) and \(S\).</li>
<li>If \(I\notin Y_{\Pi}\), then there exists some structure \(S\) that, when
guessed for input \(I\), will lead the checking stage to respond &quot;yes&quot; for
\(I\) and \(S\).</li>
</ol>
<p><strong>Definitions</strong></p>
<p>A <strong>NonDeterministic one-tape Turing Machine</strong> (NDTM)
is a computation model composed of a <em>finite state control</em>, a <em>read-write head</em>
, a two-way infinite <em>tape</em> of squares labeled (\(..., -2, -1, 0, 1, 2, ...\))
and a <em>guessing module</em> having a <em>write-only head</em>.</p>
<p><img src="https://i.stack.imgur.com/lqJWu.png" alt="img" /></p>
<p>An <strong>NDTM program</strong> is specified in exactly the same way as \(DTM\) program.
This includes the tape alphabet \(\Gamma\), input alphabet \(\Sigma\),
blank symbol \(b\), state set \(\mathcal{Q}\), initial state \(q_0\), halt
states \(q_Y\) and \(q_N\) and transition function
\(\delta: (\mathcal{Q} \backslash \{q_Y, q_N\})\times\Gamma
\rightarrow \mathcal{Q}\times\Gamma\times\{-1, +1\}\)</p>
<p>The <strong>computation of an NDTM</strong> on an input string \(x\in\Sigma^*\) differs from
that of a DTM in that it takes place in two distinct stages:</p>
<ul>
<li>the <em>guessing stage</em>:
<ul>
<li>the input string \(x\) is written in tapes \(1\) through \(|x|\).
All other squares contain the blank character.</li>
<li>the read-write head is scanning square \(1\), while the write-only head is
scanning square \(-1\), the finite state control is inactive.</li>
<li>the guessing module then directs the write-only head, one step at a
time, either to write some symbol from \(\Gamma\) in te tape square being
scanned and move one square to the left, or to stop, at which point the
guessing module becomes inactive.</li>
</ul>
</li>
</ul>
<p>The finite state control is then activated in state \(q_0\).</p>
<ul>
<li>the <em>checking stage</em>:
<ul>
<li>the guessing module and its write-only head are no longer involved, having
fulfilled their role by guessing a string on the tape.</li>
<li>the computation proceeds solely under the direction of the NDTM program
according to exactly the same rules as for a DTM.</li>
<li>the guessed string can (and usually will) be examined during this stage.</li>
<li>The computation ceases when and if the finite state control enters one of
the two halting states and is said to be an <em>accepting computation</em> if it
halts in state \(q_Y\). All other computations, halting or not are
classified as <em>non-accepting computations</em>.</li>
</ul>
</li>
</ul>
<p>The choice of whether to remain active, and, if so, which symbol to write, is
made by the guessing module in a totally arbitrary manner. An important
consequence is that the guessing module can write any string from
\(\Gamma^*\) before it halts (if it ever does).</p>
<p><strong>Properties</strong></p>
<p>An NDTM program \(M\) has an infinite number of possible computations for a
given input string \(x\), one for each possible guessed string from
\(\Gamma^*\).</p>
<p>An NDTM program \(M\) accepts \(x\) if at least one of these is an accepting
computation.</p>
<p>The language recongnized by \(M\) is
\[L_M = \{x\in\Sigma^* : M \ accepts \ x\}\]</p>
<p>The <em>time</em> required by an NDTM program \(M\) to accept the string
\(x\in L_M\) is the minimum, over all accepting computations of \(M\) for
\(x\) of the number of steps ocurring in the guessing and checking stages up
until the halt state \(q_Y\) is entered.</p>
<p>The <em>time complexity function</em> \(T_M: \mathbb{Z}^+\rightarrow\mathbb{Z}^+\)
for \(M\) is
\[
T_M(n) = max (\{1\}\cup\{m: \exists x\in\Sigma^* with \ |x|=n \ \
s.t. \ the \ time \ to \ accept \ x \ by \ M \ is \ m
\})
\]</p>
<p>The time complexity function for \(M\) depends only on the number of steps
occurring in <em>accepting computations</em>. By convention, \(T_M(n)\) is \(1\)
for whenever no inputs of length \(n\) are accepted by \(M\).</p>
<p>The NDTM program \(M\) is a <em>polynomial time NDTM program</em> if there exists a
polynomial \(p\) such that \(\forall n\geq 1: \ T_M(n)\leq p(n) \).</p>
<p><strong>Definition</strong>
\[
NP = \{L: there \ is \ a \ polynomial \ time \ NDTM \ program
\ M \ for \ which \ L_M=L\}
\]</p>
<p>A decision problem \(\Pi\) will be said to belong to \(NP\) under encoding
scheme \(e\) if the language \(L[\Pi, e]\in NP\)</p>
<p><strong>Heuristic</strong> We identify \(NP\) with the class of all decision problems
&quot;solvable&quot; by polynomial time nondeterministic algorithms.</p>
<a class="header" href="print.html#the-relationship-between-p-and-np" id="the-relationship-between-p-and-np"><h2>The Relationship between P and NP</h2></a>
<a class="header" href="print.html#proving-np-complete-results" id="proving-np-complete-results"><h1>Proving NP-Complete Results</h1></a>
<a class="header" href="print.html#ocaml-functional-programming" id="ocaml-functional-programming"><h1>Ocaml Functional Programming</h1></a>
<a class="header" href="print.html#ninety-nine-problems-in-ocaml" id="ninety-nine-problems-in-ocaml"><h1>Ninety-Nine Problems in Ocaml</h1></a>
<p><strong>Exercise 1: Tail of a List</strong></p>
<p>Write a function that returns the last element of a list.</p>
<pre><code class="language-ocaml">last : 'a list -&gt; 'a option 
</code></pre>
<p><details open>
<summary>Show Solution</summary></p>
<pre><code class="language-ocaml"> let rec last (l: 'a list): 'a option = 
   match l with
   | [] -&gt; None
   | [e] -&gt; Some e
   | _::tail -&gt; last tail
</code></pre>
<p><strong>Explanation</strong></p>
<p>Here we are defining a recursive function in OCaml.</p>
<p>Notice the optional type hints. The function takes a (homogenous) list <code>l</code>
of a generic type <code>'a</code> (<code>'SOMETHING</code> is OCaml syntax for generic types).</p>
<p>If the list is empty, we return None, there is no last element.</p>
<p>If the list contains a single element <code>e</code>, return <code>Some e</code>.</p>
<p>Otherwise, discard the first element <code>_</code> and call last on the rest of the list.</p>
<p><code>'a option</code> is OCaml's solution to the billion dollar
mistake of the <code>NullPointerException</code>. All values in OCaml are non-null.</p>
<p>The option type allows us to deal with a case where a &quot;null&quot; value would be
useful.</p>
<pre><code class="language-ocaml">type 'a option = 
| Some 'a
| None
</code></pre>
<p>The compiler will force you to handle <code>None</code> values in option types.</p>
<p>The <code>e::l</code> operation appends element <code>e</code> to the beginning of the list <code>l</code>.</p>
<p>The <code>match</code> allows us to perform different action based on the form of the list
<code>l</code>. It is basically an switch statement on steroids that allows us to
deconstruct a value of any type into its possible forms.</p>
<p>The compiler will force you to handle all possible forms of the input type.</p>
<p></details></p>
<p><strong>Exercise 2: Last Two Elements of a List</strong></p>
<p>Find the last but one (last and penultimate) elements of a list.</p>
<pre><code class="language-ocaml">last_two : 'a list -&gt; ('a * 'a) option 
</code></pre>
<p><details open>
<summary>Show Solution</summary></p>
<pre><code class="language-ocaml"> let rec last_two (l: 'a list): ('a * 'a) option = 
   match l with
   | [] 
   | [_] -&gt; None
   | e1::e2::[] -&gt; Some (e1, e2)
   | _::rest -&gt; last_two rest
</code></pre>
<p><strong>Explanation</strong></p>
<p>Same idea, minor tweaks. We are returing a product type <em>ie:</em> tuple.</p>
<p>If the list contains exactly two elements <code>e1</code> and <code>e2</code>, return the tuple
<code>(e1, e2)</code> wrapped in <code>Some</code> (we HAVE to return an option type).</p>
<p>If the list contains 0 or 1 elements, return <code>None</code>, we can match both cases
with one arrow.</p>
<p>Otherwise if the list contains 3 or more elements, discard the first one
and call <code>last_two</code> on the rest of the list.</p>
<p></details></p>
<p><strong>Exercise 3: N'th Element of a List</strong></p>
<p>Find the N'th element of a list.</p>
<pre><code class="language-ocaml">nth: 'a list -&gt; int -&gt; 'a option
</code></pre>
<p><details open>
<summary>Show solution</summary></p>
<pre><code class="language-ocaml">let rec nth (lst: 'a list) (k: int): 'a option = 
  match (k, lst) with 
  | (_, []) -&gt; None
  | (0, x::_) -&gt; Some x
  | (k, _::rest) -&gt; nth rest (k-1)
</code></pre>
<p>This function still returns <code>None</code> for negative values.</p>
<p></details></p>
<p><strong>Exercise 4: Length of a List</strong></p>
<p>Find the number of elements of a list.</p>
<pre><code class="language-ocaml">length: 'a list -&gt; int
</code></pre>
<p><details open>
<summary>Show solution</summary></p>
<pre><code class="language-ocaml">let rec length (lst: 'a list): int = 
  match lst with
  | [] -&gt; 0
  | _::rest -&gt; 1 + length rest
</code></pre>
<p><strong>Explanation</strong></p>
<p>The length of an empty list is 0.</p>
<p>The length of a list having a first element
is one plus the length of the rest of the list.</p>
<p>Here is a tail recursive version.</p>
<pre><code class="language-ocaml">let rec length (lst: 'a list): int = 
  (* Define an inner auxiliary function *)
  let rec aux (lst: 'a list) (sofar: int): int = 
    match lst with
    | [] -&gt; sofar
    | _::rest -&gt; aux rest (sofar + 1)

  (* return this expression that uses the auxiliary function *)
  in aux lst 0
</code></pre>
<p></details></p>
<p><strong>Exercise 5: Reverse a List</strong></p>
<p>Reverse a List</p>
<pre><code class="language-ocaml">rev: 'a list -&gt; 'a list
</code></pre>
<p><details open>
<summary>Show solution</summary></p>
<pre><code class="language-ocaml">let rec rev (lst: 'a list): 'a list =
  let rec aux (reversed: 'a list) (remaining: 'a list): 'a list = 
    match (reversed, remaining) with
    | (reversed, []) -&gt; reversed
    | (reversed, x::tail) -&gt; aux (x::reversed) tail
  in aux [] lst
</code></pre>
<p></details></p>
<p><strong>Exercise 6: Duplicate the Elements of a List</strong></p>
<p>Duplicate the Elements of a List.</p>
<pre><code class="language-ocaml">dupl: 'a list -&gt; 'a list
</code></pre>
<p><details open>
<summary>Show solution</summary></p>
<pre><code class="language-ocaml">let rec dupl (lst: 'a list): 'a list = 
  match lst with 
  | [] -&gt; []
  | x::rest -&gt; x::x::(dupl rest)
</code></pre>
<p></details></p>
<p><strong>Exercise 7: Split a List Into Two Parts</strong></p>
<p>Split a list into two parts; the length of the first part is given.</p>
<p>If the length of the first part is longer than the entire list,
then the first part is the list and the second part is empty.</p>
<pre><code class="language-ocaml">split: 'a list -&gt; int -&gt; 'a list * 'a list 
</code></pre>
<p><details open>
<summary>Show solution</summary></p>
<pre><code class="language-ocaml">let split (l: 'a list) (n: int): 'a list * 'a list = 
      let rec aux (f: 'a list) (l: 'a list) (r: int) : 'a list * 'a list = 
        match (r, l) with 
        | (0, l) 
        | (k, []) -&gt; (List.rev f, l)
        | (k, x::rest) -&gt; aux (x::f) (rest) (k-1)
      in aux [] l n
</code></pre>
<p></details></p>
<p><strong>Exercise n: ptitle</strong></p>
<p>pdescription</p>
<pre><code class="language-ocaml">psig
</code></pre>
<p><details open>
<summary>Show solution</summary></p>
<pre><code class="language-ocaml">   (* solution *)
</code></pre>
<p><strong>Explanation</strong></p>
<p>pexpl</p>
<p></details></p>
<a class="header" href="print.html#lambda-calculus" id="lambda-calculus"><h1>Lambda Calculus</h1></a>
<a class="header" href="print.html#maths-de-1er-cycle" id="maths-de-1er-cycle"><h1>Maths de 1er cycle</h1></a>
<a class="header" href="print.html#reduction-des-endomorphismes" id="reduction-des-endomorphismes"><h1>Reduction des Endomorphismes</h1></a>
<!-- <details> -->
<!-- <summary>**Cours**</summary> -->
<p>Soit \(\mathbb{K}\) un corps.</p>
<p>Soit \(E\) un \(\mathbb{K}\)-espace vectoriel.</p>
<p>Soit \(u: E \rightarrow E\) un endomorphisme de \(E\).</p>
<hr />
<p><strong>Definition 1</strong></p>
<p>Un sous-espace vectoriel \(F\) de \(E\) est dit stable par \(u\) si
\(u(F)\subset F\).</p>
<hr />
<hr />
<p><strong>Proposition 1</strong></p>
<p>Si les endomorphismes \(u\) et \(v\) de \(E\) commutent,
<em>c'est a dire si</em> \(u\circ v = v\circ u\)
, alors \(Ker(v)\) et \(Im(v)\) sont stables par \(u\).</p>
<hr />
<hr />
<p><strong>Proposition 2</strong></p>
<p>Si \(F\) est un sous-espace vectoriel de \(E\)
engendré par une famille \((e_i)_{i \in I}\),
alors \(F\) est stable par \(u\) ssi:
\[\forall i \in I\quad u(e_i) \in F.\]</p>
<hr />
<hr />
<p><strong>Corollaire 3: traduction matricielle de la stabilité</strong></p>
<p>Soit \(F\) un sous-espace vectoriel de \(E\) de dimension \(p\) et
\(\mathcal{B}=(e_1, ..., e_n)\)
une base de E adaptée a \(F\), c'est a dire telle que
\(\mathcal{B}' = (e_1, ..., e_p)\) soit une
base de \(F\).</p>
<p>Alors \(F\) est stable par \(u\) ssi sa matrice dans la base
\(\mathcal{B}\) est de la forme
\(\begin{pmatrix}A &amp; C\\0 &amp; B\end{pmatrix}\),
avec \(A\in \mathcal{M}_p(\mathbb{K})\).</p>
<p>Dans ce cas, \(A\) est la matrice dans la base
\(\mathcal{B}'\) de l'endomorphisme induit \(u_F\).</p>
<hr />
<hr />
<p><strong>Definition 3</strong></p>
<ol>
<li>On dit que \(\lambda \in \mathbb{K}\) est <strong>valeur propre</strong>
de \(u\) s'il existe un vecteur non nul \(x \in E\) tel que
\(u(x) = \lambda x\), c'est a dire si l'endomorphisme
\(u - \lambda Id_E\) est non injectif.</li>
<li>On dit que \(x \in E\) est <strong>vecteur propre</strong>
de \(u\) associee a la valeur propre \(\lambda\in\mathbb{K}\)
s'il est non nul et vérifie \(u(x)=\lambda x\).</li>
<li>Si \(\lambda \in \mathbb{K}\) est valeur propre de \(u\),
le <strong>sous-espace propre</strong> de \(u\) associé a la valeur propre \(\lambda\)
est: \[E_\lambda (u)=Ker(u-\lambda Id_E)=
\{x\in E : u(x)=\lambda x\}.\]</li>
</ol>
<hr />
<hr />
<p><strong>Definition 4</strong></p>
<p>Le spectre d'un endomorphisme d'un espace de dimension finie
est l'ensemble de ses valeurs propres.</p>
<hr />
<hr />
<p><strong>Proposition 5</strong></p>
<p>Si les endomorphismes \(u\) et \(v\) commutent,
c'est a dire si \(u\circ v = v\circ u\), alors les sous-espaces propres
de l'un sont stables par l'autre.</p>
<hr />
<hr />
<p><strong>Proposition 6</strong></p>
<ul>
<li>Si \(\lambda_1, ..., \lambda_p\) sont des valeurs propres deux a deux
deux distinctes de \(u\), alors les sous-espaces propres associés
\(E_{\lambda_1}(u), ..., E_{\lambda_p}(u)\) sont en somme directe.</li>
<li>Toute famille de vecteurs propres associés a des valeurs propres deux a deux
distinctes est libre.</li>
</ul>
<hr />
<hr />
<p><strong>Corollaire 7</strong></p>
<p>Si \(E\) est de dimension finie et si \(\lambda_1, ..., \lambda_p\) sont
des valeurs propres deux a deux distinctes de \(u\), alors:
\[
\sum_{i=1}^{p}{dim(E_{\lambda_i} (u))} \leq dim(E)
\]</p>
<hr />
<hr />
<p><strong>Corollaire 8</strong></p>
<p>Un endomorphisme d'un espace vectoriel de dimension \(n\) a au plus \(n\)
valeurs propres distinctes.</p>
<hr />
<hr />
<p><strong>Proposition 9</strong></p>
<p>Si \(F\) est un sous-espace vectoriel de \(E\) stable par \(u\),
les valeurs propres de l'endomorphisme \(u_F\) induit par \(u\) sur \(F\)
sont les valeurs propres \(\lambda\) telles que
\(E_\lambda(u)\cap F \neq \{0\}\). On a alors:
\[E_\lambda(u_F) = E_\lambda(u)\cap F.\]</p>
<hr />
<hr />
<p><strong>Proposition 10</strong></p>
<p>Si \(f\) est un endomorphisme de \(E\) et si \(\mathcal{B}\) et
\(\mathcal{B}'\) sont deux bases de \(E\), alors les matrices \(M\) et
\(M'\) de \(f\) respectivement dans les bases \(\mathcal{B}\) et
\(\mathcal{B}'\) sont reliés par: \[M' = P^{-1}MP,\]
ou \(P\) est la matrice de passage de \(\mathcal{B}\) a \(\mathcal{B}'\).</p>
<hr />
<hr />
<p><strong>Definition 5</strong></p>
<p>Deux matrices \(A\) et \(B\) sont semblables s'il existe
\(P\in GL_n(\mathbb{K})\) telle que \(B=P^{-1}AP\).</p>
<hr />
<hr />
<p><strong>Proposition 11</strong></p>
<p>Deux matrices
\(M\) et \(M'\)
de \(\mathcal{M}_n (\mathbb{K})\) sont
semblables ssi elles representent le meme endomorphisme de
\(\mathbb{K}^n\),
c'est a dire s'il existe \(\mathcal{B}\) et \(\mathcal{B}'\) deux
bases de \(\mathbb{K}^n\) et \(f\in \mathcal{L}(\mathbb{K}^n)\) telles que:</p>
<p>\[
M=Mat_{\mathcal{B}}(f) \quad et \quad M'=Mat_{\mathcal{B}'}(f).
\]</p>
<hr />
<hr />
<p><strong>Proposition 12</strong></p>
<p>Deux matrices semblables ont meme trace et meme determinant.</p>
<hr />
<hr />
<p><strong>Definition 6</strong></p>
<p>Soit \(A\in \mathcal{M}_n(\mathbb{K})\)</p>
<ol>
<li>On dit que \(\lambda\in\mathbb{K}\) est valeur propre de \(A\) s'il
existe une matrice colonne \(X\in\mathcal{M}_{n,1}(\mathbb{K})\)
<em>non nulle</em> telle que \(AX=\lambda X\).</li>
<li>On dit que la matrice colonne \(X\in \mathcal{M}_{n,1}(\mathbb{K})\) est
vecteur propre de \(A\) associée a la valeur propre
\(\lambda\in\mathbb{K}\) si elle est non nulle et vérifie \(AX=\lambda X\).</li>
<li>Si \(\lambda\in\mathbb{K}\) est valeur propre de \(A\), le sous-espace
propre de \(A\) associée a la valeur propre \(\lambda\) est:
\[E_\lambda (A)=Ker(A-\lambda I_n)=
\{X\in \mathcal{M}_{n,1}(\mathbb{K}): AX=\lambda X\}.\]</li>
<li>L'ensemble des valeurs propres de \(A\) est appelé le <strong>spectre</strong> de \(A\)
et noté \(sp(A)\).</li>
</ol>
<hr />
<hr />
<p><strong>Proposition 13</strong></p>
<p>Soit \(A\) une matrice représentant l'endomorphisme \(u\) dans une base
\((e_1, ..., e_n)\). On a alors \(sp(A)=sp(u)\) et, pour tout
\(\lambda\in sp(u)\):
\[
x = \sum_{i=1}^{n}{x_i e_i} \in E_\lambda (u) \iff X=
\begin{bmatrix}
x_1 \\
\vdots \\
x_n \\
\end{bmatrix}
\in E_\lambda (A).
\]</p>
<hr />
<hr />
<p><strong>Corollaire 14</strong></p>
<p>Deux matrices semblables ont meme spectre et les sous-espaces propres
associés sont de meme dimension.</p>
<hr />
<hr />
<p><strong>Proposition 15</strong></p>
<p>Soit \(\mathbb{K}'\) un sous-corps du corps \(\mathbb{K}\) et
\(A\in\mathcal{M}_n(\mathbb{K}')\). Alors</p>
<p>\[sp_{\mathbb{K}'}(A) \subseteq sp_{\mathbb{K}}(A)\]</p>
<hr />
<hr />
<p><strong>Proposition 16</strong></p>
<p>Soit \(A\in \mathcal{M}_n(\mathbb{R})\). Si \(\lambda\in sp_\mathbb{C}(A)\)
, alors \(\overline\lambda\) est valeur propre de \(A\) et:</p>
<p>\[
X\in E_\lambda (A) \iff \overline X \in E_{\overline\lambda}(A).
\]</p>
<p>Si \((X_1, ..., X_k)\) est une base de \( E_\lambda (A) \) alors
\((\overline X_1, ..., \overline X_k)\) est une base de
\( E_\overline\lambda (A) \) donc
\(dim(E_\lambda (A))=dim(E_\overline\lambda (A))\).</p>
<hr />
<hr />
<p><strong>Definition 7</strong></p>
<p>Soit \(u\in\mathcal{L}(E)\) et
\(P=\sum_{k=0}^{p}{a_k X^k} \in\mathbb{K}[X]\).</p>
<p>On note \(P(u)\) l'endomorphisme de \(E\) defini par:</p>
<p>\[
P(u) = \sum_{k=0}^{p}{a_k u^k} .
\]</p>
<p>Pour \(A\in \mathcal{M}_n (\mathbb{K})\), on definit de meme la matrice
\(P(A)\in\mathcal{M}_n (\mathbb{K})\) par:</p>
<p>\[
P(A) = \sum_{k=0}^{p}{a_k A^k} .
\]</p>
<hr />
<p><strong>Proposition 17</strong></p>
<p>Pour tout \((P, Q)\in\mathbb{K}[X]^2\), les endomorphismes \(P(u)\) et
\(Q(u)\) commutent. En particulier, pour tout \(P\in\mathbb{K}[X]\),
\(Im(u)\) et \(Ker(u)\) sont des sous-espaces stables par \(u\).</p>
<hr />
<p><strong>Proposition 18</strong></p>
<ol>
<li>Si \(x\in E_\lambda (u)\) et si \(P\in\mathbb{K}[X]\) alors
\(P(u)(x) = P(\lambda) x\).</li>
<li>En particulier, si \(\lambda\) est valeur propre de \(u\),
alors \(P(\lambda)\) est valeur propre de \(P(u)\) et tout vecteur propre
de \(u\) associé a la valeur propre \(\lambda\) est vecteur propre de
\(P(u)\) associé la valeur propre \(P(\lambda)\).</li>
</ol>
<hr />
<p><strong>Corollaire 19</strong></p>
<p>Soit \(A\in\mathcal{M}_n(\mathbb{K})\).</p>
<ol>
<li>Si \(X\in E_\lambda(A)\) et si \(P\in \mathbb{K}[X]\) alors
\(P(A)X=P(\lambda)X\).</li>
<li>En particulier, si \(\lambda\) est valeur propre de \(A\),
alors \(P(\lambda)\) est valeur propre de \(P(A)\) et tout vecteur propre
de \(A\) associé a la valeur propre \(\lambda\) est vecteur propre de
\(P(A)\) associé la valeur propre \(P(\lambda)\).</li>
</ol>
<hr />
<hr />
<p><strong>Definition 8</strong></p>
<p>On dit que \(P\in\mathbb{K}[X]\) est un polynome annulateur de \(u\), s'il
vérifie \(P(u)=0\).</p>
<p>On dit que \(P\in\mathbb{K}[X]\) est un polynome annulateur de \(A\), s'il
vérifie \(P(A)=0\).</p>
<hr />
<hr />
<p><strong>Proposition 20</strong></p>
<p>Si \(P\) est un polynome annulateur de \(u\in\mathcal{L}(E)\), alors
toute valeur propre de \(u\) est racine de \(P\).</p>
<hr />
<hr />
<p><strong>Corollaire 21</strong></p>
<p>Si \(P\) est un polynome annulateur de \(A\in\mathcal{M}_n(\mathbb{K})\),
alors toute valeur propre de \(A\) est racine de \(P\).</p>
<hr />
<hr />
<p><strong>Corollaire 22</strong></p>
<p>Si \(P\) est un polynome annulateur de \(u\) tel que \(P(0)\neq 0\) et si
\(E\) est de dimension finie, alors \(u\) est bijectif.</p>
<hr />
<hr />
<p><strong>Corollaire 23</strong></p>
<p>Si \(P\) est un polynome annulateur de \(A\) et si \(P(0)\neq 0\), alors
\(A\) est inversible.</p>
<hr />
<hr />
<p><strong>Definition 9</strong></p>
<p>Soit \(A\in\mathcal{M}_n(\mathbb{K})\). On appelle polynome caracteristique de
\(A\) et on note \(\chi_A(X)\) l'unique polynome tel que:</p>
<p>\[
\forall \lambda \in \mathbb{C} \quad \chi_A(\lambda) = det(\lambda I_n - A).
\]</p>
<p>On note alors \(\chi_A(X)=det(XI_n-A)\).</p>
<hr />
<hr />
<p><strong>Theoreme 24</strong></p>
<p>\(\lambda\in\mathbb{K}\) est valeur propre de \(A\) si et seulement s'il est
racine du polynome caracteristique de \(A\).</p>
<hr />
<hr />
<p><strong>Proposition 25</strong></p>
<p>Si \(A\in\mathcal{M}_n(\mathbb{K})\) est triangulaire de diagonale
\((\alpha_1, ..., \alpha_n)\), alors son polynome caracteristique est:
\(\prod_{k=1}^{n}{(X-\alpha_k)}\) et \(sp(A)=\{\alpha_1,...,\alpha_n\}\).</p>
<hr />
<hr />
<p><strong>Corollaire 26</strong></p>
<p>Soit \(A\in\mathcal{M}_n(\mathbb{k})\).</p>
<ul>
<li>Si \(\mathbb{K}=\mathbb{C}\), alors \(A\) a au moins une valeur propre.</li>
<li>Si \(\mathbb{K}=\mathbb{R}\) et si \(n\) est impair, alors \(A\)
a au moins une valeur propre.</li>
</ul>
<hr />
<hr />
<p><strong>Proposition 27</strong></p>
<p>Soit \(A\in\mathcal{M}_n(K)\). Son polynome caracteristique \(\chi_A\) est
un polynome unitaire de degré \(n\) et l'on a :</p>
<p>\[
\chi_A(X) = X^n - (Tr(A))X^{n-1} + ... + (-1)^ndet(A).
\]</p>
<hr />
<hr />
<p><strong>Lemme 28</strong></p>
<p>Deux matrices semblables ont meme polynome caracteristique.</p>
<hr />
<hr />
<p><strong>Définition 10</strong></p>
<p>On appelle polynome caractéristique de l'endomorphisme \(u\) et l'on note
\(\chi_u\), le polynome caractéristique de toute matrice représentant \(u\).</p>
<p>On a donc, pour tout scalaire \(\lambda\),
\(\chi_u(\lambda)=det(\lambda Id_E - u)\).</p>
<hr />
<hr />
<p><strong>Proposition 29</strong></p>
<p>Le polynome caracteristique \(\chi_u\) est unitaire de degré \(n\) et l'on a :</p>
<p>\[
\chi_u(X) = X^n - (Tr(u))X^{n-1} + ... + (-1)^ndet(u).
\]</p>
<hr />
<hr />
<p><strong>Theoreme 30</strong></p>
<p>\(\lambda\in\mathbb{K}\) est valeur propre de \(u\) si et seulement s'il est
racine du polynome caracteristique de \(u\).</p>
<hr />
<hr />
<p><strong>Corollaire 31</strong></p>
<ul>
<li>Si \(\mathbb{K}=\mathbb{C}\), alors \(u\) a au moins une valeur propre.</li>
<li>Si \(\mathbb{K}=\mathbb{R}\) et si \(n\) est impair, alors \(u\)
a au moins une valeur propre.</li>
</ul>
<hr />
<hr />
<p><strong>Proposition 32</strong></p>
<p>Si \(F\) est un sous-espace vectoriel de \(E\) stable par \(u\), alors
le polynome caracteristique \(\chi_{u_F}\) de l'endomorphisme induit par
\(u\) sur \(F\) divise \(\chi_u\).</p>
<hr />
<hr />
<p><strong>Proposition 33</strong></p>
<p>Si le polynome caracteristique de \(u\) est scindé (respectivement scindé a
racines simples), alors celui de l'endomorphisme induit par \(u\) sur tout
sous-espace vectoriel de \(E\) stable par \(u\) l'est aussi.</p>
<hr />
<hr />
<p><strong>Definition 11</strong></p>
<p>On appelle ordre de multiplicité d'une valeur propre \(\lambda\) de \(u\)
(respectivement de \(A\)), son ordre de multiplicité en tant que racine du
polynome caractéristique de \(u\) (respectivement de \(A\)). On le note
\(m(\lambda)\).</p>
<hr />
<hr />
<p><strong>Proposition 34</strong></p>
<p>Pour tout \(\lambda \in sp(u)\), on a:</p>
<p>\[
1 \leq dim(E_\lambda(u)) \leq m(\lambda).
\]</p>
<hr />
<!-- </details> --><a class="header" href="print.html#about" id="about"><h1>About</h1></a>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        
        <script>
            $(document).ready(function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        
        <script type="text/javascript" src="highlightjs-line-numbers.js"></script>
        

    </body>
</html>
